{
  "symbols": [
    {
      "name": "get_sync_url",
      "kind": "function",
      "path": "apps/api/alembic/env.py",
      "line": 49,
      "signature": "get_sync_url() -> str",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "run_migrations_offline",
      "kind": "function",
      "path": "apps/api/alembic/env.py",
      "line": 64,
      "signature": "run_migrations_offline() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "do_run_migrations",
      "kind": "function",
      "path": "apps/api/alembic/env.py",
      "line": 72,
      "signature": "do_run_migrations(connection: Connection) -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "run_async_migrations",
      "kind": "async_function",
      "path": "apps/api/alembic/env.py",
      "line": 79,
      "signature": "async run_async_migrations() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "run_migrations_online",
      "kind": "function",
      "path": "apps/api/alembic/env.py",
      "line": 92,
      "signature": "run_migrations_online() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0001_initial.py",
      "line": 17,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0001_initial.py",
      "line": 197,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0002_import_sessions.py",
      "line": 16,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0002_import_sessions.py",
      "line": 46,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0003_enum_to_string.py",
      "line": 24,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0003_enum_to_string.py",
      "line": 87,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0004_importer_custom_fields.py",
      "line": 24,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0004_importer_custom_fields.py",
      "line": 67,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0005_custom_field_enhancements.py",
      "line": 15,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0005_custom_field_enhancements.py",
      "line": 41,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0006_custom_field_audit.py",
      "line": 15,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0006_custom_field_audit.py",
      "line": 33,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0007_custom_field_locking.py",
      "line": 15,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0007_custom_field_locking.py",
      "line": 51,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0008_replace_valuation_rules_v2.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0008_replace_valuation_rules_v2.py",
      "line": 171,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0009_add_profile_rule_group_weights.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0009_add_profile_rule_group_weights.py",
      "line": 30,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0010_add_application_settings_table.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0010_add_application_settings_table.py",
      "line": 41,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0011_add_cpu_igpu_mark.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0011_add_cpu_igpu_mark.py",
      "line": 24,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0012_add_listing_performance_metrics.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0012_add_listing_performance_metrics.py",
      "line": 33,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0013_add_listing_metadata_fields.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0013_add_listing_metadata_fields.py",
      "line": 31,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0014_add_cpu_passmark_fields.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0014_add_cpu_passmark_fields.py",
      "line": 26,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0015_listing_links_and_ruleset_priority.py",
      "line": 20,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0015_listing_links_and_ruleset_priority.py",
      "line": 75,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0016_add_rule_group_is_active.py",
      "line": 18,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0016_add_rule_group_is_active.py",
      "line": 33,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0017_ram_and_storage_profiles.py",
      "line": 25,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0017_ram_and_storage_profiles.py",
      "line": 173,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0018_add_rule_group_metadata.py",
      "line": 21,
      "signature": "upgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0018_add_rule_group_metadata.py",
      "line": 46,
      "signature": "downgrade() -> None",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0019_add_baseline_audit_log.py",
      "line": 19,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0019_add_baseline_audit_log.py",
      "line": 74,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0020_add_action_multipliers_schema_documentation.py",
      "line": 22,
      "signature": "upgrade()",
      "summary": "Add database comment documenting the modifiers_json schema structure.",
      "layer": "schema",
      "docstring": "Add database comment documenting the modifiers_json schema structure.",
      "category": "business_logic"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0020_add_action_multipliers_schema_documentation.py",
      "line": 62,
      "signature": "downgrade()",
      "summary": "Remove the database comment.",
      "layer": "schema",
      "docstring": "Remove the database comment.",
      "category": "business_logic"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0021_add_url_ingestion_foundation.py",
      "line": 25,
      "signature": "upgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0021_add_url_ingestion_foundation.py",
      "line": 89,
      "signature": "downgrade()",
      "summary": "",
      "layer": "core",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0022_add_progress_pct_to_import_session.py",
      "line": 21,
      "signature": "upgrade() -> None",
      "summary": "Add progress_pct field to import_session table.",
      "layer": "core",
      "docstring": "Add progress_pct field to import_session table.",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0022_add_progress_pct_to_import_session.py",
      "line": 28,
      "signature": "downgrade() -> None",
      "summary": "Remove progress_pct field from import_session table.",
      "layer": "core",
      "docstring": "Remove progress_pct field from import_session table.",
      "category": "migration"
    },
    {
      "name": "upgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0bfccac265c8_add_dedup_hash_field_to_listing_for_.py",
      "line": 21,
      "signature": "upgrade() -> None",
      "summary": "Upgrade schema.",
      "layer": "core",
      "docstring": "Upgrade schema.",
      "category": "migration"
    },
    {
      "name": "downgrade",
      "kind": "function",
      "path": "apps/api/alembic/versions/0bfccac265c8_add_dedup_hash_field_to_listing_for_.py",
      "line": 146,
      "signature": "downgrade() -> None",
      "summary": "Downgrade schema.",
      "layer": "core",
      "docstring": "Downgrade schema.",
      "category": "migration"
    },
    {
      "name": "create_app",
      "kind": "function",
      "path": "apps/api/dealbrain_api/__init__.py",
      "line": 13,
      "signature": "create_app() -> 'FastAPI'",
      "summary": "Factory wrapper that defers heavy imports until needed.",
      "layer": "core",
      "docstring": "Factory wrapper that defers heavy imports until needed.",
      "category": "config"
    },
    {
      "name": "run",
      "kind": "function",
      "path": "apps/api/dealbrain_api/main.py",
      "line": 14,
      "signature": "run() -> None",
      "summary": "Launch the FastAPI app with Uvicorn.",
      "layer": "core",
      "docstring": "Launch the FastAPI app with Uvicorn.",
      "category": "business_logic"
    },
    {
      "name": "get_app",
      "kind": "function",
      "path": "apps/api/dealbrain_api/main.py",
      "line": 25,
      "signature": "get_app()",
      "summary": "Factory used by uvicorn to instantiate the app.",
      "layer": "core",
      "docstring": "Factory used by uvicorn to instantiate the app.",
      "category": "business_logic"
    },
    {
      "name": "CacheManager",
      "kind": "class",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 20,
      "signature": "class CacheManager",
      "summary": "Manages Redis cache connections and operations.",
      "layer": "core",
      "docstring": "Manages Redis cache connections and operations.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 23,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "core",
      "parent": "CacheManager",
      "category": "business_logic"
    },
    {
      "name": "get_redis",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 27,
      "signature": "async get_redis(self) -> aioredis.Redis",
      "summary": "Get or create Redis connection.",
      "layer": "core",
      "parent": "CacheManager",
      "docstring": "Get or create Redis connection.",
      "category": "business_logic"
    },
    {
      "name": "close",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 37,
      "signature": "async close(self)",
      "summary": "Close Redis connection.",
      "layer": "core",
      "parent": "CacheManager",
      "docstring": "Close Redis connection.",
      "category": "business_logic"
    },
    {
      "name": "get",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 43,
      "signature": "async get(self, key: str) -> Optional[str]",
      "summary": "Get value from cache.",
      "layer": "core",
      "parent": "CacheManager",
      "docstring": "Get value from cache.",
      "category": "business_logic"
    },
    {
      "name": "set",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 52,
      "signature": "async set(self, key: str, value: str, ttl: Optional[timedelta]) -> bool",
      "summary": "Set value in cache with optional TTL.",
      "layer": "core",
      "parent": "CacheManager",
      "docstring": "Set value in cache with optional TTL.",
      "category": "business_logic"
    },
    {
      "name": "delete",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 70,
      "signature": "async delete(self, key: str) -> bool",
      "summary": "Delete key from cache.",
      "layer": "core",
      "parent": "CacheManager",
      "docstring": "Delete key from cache.",
      "category": "business_logic"
    },
    {
      "name": "delete_pattern",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 80,
      "signature": "async delete_pattern(self, pattern: str) -> int",
      "summary": "Delete all keys matching pattern.",
      "layer": "core",
      "parent": "CacheManager",
      "docstring": "Delete all keys matching pattern.",
      "category": "business_logic"
    },
    {
      "name": "cache_key",
      "kind": "function",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 97,
      "signature": "cache_key() -> str",
      "summary": "Generate cache key from function arguments.",
      "layer": "core",
      "docstring": "Generate cache key from function arguments.",
      "category": "business_logic"
    },
    {
      "name": "cached",
      "kind": "function",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 112,
      "signature": "cached(prefix: str, ttl: Optional[timedelta], key_func: Optional[Callable])",
      "summary": "Decorator for caching async function results in Redis.",
      "layer": "core",
      "docstring": "Decorator for caching async function results in Redis.\n\nArgs:\n    prefix: Cache key prefix (e.g., \"ruleset\", \"rule_eval\")\n    ttl: Time-to-live for cached values\n    key_func: Optional function to generate cache key from args\n\nExample:\n    @cached(prefix=\"ruleset\", ttl=timedelta(minutes=30))\n    async def get_ruleset(session, ruleset_id: int):\n        ...",
      "category": "business_logic"
    },
    {
      "name": "invalidate_cache_pattern",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 167,
      "signature": "async invalidate_cache_pattern(pattern: str) -> int",
      "summary": "Invalidate all cache keys matching pattern.",
      "layer": "core",
      "docstring": "Invalidate all cache keys matching pattern.\n\nExample:\n    await invalidate_cache_pattern(\"ruleset:*\")\n    await invalidate_cache_pattern(\"rule_eval:123:*\")",
      "category": "business_logic"
    },
    {
      "name": "invalidate_ruleset_cache",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 178,
      "signature": "async invalidate_ruleset_cache(ruleset_id: int)",
      "summary": "Invalidate all cache entries for a ruleset.",
      "layer": "core",
      "docstring": "Invalidate all cache entries for a ruleset.",
      "category": "business_logic"
    },
    {
      "name": "invalidate_rule_cache",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/cache.py",
      "line": 184,
      "signature": "async invalidate_rule_cache(rule_id: int)",
      "summary": "Invalidate all cache entries for a rule.",
      "layer": "core",
      "docstring": "Invalidate all cache entries for a rule.",
      "category": "business_logic"
    },
    {
      "name": "Base",
      "kind": "class",
      "path": "apps/api/dealbrain_api/db.py",
      "line": 14,
      "signature": "class Base(DeclarativeBase)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_engine",
      "kind": "function",
      "path": "apps/api/dealbrain_api/db.py",
      "line": 22,
      "signature": "get_engine() -> AsyncEngine",
      "summary": "Return a singleton async engine.",
      "layer": "core",
      "docstring": "Return a singleton async engine.",
      "category": "business_logic"
    },
    {
      "name": "get_session_factory",
      "kind": "function",
      "path": "apps/api/dealbrain_api/db.py",
      "line": 40,
      "signature": "get_session_factory() -> async_sessionmaker[AsyncSession]",
      "summary": "Return a configured session factory.",
      "layer": "core",
      "docstring": "Return a configured session factory.",
      "category": "business_logic"
    },
    {
      "name": "session_scope",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/db.py",
      "line": 49,
      "signature": "async session_scope() -> AsyncIterator[AsyncSession]",
      "summary": "Provide a transactional scope for async operations.",
      "layer": "core",
      "docstring": "Provide a transactional scope for async operations.",
      "category": "business_logic"
    },
    {
      "name": "session_dependency",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/db.py",
      "line": 65,
      "signature": "async session_dependency() -> AsyncIterator[AsyncSession]",
      "summary": "Dependency for FastAPI routes to inject a session.",
      "layer": "core",
      "docstring": "Dependency for FastAPI routes to inject a session.",
      "category": "business_logic"
    },
    {
      "name": "create_app",
      "kind": "function",
      "path": "apps/api/dealbrain_api/app.py",
      "line": 10,
      "signature": "create_app() -> FastAPI",
      "summary": "Create and configure the FastAPI app instance.",
      "layer": "core",
      "docstring": "Create and configure the FastAPI app instance.",
      "category": "business_logic"
    },
    {
      "name": "AdapterConfig",
      "kind": "class",
      "path": "apps/api/dealbrain_api/settings.py",
      "line": 16,
      "signature": "class AdapterConfig(BaseModel)",
      "summary": "Configuration for a single URL ingestion adapter.",
      "layer": "core",
      "docstring": "Configuration for a single URL ingestion adapter.",
      "category": "config"
    },
    {
      "name": "IngestionSettings",
      "kind": "class",
      "path": "apps/api/dealbrain_api/settings.py",
      "line": 41,
      "signature": "class IngestionSettings(BaseModel)",
      "summary": "Configuration for URL ingestion system.",
      "layer": "core",
      "docstring": "Configuration for URL ingestion system.",
      "category": "config"
    },
    {
      "name": "TelemetrySettings",
      "kind": "class",
      "path": "apps/api/dealbrain_api/settings.py",
      "line": 103,
      "signature": "class TelemetrySettings(BaseModel)",
      "summary": "Configuration for application telemetry.",
      "layer": "core",
      "docstring": "Configuration for application telemetry.",
      "category": "config"
    },
    {
      "name": "Settings",
      "kind": "class",
      "path": "apps/api/dealbrain_api/settings.py",
      "line": 136,
      "signature": "class Settings(BaseSettings)",
      "summary": "",
      "layer": "core",
      "category": "config"
    },
    {
      "name": "model_post_init",
      "kind": "method",
      "path": "apps/api/dealbrain_api/settings.py",
      "line": 185,
      "signature": "model_post_init(self, __context) -> None",
      "summary": "Post-initialization hook to inject API keys into adapter configs.",
      "layer": "core",
      "parent": "Settings",
      "docstring": "Post-initialization hook to inject API keys into adapter configs.",
      "category": "config"
    },
    {
      "name": "get_settings",
      "kind": "function",
      "path": "apps/api/dealbrain_api/settings.py",
      "line": 194,
      "signature": "get_settings() -> Settings",
      "summary": "Return cached application settings.",
      "layer": "core",
      "docstring": "Return cached application settings.",
      "category": "config"
    },
    {
      "name": "ping",
      "kind": "function",
      "path": "apps/api/dealbrain_api/worker.py",
      "line": 28,
      "signature": "ping() -> str",
      "summary": "Simple task to verify the worker wiring.",
      "layer": "core",
      "docstring": "Simple task to verify the worker wiring.",
      "category": "business_logic"
    },
    {
      "name": "dashboard",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/dashboard.py",
      "line": 16,
      "signature": "async dashboard(budget: float, session: AsyncSession) -> dict",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "rankings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rankings.py",
      "line": 29,
      "signature": "async rankings(metric: str, limit: int, session: AsyncSession) -> Sequence[ListingRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_entities",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/field_data.py",
      "line": 16,
      "signature": "async list_entities() -> dict[str, list[dict[str, str]]]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "entity_schema",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/field_data.py",
      "line": 30,
      "signature": "async entity_schema(entity: str, db: AsyncSession) -> dict[str, object]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_entity_records",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/field_data.py",
      "line": 38,
      "signature": "async list_entity_records(entity: str, limit: int, offset: int, db: AsyncSession) -> dict[str, object]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_entity_record",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/field_data.py",
      "line": 51,
      "signature": "async create_entity_record(entity: str, payload: dict, db: AsyncSession) -> dict[str, object]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "update_entity_record",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/field_data.py",
      "line": 64,
      "signature": "async update_entity_record(entity: str, record_id: int, payload: dict, db: AsyncSession) -> dict[str, object]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_import_session",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 49,
      "signature": "async create_import_session(upload: UploadFile, declared_entities: str | None, db: AsyncSession) -> ImportSessionSnapshotModel",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_import_sessions",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 92,
      "signature": "async list_import_sessions(db: AsyncSession) -> ImportSessionListModel",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_import_session",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 116,
      "signature": "async get_import_session(session_id: UUID, db: AsyncSession) -> ImportSessionSnapshotModel",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "update_import_mappings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 141,
      "signature": "async update_import_mappings(session_id: UUID, request: UpdateMappingsRequest, db: AsyncSession) -> ImportSessionSnapshotModel",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "refresh_conflicts",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 168,
      "signature": "async refresh_conflicts(session_id: UUID, db: AsyncSession) -> ImportSessionSnapshotModel",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "commit_import_session",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 193,
      "signature": "async commit_import_session(session_id: UUID, request: CommitImportRequest, db: AsyncSession) -> CommitImportResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_import_field",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 248,
      "signature": "async create_import_field(session_id: UUID, request: ImporterFieldCreateRequest, db: AsyncSession) -> ImporterFieldCreateResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ImportRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 300,
      "signature": "class ImportRequest(BaseModel)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ImportResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 304,
      "signature": "class ImportResponse(BaseModel)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "import_workbook",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/imports.py",
      "line": 311,
      "signature": "async import_workbook(payload: ImportRequest) -> ImportResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_custom_fields",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/custom_fields.py",
      "line": 24,
      "signature": "async list_custom_fields(entity: str | None, include_inactive: bool, include_deleted: bool, db: AsyncSession) -> CustomFieldListResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_custom_field",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/custom_fields.py",
      "line": 40,
      "signature": "async create_custom_field(request: CustomFieldCreateRequest, db: AsyncSession) -> CustomFieldResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "update_custom_field",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/custom_fields.py",
      "line": 67,
      "signature": "async update_custom_field(field_id: int, request: CustomFieldUpdateRequest, force: bool, db: AsyncSession) -> CustomFieldResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "add_field_option",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/custom_fields.py",
      "line": 107,
      "signature": "async add_field_option(field_id: int, request: AddFieldOptionRequest, db: AsyncSession) -> FieldOptionResponse",
      "summary": "Add a new option to a dropdown or multi-select field.",
      "layer": "core",
      "docstring": "Add a new option to a dropdown or multi-select field.\n\nThis endpoint allows inline creation of dropdown options from the UI.\nThe option will be immediately available for selection.\n\nArgs:\n    field_id: ID of the field to add the option to\n    request: Request containing the option value\n    db: Database session\n\nReturns:\n    Updated field with all current options\n\nRaises:\n    404: Field not found\n    400: Invalid field type or duplicate option",
      "category": "business_logic"
    },
    {
      "name": "delete_custom_field",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/custom_fields.py",
      "line": 151,
      "signature": "async delete_custom_field(field_id: int, hard_delete: bool, force: bool, db: AsyncSession)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_entities_metadata",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/entities.py",
      "line": 14,
      "signature": "async get_entities_metadata(db: AsyncSession) -> dict",
      "summary": "Get metadata for all entities and fields for rule builder.",
      "layer": "core",
      "docstring": "Get metadata for all entities and fields for rule builder.",
      "category": "business_logic"
    },
    {
      "name": "SettingResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/settings.py",
      "line": 14,
      "signature": "class SettingResponse(BaseModel)",
      "summary": "Setting response schema.",
      "layer": "core",
      "docstring": "Setting response schema.",
      "category": "config"
    },
    {
      "name": "SettingUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/settings.py",
      "line": 21,
      "signature": "class SettingUpdateRequest(BaseModel)",
      "summary": "Setting update request schema.",
      "layer": "core",
      "docstring": "Setting update request schema.",
      "category": "config"
    },
    {
      "name": "get_setting",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/settings.py",
      "line": 28,
      "signature": "async get_setting(key: str, session: AsyncSession)",
      "summary": "Get a setting by key.",
      "layer": "core",
      "docstring": "Get a setting by key.",
      "category": "config"
    },
    {
      "name": "update_setting",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/settings.py",
      "line": 43,
      "signature": "async update_setting(key: str, request: SettingUpdateRequest, session: AsyncSession)",
      "summary": "Update or create a setting.",
      "layer": "core",
      "docstring": "Update or create a setting.",
      "category": "config"
    },
    {
      "name": "get_valuation_thresholds",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/settings.py",
      "line": 60,
      "signature": "async get_valuation_thresholds(session: AsyncSession)",
      "summary": "Get valuation thresholds (backwards compatibility endpoint).",
      "layer": "core",
      "docstring": "Get valuation thresholds (backwards compatibility endpoint).",
      "category": "config"
    },
    {
      "name": "require_admin",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 25,
      "signature": "async require_admin() -> None",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "TaskSubmissionResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 29,
      "signature": "class TaskSubmissionResponse(BaseModel)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ValuationRecalcRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 37,
      "signature": "class ValuationRecalcRequest(BaseModel)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "MetricsRecalcRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 45,
      "signature": "class MetricsRecalcRequest(BaseModel)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "TaskStatusResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 49,
      "signature": "class TaskStatusResponse(BaseModel)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "trigger_valuation_recalc",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 59,
      "signature": "async trigger_valuation_recalc(request: ValuationRecalcRequest, _user) -> TaskSubmissionResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "trigger_metric_recalc",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 73,
      "signature": "async trigger_metric_recalc(request: MetricsRecalcRequest, _user) -> TaskSubmissionResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "trigger_cpu_mark_recalc",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 87,
      "signature": "async trigger_cpu_mark_recalc(request: MetricsRecalcRequest, _user) -> TaskSubmissionResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "trigger_passmark_import",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 101,
      "signature": "async trigger_passmark_import(upload: UploadFile, _user) -> TaskSubmissionResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "trigger_entity_import",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 119,
      "signature": "async trigger_entity_import(entity: str, dry_run: bool, upload: UploadFile, _user) -> TaskSubmissionResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_task_status",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/admin.py",
      "line": 139,
      "signature": "async get_task_status(task_id: str, _user) -> TaskStatusResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_baseline_metrics",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/metrics.py",
      "line": 13,
      "signature": "async get_baseline_metrics(session: AsyncSession) -> dict",
      "summary": "Get comprehensive baseline metrics.",
      "layer": "core",
      "docstring": "Get comprehensive baseline metrics.\n\nReturns metrics about:\n- Layer influence (% of listings affected by each layer)\n- Top contributing rules by absolute value\n- Override churn rates\n- Current baseline information\n\nReturns:\n    Dictionary with baseline metrics",
      "category": "business_logic"
    },
    {
      "name": "get_layer_influence",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/metrics.py",
      "line": 33,
      "signature": "async get_layer_influence(session: AsyncSession) -> dict",
      "summary": "Get percentage of listings influenced by each valuation layer.",
      "layer": "core",
      "docstring": "Get percentage of listings influenced by each valuation layer.\n\nReturns:\n    Dictionary with layer names and percentages",
      "category": "business_logic"
    },
    {
      "name": "get_top_rules",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/metrics.py",
      "line": 47,
      "signature": "async get_top_rules(limit: int, days: int, session: AsyncSession) -> dict",
      "summary": "Get top rules by absolute contribution amount.",
      "layer": "core",
      "docstring": "Get top rules by absolute contribution amount.\n\nArgs:\n    limit: Number of top rules to return (1-50)\n    days: Number of days to look back for aggregation (1-365)\n\nReturns:\n    List of top contributing rules",
      "category": "business_logic"
    },
    {
      "name": "get_override_churn",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/metrics.py",
      "line": 73,
      "signature": "async get_override_churn(days: int, session: AsyncSession) -> dict",
      "summary": "Get override churn rate over specified period.",
      "layer": "core",
      "docstring": "Get override churn rate over specified period.\n\nArgs:\n    days: Number of days to analyze (1-90)\n\nReturns:\n    Dictionary with churn metrics",
      "category": "business_logic"
    },
    {
      "name": "check_baseline_health",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/health.py",
      "line": 17,
      "signature": "async check_baseline_health(expected_hash: str | None, session: AsyncSession) -> dict[str, Any]",
      "summary": "Check health of baseline valuation system.",
      "layer": "core",
      "docstring": "Check health of baseline valuation system.\n\nChecks:\n- At least one active baseline ruleset exists\n- Baseline source_hash matches expected (if provided)\n- No stale baselines (warn if > 90 days old)\n- Basic Adjustments group exists in target ruleset\n\nArgs:\n    expected_hash: Expected source hash for baseline (optional)\n\nReturns:\n    Health status with detailed check results",
      "category": "business_logic"
    },
    {
      "name": "check_overall_health",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/health.py",
      "line": 118,
      "signature": "async check_overall_health(session: AsyncSession) -> dict[str, Any]",
      "summary": "Check overall system health including baseline subsystem.",
      "layer": "core",
      "docstring": "Check overall system health including baseline subsystem.\n\nReturns:\n    Overall health status",
      "category": "business_logic"
    },
    {
      "name": "get_baseline_metadata",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 31,
      "signature": "async get_baseline_metadata(session: AsyncSession)",
      "summary": "Get metadata for the currently active baseline ruleset.",
      "layer": "core",
      "docstring": "Get metadata for the currently active baseline ruleset.\n\nReturns baseline field definitions, version info, and source hash.\nPublic endpoint for UI metadata population.\n\nReturns:\n    BaselineMetadataResponse if active baseline exists, None otherwise",
      "category": "business_logic"
    },
    {
      "name": "get_baseline_metadata_alias",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 55,
      "signature": "async get_baseline_metadata_alias(session: AsyncSession)",
      "summary": "Alias for /meta endpoint for backwards compatibility.",
      "layer": "core",
      "docstring": "Alias for /meta endpoint for backwards compatibility.\n\nReturns:\n    BaselineMetadataResponse if active baseline exists, None otherwise",
      "category": "business_logic"
    },
    {
      "name": "instantiate_baseline",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 69,
      "signature": "async instantiate_baseline(request: BaselineInstantiateRequest, session: AsyncSession)",
      "summary": "Instantiate a baseline ruleset from a JSON file (idempotent).",
      "layer": "core",
      "docstring": "Instantiate a baseline ruleset from a JSON file (idempotent).\n\nIf a ruleset with the same source hash already exists, returns existing\nruleset info with created=false. Otherwise creates new baseline ruleset.\n\nRequires: baseline:admin permission (RBAC integration point)\n\nArgs:\n    request: Contains baseline_path, create_adjustments_group flag, and actor\n\nReturns:\n    BaselineInstantiateResponse with ruleset info and creation status",
      "category": "business_logic"
    },
    {
      "name": "diff_baseline",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 129,
      "signature": "async diff_baseline(request: BaselineDiffRequest, session: AsyncSession)",
      "summary": "Compare candidate baseline JSON against current active baseline.",
      "layer": "core",
      "docstring": "Compare candidate baseline JSON against current active baseline.\n\nReturns field-level granular diff showing added, changed, and removed fields.\n\nRequires: baseline:admin permission (RBAC integration point)\n\nArgs:\n    request: Contains candidate_json and optional actor\n\nReturns:\n    BaselineDiffResponse with added, changed, removed fields and summary",
      "category": "business_logic"
    },
    {
      "name": "adopt_baseline",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 164,
      "signature": "async adopt_baseline(request: BaselineAdoptRequest, session: AsyncSession)",
      "summary": "Adopt selected changes from candidate baseline, creating new version.",
      "layer": "core",
      "docstring": "Adopt selected changes from candidate baseline, creating new version.\n\nCreates a NEW baseline ruleset version with selected changes. Never mutates existing\nrulesets. Previous baseline is deactivated automatically.\n\nRequires: baseline:admin permission (RBAC integration point)\n\nArgs:\n    request: Contains candidate_json, optional selected_changes,\n             trigger_recalculation, and actor\n\nReturns:\n    BaselineAdoptResponse with new ruleset info and audit details",
      "category": "business_logic"
    },
    {
      "name": "hydrate_baseline_rules",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 227,
      "signature": "async hydrate_baseline_rules(ruleset_id: int, request: HydrateBaselineRequest, session: AsyncSession)",
      "summary": "Hydrate placeholder baseline rules for Advanced mode editing.",
      "layer": "core",
      "docstring": "Hydrate placeholder baseline rules for Advanced mode editing.\n\nConverts compact baseline placeholder rules into expanded, editable rules\nwith explicit conditions and actions. This enables the transition from\nBasic mode (compact baseline) to Advanced mode (full rule editing).\n\nRequires: baseline:admin permission (RBAC integration point)\n\nArgs:\n    ruleset_id: ID of the ruleset containing placeholder rules to hydrate\n    request: Contains optional actor field\n\nReturns:\n    HydrateBaselineResponse with status, counts, and hydration summary\n\nRaises:\n    HTTPException: 404 if ruleset not found, 500 if hydration fails",
      "category": "business_logic"
    },
    {
      "name": "get_entity_overrides",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 299,
      "signature": "async get_entity_overrides(entity_key: str, session: AsyncSession)",
      "summary": "Get all field overrides for an entity.",
      "layer": "core",
      "docstring": "Get all field overrides for an entity.\n\nTODO: Implement full override management via Basic Adjustments group.\nFor now, returns empty list to allow UI to load.\n\nArgs:\n    entity_key: Entity identifier (e.g., 'listing', 'cpu', 'gpu')\n\nReturns:\n    List of field overrides (currently empty stub)",
      "category": "business_logic"
    },
    {
      "name": "upsert_field_override",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 321,
      "signature": "async upsert_field_override(override: dict[str, Any], session: AsyncSession)",
      "summary": "Create or update a field override.",
      "layer": "core",
      "docstring": "Create or update a field override.\n\nTODO: Implement by updating modifiers_json in Basic Adjustments group.\nFor now, returns the input unchanged.\n\nArgs:\n    override: Field override data (field_name, entity_key, override_value, etc.)\n\nReturns:\n    The created/updated override (currently echo stub)",
      "category": "business_logic"
    },
    {
      "name": "delete_field_override",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 342,
      "signature": "async delete_field_override(entity_key: str, field_name: str, session: AsyncSession)",
      "summary": "Delete a specific field override (reset to baseline).",
      "layer": "core",
      "docstring": "Delete a specific field override (reset to baseline).\n\nTODO: Implement by removing field from modifiers_json.\n\nArgs:\n    entity_key: Entity identifier\n    field_name: Field name to reset\n\nReturns:\n    Success status",
      "category": "business_logic"
    },
    {
      "name": "delete_entity_overrides",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 364,
      "signature": "async delete_entity_overrides(entity_key: str, session: AsyncSession)",
      "summary": "Delete all overrides for an entity.",
      "layer": "core",
      "docstring": "Delete all overrides for an entity.\n\nTODO: Implement by clearing modifiers_json for entity.\n\nArgs:\n    entity_key: Entity identifier\n\nReturns:\n    Success status",
      "category": "business_logic"
    },
    {
      "name": "preview_impact",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 386,
      "signature": "async preview_impact(entity_key: str | None, sample_size: int, session: AsyncSession)",
      "summary": "Preview the impact of current overrides on listings.",
      "layer": "core",
      "docstring": "Preview the impact of current overrides on listings.\n\nTODO: Implement by running evaluation with/without overrides.\nFor now, returns stub data.\n\nArgs:\n    entity_key: Optional entity filter\n    sample_size: Number of listings to sample\n\nReturns:\n    Preview statistics and sample listings",
      "category": "business_logic"
    },
    {
      "name": "export_baseline",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 422,
      "signature": "async export_baseline(session: AsyncSession)",
      "summary": "Export current baseline configuration including overrides.",
      "layer": "core",
      "docstring": "Export current baseline configuration including overrides.\n\nTODO: Implement by serializing active baseline + overrides.\n\nReturns:\n    Baseline metadata with current overrides applied",
      "category": "business_logic"
    },
    {
      "name": "validate_baseline",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/baseline.py",
      "line": 448,
      "signature": "async validate_baseline(payload: dict[str, Any], session: AsyncSession)",
      "summary": "Validate a baseline JSON structure.",
      "layer": "core",
      "docstring": "Validate a baseline JSON structure.\n\nTODO: Implement schema validation and constraint checking.\n\nArgs:\n    payload: Contains baseline_json or baseline object\n\nReturns:\n    Validation result with errors/warnings",
      "category": "business_logic"
    },
    {
      "name": "list_fields",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/fields.py",
      "line": 43,
      "signature": "async list_fields(entity: str | None, include_inactive: bool, include_deleted: bool, db: AsyncSession) -> FieldListResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_field",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/fields.py",
      "line": 59,
      "signature": "async create_field(request: FieldCreateRequest, actor: str | None, db: AsyncSession) -> FieldResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "update_field",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/fields.py",
      "line": 89,
      "signature": "async update_field(field_id: int, request: FieldUpdateRequest, force: bool, actor: str | None, db: AsyncSession) -> FieldResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "delete_field",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/fields.py",
      "line": 132,
      "signature": "async delete_field(field_id: int, hard_delete: bool, force: bool, actor: str | None, db: AsyncSession) -> FieldDeleteResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "field_history",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/fields.py",
      "line": 171,
      "signature": "async field_history(field_id: int, limit: int, db: AsyncSession) -> FieldAuditResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "field_usage",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/fields.py",
      "line": 197,
      "signature": "async field_usage(entity: str | None, db: AsyncSession) -> FieldUsageResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_field_values",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/fields.py",
      "line": 211,
      "signature": "async get_field_values(field_name: str, limit: int, search: str | None, db: AsyncSession) -> FieldValuesResponse",
      "summary": "Get distinct values for a field across all entities.",
      "layer": "core",
      "docstring": "Get distinct values for a field across all entities.\n\n**Examples:**\n- `/fields/listing.condition/values` -> [\"New\", \"Like New\", \"Good\", \"Fair\"]\n- `/fields/cpu.manufacturer/values?limit=5` -> [\"Intel\", \"AMD\", \"Apple\", ...]\n- `/fields/listing.seller/values?search=ebay` -> [\"ebay_seller_1\", \"ebay_seller_2\"]",
      "category": "business_logic"
    },
    {
      "name": "parse_csv_file",
      "kind": "function",
      "path": "apps/api/dealbrain_api/api/ingestion.py",
      "line": 38,
      "signature": "parse_csv_file(content: bytes) -> list[str]",
      "summary": "Parse CSV file content and extract URLs.",
      "layer": "core",
      "docstring": "Parse CSV file content and extract URLs.\n\nExpected CSV format:\n    url\n    https://www.ebay.com/itm/123456789\n    https://www.amazon.com/dp/B08N5WRWNW\n\nArgs:\n    content: Raw CSV file bytes\n\nReturns:\n    List of URL strings\n\nRaises:\n    ValueError: If CSV is invalid or missing 'url' column",
      "category": "business_logic"
    },
    {
      "name": "parse_json_file",
      "kind": "function",
      "path": "apps/api/dealbrain_api/api/ingestion.py",
      "line": 82,
      "signature": "parse_json_file(content: bytes) -> list[str]",
      "summary": "Parse JSON file content and extract URLs.",
      "layer": "core",
      "docstring": "Parse JSON file content and extract URLs.\n\nExpected JSON format:\n    [\n      {\"url\": \"https://www.ebay.com/itm/123456789\"},\n      {\"url\": \"https://www.amazon.com/dp/B08N5WRWNW\"}\n    ]\n\nArgs:\n    content: Raw JSON file bytes\n\nReturns:\n    List of URL strings\n\nRaises:\n    ValueError: If JSON is invalid or missing 'url' fields",
      "category": "business_logic"
    },
    {
      "name": "create_bulk_url_import",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/ingestion.py",
      "line": 136,
      "signature": "async create_bulk_url_import(file: UploadFile, session: AsyncSession) -> BulkIngestionResponse",
      "summary": "Create a bulk URL import job from CSV or JSON file upload.",
      "layer": "core",
      "docstring": "Create a bulk URL import job from CSV or JSON file upload.\n\nThis endpoint accepts a file upload (CSV or JSON format) containing up to 1000 URLs,\ncreates a parent ImportSession and child sessions for each URL, and queues Celery tasks\nfor asynchronous processing.\n\nFile Formats:\n\nCSV format (header: url):\n```csv\nurl\nhttps://www.ebay.com/itm/123456789\nhttps://www.amazon.com/dp/B08N5WRWNW\n```\n\nJSON format:\n```json\n[\n  {\"url\": \"https://www.ebay.com/itm/123456789\"},\n  {\"url\": \"https://www.amazon.com/dp/B08N5WRWNW\"}\n]\n```\n\nArgs:\n    file: Uploaded CSV or JSON file (multipart/form-data)\n    session: Database session (injected)\n\nReturns:\n    BulkIngestionResponse with bulk_job_id and total_urls\n\nRaises:\n    HTTPException:\n        400: Invalid file format, empty file, or parse errors\n        413: More than 1000 URLs in file\n        422: Invalid URL format in file\n        500: Unexpected server errors\n\nExample:\n    POST /api/v1/ingest/bulk\n    Content-Type: multipart/form-data\n    file: urls.csv\n\n    Response (202):\n    {\n        \"bulk_job_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n        \"total_urls\": 42\n    }",
      "category": "business_logic"
    },
    {
      "name": "create_single_url_import",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/ingestion.py",
      "line": 362,
      "signature": "async create_single_url_import(request: IngestionRequest, session: AsyncSession) -> IngestionResponse",
      "summary": "Create a single URL import job and queue it for processing.",
      "layer": "core",
      "docstring": "Create a single URL import job and queue it for processing.\n\nThis endpoint accepts a URL, validates it, creates an ImportSession record,\nand queues a Celery task for asynchronous ingestion. The task will:\n1. Fetch and parse the URL using the adapter router\n2. Extract product data (title, price, specs, etc.)\n3. Create or update a Listing record\n4. Store provenance and quality metadata\n\nArgs:\n    request: IngestionRequest containing URL and optional priority\n    session: Database session (injected)\n\nReturns:\n    IngestionResponse with job_id and status='queued'\n\nRaises:\n    HTTPException: For validation errors (422) or server errors (500)\n\nExample:\n    POST /api/v1/ingest/single\n    {\n        \"url\": \"https://www.ebay.com/itm/123456789012\",\n        \"priority\": \"normal\"\n    }\n\n    Response (202):\n    {\n        \"job_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n        \"status\": \"queued\",\n        \"listing_id\": null,\n        \"provenance\": null,\n        \"quality\": null,\n        \"errors\": []\n    }",
      "category": "business_logic"
    },
    {
      "name": "get_ingestion_status",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/ingestion.py",
      "line": 461,
      "signature": "async get_ingestion_status(job_id: str, session: AsyncSession) -> IngestionResponse",
      "summary": "Retrieve the status of an ingestion job.",
      "layer": "core",
      "docstring": "Retrieve the status of an ingestion job.\n\nThis endpoint fetches the ImportSession record and returns the current status,\nalong with any results (listing_id, provenance, quality) or errors.\n\nArgs:\n    job_id: ImportSession UUID as string\n    session: Database session (injected)\n\nReturns:\n    IngestionResponse with job status and results\n\nRaises:\n    HTTPException: 404 if job not found, 422 if invalid UUID format\n\nExample:\n    GET /api/v1/ingest/550e8400-e29b-41d4-a716-446655440000\n\n    Response (200):\n    {\n        \"job_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n        \"status\": \"complete\",\n        \"listing_id\": 123,\n        \"provenance\": \"ebay_api\",\n        \"quality\": \"full\",\n        \"errors\": []\n    }",
      "category": "business_logic"
    },
    {
      "name": "get_bulk_ingestion_status",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/ingestion.py",
      "line": 563,
      "signature": "async get_bulk_ingestion_status(bulk_job_id: str, offset: int, limit: int, session: AsyncSession) -> BulkIngestionStatusResponse",
      "summary": "Retrieve the aggregated status of a bulk URL ingestion job.",
      "layer": "core",
      "docstring": "Retrieve the aggregated status of a bulk URL ingestion job.\n\nThis endpoint fetches the parent ImportSession and all child ImportSession records\nfor a bulk job, aggregates status counts, and returns per-URL status information\nwith pagination support.\n\nStatus Aggregation Logic:\n- total_urls: Total number of URLs in the bulk job\n- completed: Number of URLs finished (complete + partial + failed)\n- success: Number of URLs successfully completed (complete only)\n- partial: Number of partially completed URLs\n- failed: Number of failed URLs\n- running: Number of URLs currently being processed\n- queued: Number of URLs waiting to be processed\n\nOverall Status Logic:\n- \"queued\": All children are queued\n- \"running\": At least one child is running or queued (but not all queued)\n- \"complete\": All children are complete/partial/failed (100% done)\n- \"partial\": Some children complete and some failed\n- \"failed\": All children failed\n\nArgs:\n    bulk_job_id: Parent ImportSession UUID as string\n    offset: Pagination offset (default: 0)\n    limit: Pagination limit (default: 100, max: 1000)\n    session: Database session (injected)\n\nReturns:\n    BulkIngestionStatusResponse with aggregated status and per-URL details\n\nRaises:\n    HTTPException:\n        404: Bulk job not found\n        422: Invalid UUID format\n        500: Unexpected server errors\n\nExample:\n    GET /api/v1/ingest/bulk/550e8400-e29b-41d4-a716-446655440000?offset=0&limit=50\n\n    Response (200):\n    {\n        \"bulk_job_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n        \"status\": \"running\",\n        \"total_urls\": 42,\n        \"completed\": 30,\n        \"success\": 25,\n        \"partial\": 3,\n        \"failed\": 2,\n        \"running\": 5,\n        \"queued\": 7,\n        \"per_row_status\": [\n            {\n                \"url\": \"https://ebay.com/itm/123\",\n                \"status\": \"complete\",\n                \"listing_id\": 456,\n                \"error\": null\n            },\n            ...\n        ],\n        \"offset\": 0,\n        \"limit\": 50,\n        \"has_more\": false\n    }",
      "category": "business_logic"
    },
    {
      "name": "create_ruleset",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 61,
      "signature": "async create_ruleset(request: RulesetCreateRequest, session: AsyncSession)",
      "summary": "Create a new valuation ruleset",
      "layer": "core",
      "docstring": "Create a new valuation ruleset",
      "category": "business_logic"
    },
    {
      "name": "list_rulesets",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 95,
      "signature": "async list_rulesets(active_only: bool, skip: int, limit: int, session: AsyncSession)",
      "summary": "List all valuation rulesets",
      "layer": "core",
      "docstring": "List all valuation rulesets",
      "category": "business_logic"
    },
    {
      "name": "get_ruleset",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 130,
      "signature": "async get_ruleset(ruleset_id: int, session: AsyncSession)",
      "summary": "Get a ruleset by ID with all groups and rules",
      "layer": "core",
      "docstring": "Get a ruleset by ID with all groups and rules",
      "category": "business_logic"
    },
    {
      "name": "update_ruleset",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 223,
      "signature": "async update_ruleset(ruleset_id: int, request: RulesetUpdateRequest, session: AsyncSession)",
      "summary": "Update a ruleset",
      "layer": "core",
      "docstring": "Update a ruleset",
      "category": "business_logic"
    },
    {
      "name": "delete_ruleset",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 255,
      "signature": "async delete_ruleset(ruleset_id: int, session: AsyncSession)",
      "summary": "Delete a ruleset (cascades to groups and rules)",
      "layer": "core",
      "docstring": "Delete a ruleset (cascades to groups and rules)",
      "category": "business_logic"
    },
    {
      "name": "create_rule_group",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 272,
      "signature": "async create_rule_group(request: RuleGroupCreateRequest, session: AsyncSession)",
      "summary": "Create a new rule group",
      "layer": "core",
      "docstring": "Create a new rule group",
      "category": "business_logic"
    },
    {
      "name": "list_rule_groups",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 322,
      "signature": "async list_rule_groups(ruleset_id: int | None, category: str | None, session: AsyncSession) -> list[RuleGroupResponse]",
      "summary": "List rule groups",
      "layer": "core",
      "docstring": "List rule groups",
      "category": "business_logic"
    },
    {
      "name": "get_rule_group",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 366,
      "signature": "async get_rule_group(group_id: int, session: AsyncSession) -> RuleGroupResponse",
      "summary": "Get a rule group by ID",
      "layer": "core",
      "docstring": "Get a rule group by ID",
      "category": "business_logic"
    },
    {
      "name": "update_rule_group",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 439,
      "signature": "async update_rule_group(group_id: int, request: RuleGroupUpdateRequest, session: AsyncSession) -> RuleGroupResponse",
      "summary": "Update a rule group",
      "layer": "core",
      "docstring": "Update a rule group",
      "category": "business_logic"
    },
    {
      "name": "create_rule",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 503,
      "signature": "async create_rule(request: RuleCreateRequest, session: AsyncSession)",
      "summary": "Create a new valuation rule",
      "layer": "core",
      "docstring": "Create a new valuation rule",
      "category": "business_logic"
    },
    {
      "name": "list_rules",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 557,
      "signature": "async list_rules(group_id: int | None, active_only: bool, skip: int, limit: int, session: AsyncSession)",
      "summary": "List valuation rules",
      "layer": "core",
      "docstring": "List valuation rules",
      "category": "business_logic"
    },
    {
      "name": "get_rule",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 616,
      "signature": "async get_rule(rule_id: int, session: AsyncSession)",
      "summary": "Get a valuation rule by ID",
      "layer": "core",
      "docstring": "Get a valuation rule by ID",
      "category": "business_logic"
    },
    {
      "name": "update_rule",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 666,
      "signature": "async update_rule(rule_id: int, request: RuleUpdateRequest, session: AsyncSession)",
      "summary": "Update a valuation rule",
      "layer": "core",
      "docstring": "Update a valuation rule",
      "category": "business_logic"
    },
    {
      "name": "delete_rule",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 739,
      "signature": "async delete_rule(rule_id: int, session: AsyncSession)",
      "summary": "Delete a valuation rule",
      "layer": "core",
      "docstring": "Delete a valuation rule",
      "category": "business_logic"
    },
    {
      "name": "preview_rule",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 767,
      "signature": "async preview_rule(request: RulePreviewRequest, session: AsyncSession)",
      "summary": "Preview impact of a rule before saving",
      "layer": "core",
      "docstring": "Preview impact of a rule before saving",
      "category": "business_logic"
    },
    {
      "name": "validate_formula",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 789,
      "signature": "async validate_formula(request: FormulaValidationRequest, session: AsyncSession)",
      "summary": "Validate a formula and provide preview calculation.",
      "layer": "core",
      "docstring": "Validate a formula and provide preview calculation.\n\nThis endpoint:\n- Validates formula syntax\n- Checks field availability against entity metadata\n- Calculates preview with sample data (either provided or from database)\n- Returns list of used fields from formula\n- Provides helpful error messages with suggestions\n\nExample formulas:\n- \"ram_gb * 2.5\" - Simple per-GB pricing\n- \"cpu_mark_multi / 1000 * 5.0\" - Benchmark-based calculation\n- \"max(ram_gb * 2.5, 50)\" - Minimum value enforcement\n- \"ram_gb * 2.5 if ram_gb >= 16 else ram_gb * 3.0\" - Conditional pricing",
      "category": "business_logic"
    },
    {
      "name": "evaluate_listing",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 860,
      "signature": "async evaluate_listing(listing_id: int, ruleset_id: int | None, session: AsyncSession)",
      "summary": "Evaluate a single listing with a ruleset",
      "layer": "core",
      "docstring": "Evaluate a single listing with a ruleset",
      "category": "business_logic"
    },
    {
      "name": "apply_ruleset",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 876,
      "signature": "async apply_ruleset(request: ApplyRulesetRequest, session: AsyncSession)",
      "summary": "Apply a ruleset to listings",
      "layer": "core",
      "docstring": "Apply a ruleset to listings",
      "category": "business_logic"
    },
    {
      "name": "get_audit_log",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 907,
      "signature": "async get_audit_log(rule_id: int | None, limit: int, session: AsyncSession)",
      "summary": "Get audit log for rules",
      "layer": "core",
      "docstring": "Get audit log for rules",
      "category": "business_logic"
    },
    {
      "name": "export_ruleset_package",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 933,
      "signature": "async export_ruleset_package(ruleset_id: int, request: PackageMetadataRequest, session: AsyncSession)",
      "summary": "Export a ruleset as a .dbrs package file",
      "layer": "core",
      "docstring": "Export a ruleset as a .dbrs package file",
      "category": "business_logic"
    },
    {
      "name": "install_ruleset_package",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 984,
      "signature": "async install_ruleset_package(file: UploadFile, actor: str, merge_strategy: str, session: AsyncSession)",
      "summary": "Install a .dbrs package file",
      "layer": "core",
      "docstring": "Install a .dbrs package file",
      "category": "business_logic"
    },
    {
      "name": "preview_package_export",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/rules.py",
      "line": 1023,
      "signature": "async preview_package_export(ruleset_id: int, request: PackageMetadataRequest, session: AsyncSession)",
      "summary": "Preview what will be included in a package export",
      "layer": "core",
      "docstring": "Preview what will be included in a package export",
      "category": "business_logic"
    },
    {
      "name": "list_listings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 194,
      "signature": "async list_listings(limit: int, offset: int, session: AsyncSession) -> Sequence[ListingRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_listing_endpoint",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 205,
      "signature": "async create_listing_endpoint(payload: ListingCreate, session: AsyncSession) -> ListingRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_listing_schema",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 223,
      "signature": "async get_listing_schema(session: AsyncSession) -> ListingSchemaResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_listing",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 230,
      "signature": "async get_listing(listing_id: int, session: AsyncSession) -> ListingRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "update_listing_endpoint",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 238,
      "signature": "async update_listing_endpoint(listing_id: int, payload: ListingCreate, session: AsyncSession) -> ListingRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "patch_listing_endpoint",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 259,
      "signature": "async patch_listing_endpoint(listing_id: int, request: ListingPartialUpdateRequest, session: AsyncSession) -> ListingRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "update_listing_valuation_overrides",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 292,
      "signature": "async update_listing_valuation_overrides(listing_id: int, request: ListingValuationOverrideRequest, session: AsyncSession) -> ListingValuationOverrideResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "bulk_update_listings_endpoint",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 325,
      "signature": "async bulk_update_listings_endpoint(request: ListingBulkUpdateRequest, session: AsyncSession) -> ListingBulkUpdateResponse",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_valuation_breakdown",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 346,
      "signature": "async get_valuation_breakdown(listing_id: int, session: AsyncSession) -> ValuationBreakdownResponse",
      "summary": "Get detailed valuation breakdown for a listing.",
      "layer": "core",
      "docstring": "Get detailed valuation breakdown for a listing.\n\nThis endpoint returns the detailed breakdown of how a listing's adjusted price\nwas calculated, including all applied rules and their individual contributions,\nas well as inactive rules from the same ruleset.\n\nArgs:\n    listing_id: ID of the listing to get breakdown for\n    session: Database session\n\nReturns:\n    Detailed valuation breakdown with enriched rule metadata\n\nRaises:\n    404: Listing not found",
      "category": "business_logic"
    },
    {
      "name": "recalculate_listing_metrics",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 512,
      "signature": "async recalculate_listing_metrics(listing_id: int, session: AsyncSession)",
      "summary": "Recalculate all performance metrics for a listing.",
      "layer": "core",
      "docstring": "Recalculate all performance metrics for a listing.",
      "category": "business_logic"
    },
    {
      "name": "bulk_recalculate_metrics",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 525,
      "signature": "async bulk_recalculate_metrics(request: BulkRecalculateRequest, session: AsyncSession)",
      "summary": "Recalculate metrics for multiple listings.",
      "layer": "core",
      "docstring": "Recalculate metrics for multiple listings.\n\nIf listing_ids is None or empty, updates all listings.",
      "category": "business_logic"
    },
    {
      "name": "update_listing_ports",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 544,
      "signature": "async update_listing_ports(listing_id: int, request: UpdatePortsRequest, session: AsyncSession)",
      "summary": "Create or update ports for a listing.",
      "layer": "core",
      "docstring": "Create or update ports for a listing.",
      "category": "business_logic"
    },
    {
      "name": "get_listing_ports",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/listings.py",
      "line": 560,
      "signature": "async get_listing_ports(listing_id: int, session: AsyncSession)",
      "summary": "Get ports for a listing.",
      "layer": "core",
      "docstring": "Get ports for a listing.",
      "category": "business_logic"
    },
    {
      "name": "list_cpus",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 37,
      "signature": "async list_cpus(session: AsyncSession) -> Sequence[CpuRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_cpu",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 43,
      "signature": "async get_cpu(cpu_id: int, session: AsyncSession) -> CpuRead",
      "summary": "Get a single CPU by ID.",
      "layer": "core",
      "docstring": "Get a single CPU by ID.",
      "category": "business_logic"
    },
    {
      "name": "create_cpu",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 52,
      "signature": "async create_cpu(payload: CpuCreate, session: AsyncSession) -> CpuRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_gpus",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 65,
      "signature": "async list_gpus(session: AsyncSession) -> Sequence[GpuRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_gpu",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 71,
      "signature": "async get_gpu(gpu_id: int, session: AsyncSession) -> GpuRead",
      "summary": "Get a single GPU by ID.",
      "layer": "core",
      "docstring": "Get a single GPU by ID.",
      "category": "business_logic"
    },
    {
      "name": "create_gpu",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 80,
      "signature": "async create_gpu(payload: GpuCreate, session: AsyncSession) -> GpuRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_profiles",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 93,
      "signature": "async list_profiles(session: AsyncSession) -> Sequence[ProfileRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_profile",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 101,
      "signature": "async create_profile(payload: ProfileCreate, session: AsyncSession) -> ProfileRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_ports_profiles",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 116,
      "signature": "async list_ports_profiles(session: AsyncSession) -> Sequence[PortsProfileRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "create_ports_profile",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 127,
      "signature": "async create_ports_profile(payload: PortsProfileCreate, session: AsyncSession) -> PortsProfileRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_ram_specs",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 145,
      "signature": "async list_ram_specs(search: str | None, generation: RamGeneration | None, min_capacity_gb: int | None, max_capacity_gb: int | None, limit: int, session: AsyncSession) -> Sequence[RamSpecRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_ram_spec",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 182,
      "signature": "async get_ram_spec(ram_spec_id: int, session: AsyncSession) -> RamSpecRead",
      "summary": "Get a single RAM specification by ID.",
      "layer": "core",
      "docstring": "Get a single RAM specification by ID.",
      "category": "business_logic"
    },
    {
      "name": "create_ram_spec",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 193,
      "signature": "async create_ram_spec(payload: RamSpecCreate, session: AsyncSession) -> RamSpecRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_storage_profiles",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 204,
      "signature": "async list_storage_profiles(search: str | None, medium: StorageMedium | None, min_capacity_gb: int | None, max_capacity_gb: int | None, limit: int, session: AsyncSession) -> Sequence[StorageProfileRead]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_storage_profile",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 241,
      "signature": "async get_storage_profile(storage_profile_id: int, session: AsyncSession) -> StorageProfileRead",
      "summary": "Get a single storage profile by ID.",
      "layer": "core",
      "docstring": "Get a single storage profile by ID.",
      "category": "business_logic"
    },
    {
      "name": "create_storage_profile",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 257,
      "signature": "async create_storage_profile(payload: StorageProfileCreate, session: AsyncSession) -> StorageProfileRead",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "get_cpu_listings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 275,
      "signature": "async get_cpu_listings(cpu_id: int, limit: int, offset: int, session: AsyncSession) -> Sequence[ListingRead]",
      "summary": "Get all listings that use this CPU.",
      "layer": "core",
      "docstring": "Get all listings that use this CPU.",
      "category": "business_logic"
    },
    {
      "name": "get_gpu_listings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 304,
      "signature": "async get_gpu_listings(gpu_id: int, limit: int, offset: int, session: AsyncSession) -> Sequence[ListingRead]",
      "summary": "Get all listings that use this GPU.",
      "layer": "core",
      "docstring": "Get all listings that use this GPU.",
      "category": "business_logic"
    },
    {
      "name": "get_ram_spec_listings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 333,
      "signature": "async get_ram_spec_listings(ram_spec_id: int, limit: int, offset: int, session: AsyncSession) -> Sequence[ListingRead]",
      "summary": "Get all listings that use this RAM specification.",
      "layer": "core",
      "docstring": "Get all listings that use this RAM specification.",
      "category": "business_logic"
    },
    {
      "name": "get_storage_profile_listings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/catalog.py",
      "line": 362,
      "signature": "async get_storage_profile_listings(storage_profile_id: int, limit: int, offset: int, session: AsyncSession) -> Sequence[ListingRead]",
      "summary": "Get all listings that use this storage profile (either primary or secondary).",
      "layer": "core",
      "docstring": "Get all listings that use this storage profile (either primary or secondary).",
      "category": "business_logic"
    },
    {
      "name": "TelemetryLogEntry",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/telemetry.py",
      "line": 17,
      "signature": "class TelemetryLogEntry(BaseModel)",
      "summary": "Payload for frontend telemetry submissions.",
      "layer": "core",
      "docstring": "Payload for frontend telemetry submissions.",
      "category": "business_logic"
    },
    {
      "name": "ingest_telemetry_log",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/api/telemetry.py",
      "line": 29,
      "signature": "async ingest_telemetry_log(entry: TelemetryLogEntry, request: Request) -> dict[str, bool]",
      "summary": "Accept telemetry events from the frontend and emit to backend logger.",
      "layer": "core",
      "docstring": "Accept telemetry events from the frontend and emit to backend logger.",
      "category": "business_logic"
    },
    {
      "name": "MappingSuggestionModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 14,
      "signature": "class MappingSuggestionModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldMappingModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 20,
      "signature": "class FieldMappingModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "EntityMappingModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 31,
      "signature": "class EntityMappingModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "SheetColumnModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 36,
      "signature": "class SheetColumnModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "SheetMetaModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 41,
      "signature": "class SheetMetaModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ComponentMatchSuggestionModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 51,
      "signature": "class ComponentMatchSuggestionModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ComponentMatchModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 56,
      "signature": "class ComponentMatchModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "EntityPreviewModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 64,
      "signature": "class EntityPreviewModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CpuConflictFieldModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 72,
      "signature": "class CpuConflictFieldModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CpuConflictModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 78,
      "signature": "class CpuConflictModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ImportSessionSnapshotModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 85,
      "signature": "class ImportSessionSnapshotModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ImportSessionListModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 100,
      "signature": "class ImportSessionListModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "UpdateFieldMappingPayload",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 104,
      "signature": "class UpdateFieldMappingPayload(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "UpdateEntityMappingPayload",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 110,
      "signature": "class UpdateEntityMappingPayload(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "UpdateMappingsRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 115,
      "signature": "class UpdateMappingsRequest(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ConflictResolutionModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 119,
      "signature": "class ConflictResolutionModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ComponentOverrideModel",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 125,
      "signature": "class ComponentOverrideModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CommitImportRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 132,
      "signature": "class CommitImportRequest(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CommitImportResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 138,
      "signature": "class CommitImportResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ImporterFieldCreateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 145,
      "signature": "class ImporterFieldCreateRequest(CustomFieldCreateRequest)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ImporterFieldCreateResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/imports.py",
      "line": 149,
      "signature": "class ImporterFieldCreateResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldCreateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/custom_fields.py",
      "line": 16,
      "signature": "class CustomFieldCreateRequest(CustomFieldDefinitionCreate)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/custom_fields.py",
      "line": 20,
      "signature": "class CustomFieldUpdateRequest(CustomFieldDefinitionUpdate)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/custom_fields.py",
      "line": 24,
      "signature": "class CustomFieldResponse(CustomFieldDefinitionRead)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldListResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/custom_fields.py",
      "line": 28,
      "signature": "class CustomFieldListResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "AddFieldOptionRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/custom_fields.py",
      "line": 32,
      "signature": "class AddFieldOptionRequest(BaseModel)",
      "summary": "Request to add an option to a dropdown/multi-select field",
      "layer": "schema",
      "docstring": "Request to add an option to a dropdown/multi-select field",
      "category": "business_logic"
    },
    {
      "name": "FieldOptionResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/custom_fields.py",
      "line": 37,
      "signature": "class FieldOptionResponse(BaseModel)",
      "summary": "Response with updated field options",
      "layer": "schema",
      "docstring": "Response with updated field options",
      "category": "business_logic"
    },
    {
      "name": "FieldCreateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 16,
      "signature": "class FieldCreateRequest(CustomFieldDefinitionCreate)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 20,
      "signature": "class FieldUpdateRequest(CustomFieldDefinitionUpdate)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 24,
      "signature": "class FieldResponse(CustomFieldDefinitionRead)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldListResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 28,
      "signature": "class FieldListResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldAuditEntry",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 32,
      "signature": "class FieldAuditEntry(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldAuditResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 42,
      "signature": "class FieldAuditResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldUsageRecord",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 46,
      "signature": "class FieldUsageRecord(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldUsageResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 54,
      "signature": "class FieldUsageResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldDeleteResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 58,
      "signature": "class FieldDeleteResponse(FieldUsageRecord)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "FieldValuesResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/fields.py",
      "line": 62,
      "signature": "class FieldValuesResponse(BaseModel)",
      "summary": "Response schema for field values endpoint.",
      "layer": "schema",
      "docstring": "Response schema for field values endpoint.",
      "category": "business_logic"
    },
    {
      "name": "ListingFieldSchema",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 14,
      "signature": "class ListingFieldSchema(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ListingSchemaResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 26,
      "signature": "class ListingSchemaResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ListingPartialUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 31,
      "signature": "class ListingPartialUpdateRequest(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "coerce_reference_fields",
      "kind": "method",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 37,
      "signature": "coerce_reference_fields(cls, v: dict[str, Any] | None) -> dict[str, Any] | None",
      "summary": "Coerce reference identifiers to integers when provided as strings.",
      "layer": "schema",
      "parent": "ListingPartialUpdateRequest",
      "docstring": "Coerce reference identifiers to integers when provided as strings.",
      "category": "business_logic"
    },
    {
      "name": "ListingBulkUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 66,
      "signature": "class ListingBulkUpdateRequest(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "coerce_bulk_reference_fields",
      "kind": "method",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 73,
      "signature": "coerce_bulk_reference_fields(cls, v: dict[str, Any] | None) -> dict[str, Any] | None",
      "summary": "",
      "layer": "schema",
      "parent": "ListingBulkUpdateRequest",
      "category": "business_logic"
    },
    {
      "name": "ListingBulkUpdateResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 85,
      "signature": "class ListingBulkUpdateResponse(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ValuationAdjustmentAction",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 90,
      "signature": "class ValuationAdjustmentAction(BaseModel)",
      "summary": "Breakdown of an individual action contributing to a rule adjustment.",
      "layer": "schema",
      "docstring": "Breakdown of an individual action contributing to a rule adjustment.",
      "category": "business_logic"
    },
    {
      "name": "ValuationAdjustmentDetail",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 99,
      "signature": "class ValuationAdjustmentDetail(BaseModel)",
      "summary": "Details of a rule adjustment applied during valuation.",
      "layer": "schema",
      "docstring": "Details of a rule adjustment applied during valuation.",
      "category": "business_logic"
    },
    {
      "name": "LegacyValuationLine",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 113,
      "signature": "class LegacyValuationLine(BaseModel)",
      "summary": "Legacy component deduction line retained for backwards compatibility.",
      "layer": "schema",
      "docstring": "Legacy component deduction line retained for backwards compatibility.",
      "category": "business_logic"
    },
    {
      "name": "ValuationBreakdownResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 124,
      "signature": "class ValuationBreakdownResponse(BaseModel)",
      "summary": "Detailed breakdown of listing valuation calculation.",
      "layer": "schema",
      "docstring": "Detailed breakdown of listing valuation calculation.",
      "category": "business_logic"
    },
    {
      "name": "BulkRecalculateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 145,
      "signature": "class BulkRecalculateRequest(BaseModel)",
      "summary": "Request to recalculate metrics for multiple listings",
      "layer": "schema",
      "docstring": "Request to recalculate metrics for multiple listings",
      "category": "business_logic"
    },
    {
      "name": "BulkRecalculateResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 150,
      "signature": "class BulkRecalculateResponse(BaseModel)",
      "summary": "Response after bulk metric recalculation",
      "layer": "schema",
      "docstring": "Response after bulk metric recalculation",
      "category": "business_logic"
    },
    {
      "name": "PortEntry",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 156,
      "signature": "class PortEntry(BaseModel)",
      "summary": "Single port entry with type and quantity",
      "layer": "schema",
      "docstring": "Single port entry with type and quantity",
      "category": "business_logic"
    },
    {
      "name": "UpdatePortsRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 162,
      "signature": "class UpdatePortsRequest(BaseModel)",
      "summary": "Request to update ports for a listing",
      "layer": "schema",
      "docstring": "Request to update ports for a listing",
      "category": "business_logic"
    },
    {
      "name": "PortsResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 167,
      "signature": "class PortsResponse(BaseModel)",
      "summary": "Response with ports data",
      "layer": "schema",
      "docstring": "Response with ports data",
      "category": "business_logic"
    },
    {
      "name": "ListingValuationOverrideRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 172,
      "signature": "class ListingValuationOverrideRequest(BaseModel)",
      "summary": "Request schema for managing listing-level ruleset overrides.",
      "layer": "schema",
      "docstring": "Request schema for managing listing-level ruleset overrides.",
      "category": "business_logic"
    },
    {
      "name": "validate_ruleset_id",
      "kind": "method",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 186,
      "signature": "validate_ruleset_id(cls, value: int | None, info) -> int | None",
      "summary": "",
      "layer": "schema",
      "parent": "ListingValuationOverrideRequest",
      "category": "business_logic"
    },
    {
      "name": "ListingValuationOverrideResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/api/schemas/listings.py",
      "line": 193,
      "signature": "class ListingValuationOverrideResponse(BaseModel)",
      "summary": "Response describing the current listing valuation override state.",
      "layer": "schema",
      "docstring": "Response describing the current listing valuation override state.",
      "category": "business_logic"
    },
    {
      "name": "__getattr__",
      "kind": "function",
      "path": "apps/api/dealbrain_api/importers/__init__.py",
      "line": 8,
      "signature": "__getattr__(name: str)",
      "summary": "",
      "layer": "core",
      "category": "config"
    },
    {
      "name": "__dir__",
      "kind": "function",
      "path": "apps/api/dealbrain_api/importers/__init__.py",
      "line": 16,
      "signature": "__dir__() -> list[str]",
      "summary": "",
      "layer": "core",
      "category": "config"
    },
    {
      "name": "ImportSummary",
      "kind": "class",
      "path": "apps/api/dealbrain_api/importers/excel.py",
      "line": 26,
      "signature": "class ImportSummary",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "SpreadsheetImporter",
      "kind": "class",
      "path": "apps/api/dealbrain_api/importers/excel.py",
      "line": 35,
      "signature": "class SpreadsheetImporter",
      "summary": "Parse the Excel workbook that backs the Deal Brain catalog.",
      "layer": "core",
      "docstring": "Parse the Excel workbook that backs the Deal Brain catalog.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/importers/excel.py",
      "line": 38,
      "signature": "__init__(self, path: Path) -> None",
      "summary": "",
      "layer": "core",
      "parent": "SpreadsheetImporter",
      "category": "business_logic"
    },
    {
      "name": "load",
      "kind": "method",
      "path": "apps/api/dealbrain_api/importers/excel.py",
      "line": 41,
      "signature": "load(self) -> tuple[SpreadsheetSeed, ImportSummary]",
      "summary": "",
      "layer": "core",
      "parent": "SpreadsheetImporter",
      "category": "business_logic"
    },
    {
      "name": "EntityConfig",
      "kind": "class",
      "path": "apps/api/dealbrain_api/importers/universal.py",
      "line": 28,
      "signature": "class EntityConfig",
      "summary": "Configuration describing how to map a payload into a seed list.",
      "layer": "core",
      "docstring": "Configuration describing how to map a payload into a seed list.",
      "category": "business_logic"
    },
    {
      "name": "ImporterError",
      "kind": "class",
      "path": "apps/api/dealbrain_api/importers/universal.py",
      "line": 67,
      "signature": "class ImporterError(Exception)",
      "summary": "Raised when universal importer fails to parse or validate the payload.",
      "layer": "core",
      "docstring": "Raised when universal importer fails to parse or validate the payload.",
      "category": "business_logic"
    },
    {
      "name": "load_seed_from_file",
      "kind": "function",
      "path": "apps/api/dealbrain_api/importers/universal.py",
      "line": 71,
      "signature": "load_seed_from_file(path: Path, entity: str) -> tuple[SpreadsheetSeed, int]",
      "summary": "Load entities from *path* and return a populated ``SpreadsheetSeed``.",
      "layer": "core",
      "docstring": "Load entities from *path* and return a populated ``SpreadsheetSeed``.\n\nParameters\n----------\npath:\n    Relative or absolute file path pointing to a ``.json`` or ``.csv`` file.\nentity:\n    Entity key (``cpu``, ``gpu``, ``profile``, ``ports_profile``, ``listing``).\n\nReturns\n-------\ntuple[SpreadsheetSeed, int]\n    Seed object populated with the imported entities and the number of\n    records validated for the requested entity.",
      "category": "business_logic"
    },
    {
      "name": "BaselineAuditLog",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/baseline_audit.py",
      "line": 21,
      "signature": "class BaselineAuditLog(Base)",
      "summary": "Audit log for baseline valuation operations.",
      "layer": "model",
      "docstring": "Audit log for baseline valuation operations.",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/baseline_audit.py",
      "line": 53,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "Convert audit log to dictionary.",
      "layer": "model",
      "parent": "BaselineAuditLog",
      "docstring": "Convert audit log to dictionary.",
      "category": "business_logic"
    },
    {
      "name": "TimestampMixin",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 16,
      "signature": "class TimestampMixin",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "Cpu",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 23,
      "signature": "class Cpu(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "Gpu",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 47,
      "signature": "class Gpu(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "PortsProfile",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 61,
      "signature": "class PortsProfile(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "Port",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 73,
      "signature": "class Port(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "RamSpec",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 86,
      "signature": "class RamSpec(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "StorageProfile",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 116,
      "signature": "class StorageProfile(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "Profile",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 155,
      "signature": "class Profile(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleset",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 168,
      "signature": "class ValuationRuleset(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleGroup",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 187,
      "signature": "class ValuationRuleGroup(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleV2",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 207,
      "signature": "class ValuationRuleV2(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleCondition",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 237,
      "signature": "class ValuationRuleCondition(Base)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleAction",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 262,
      "signature": "class ValuationRuleAction(Base)",
      "summary": "Action to apply when a valuation rule matches.",
      "layer": "model",
      "docstring": "Action to apply when a valuation rule matches.\n\nActions define how to adjust pricing or valuation based on matched conditions.\nThe modifiers_json field supports two formats for applying multipliers:\n\n1. Dynamic Field-Based Multipliers (Primary Format):\n    {\n        \"multipliers\": [\n            {\n                \"name\": \"RAM Generation Multiplier\",\n                \"field\": \"ram_spec.ddr_generation\",\n                \"conditions\": [\n                    {\"value\": \"ddr3\", \"multiplier\": 0.7},\n                    {\"value\": \"ddr4\", \"multiplier\": 1.0},\n                    {\"value\": \"ddr5\", \"multiplier\": 1.3}\n                ]\n            }\n        ]\n    }\n\n2. Legacy Condition Multipliers (Backward Compatible):\n    {\n        \"condition_multipliers\": {\n            \"new\": 1.0,\n            \"refurb\": 0.75,\n            \"used\": 0.6\n        }\n    }\n\nBoth formats can coexist. Field paths use dot notation to navigate nested\nstructures (e.g., \"ram_spec.ddr_generation\"). Empty dict {} is valid.",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleVersion",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 311,
      "signature": "class ValuationRuleVersion(Base)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleAudit",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 326,
      "signature": "class ValuationRuleAudit(Base)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "Listing",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 340,
      "signature": "class Listing(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ram_type",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 438,
      "signature": "ram_type(self) -> str | None",
      "summary": "",
      "layer": "model",
      "parent": "Listing",
      "category": "business_logic"
    },
    {
      "name": "ram_speed_mhz",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 442,
      "signature": "ram_speed_mhz(self) -> int | None",
      "summary": "",
      "layer": "model",
      "parent": "Listing",
      "category": "business_logic"
    },
    {
      "name": "cpu_name",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 446,
      "signature": "cpu_name(self) -> str | None",
      "summary": "Denormalized CPU name for frontend convenience.",
      "layer": "model",
      "parent": "Listing",
      "docstring": "Denormalized CPU name for frontend convenience.",
      "category": "business_logic"
    },
    {
      "name": "gpu_name",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 451,
      "signature": "gpu_name(self) -> str | None",
      "summary": "Denormalized GPU name for frontend convenience.",
      "layer": "model",
      "parent": "Listing",
      "docstring": "Denormalized GPU name for frontend convenience.",
      "category": "business_logic"
    },
    {
      "name": "thumbnail_url",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 456,
      "signature": "thumbnail_url(self) -> str | None",
      "summary": "Extract thumbnail URL from raw listing JSON or attributes.",
      "layer": "model",
      "parent": "Listing",
      "docstring": "Extract thumbnail URL from raw listing JSON or attributes.",
      "category": "business_logic"
    },
    {
      "name": "ListingComponent",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 473,
      "signature": "class ListingComponent(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ListingScoreSnapshot",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 487,
      "signature": "class ListingScoreSnapshot(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ImportJob",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 504,
      "signature": "class ImportJob(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "TaskRun",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 517,
      "signature": "class TaskRun(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ImportSession",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 529,
      "signature": "class ImportSession(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ImportSessionAudit",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 562,
      "signature": "class ImportSessionAudit(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldDefinition",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 576,
      "signature": "class CustomFieldDefinition(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "validation",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 607,
      "signature": "validation(self) -> dict[str, Any] | None",
      "summary": "",
      "layer": "model",
      "parent": "CustomFieldDefinition",
      "category": "business_logic"
    },
    {
      "name": "validation",
      "kind": "method",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 611,
      "signature": "validation(self, value: dict[str, Any] | None) -> None",
      "summary": "",
      "layer": "model",
      "parent": "CustomFieldDefinition",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldAuditLog",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 615,
      "signature": "class CustomFieldAuditLog(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldAttributeHistory",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 629,
      "signature": "class CustomFieldAttributeHistory(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "ApplicationSettings",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 648,
      "signature": "class ApplicationSettings(Base, TimestampMixin)",
      "summary": "",
      "layer": "model",
      "category": "business_logic"
    },
    {
      "name": "RawPayload",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 656,
      "signature": "class RawPayload(Base, TimestampMixin)",
      "summary": "Stores raw adapter payloads for URL-ingested listings.",
      "layer": "model",
      "docstring": "Stores raw adapter payloads for URL-ingested listings.\n\nPreserves original data from adapters (JSON-LD, API responses, HTML) for\ndebugging, re-processing, and audit trails. TTL-based cleanup prevents\nunbounded storage growth.",
      "category": "business_logic"
    },
    {
      "name": "IngestionMetric",
      "kind": "class",
      "path": "apps/api/dealbrain_api/models/core.py",
      "line": 682,
      "signature": "class IngestionMetric(Base, TimestampMixin)",
      "summary": "Tracks adapter performance metrics for telemetry dashboard.",
      "layer": "model",
      "docstring": "Tracks adapter performance metrics for telemetry dashboard.\n\nAggregates success rates, latencies, and field completeness per adapter.\nSupports time-series analysis for monitoring adapter health and identifying\nregressions.\n\nExample aggregation queries:\n    -- Recent adapter success rate\n    SELECT adapter,\n           SUM(success_count)::float / NULLIF(SUM(success_count + failure_count), 0) AS success_rate\n    FROM ingestion_metric\n    WHERE measured_at >= NOW() - INTERVAL '24 hours'\n    GROUP BY adapter;\n\n    -- P95 latency trend\n    SELECT DATE_TRUNC('hour', measured_at) AS hour,\n           adapter,\n           AVG(p95_latency_ms) AS avg_p95_latency\n    FROM ingestion_metric\n    WHERE measured_at >= NOW() - INTERVAL '7 days'\n    GROUP BY hour, adapter\n    ORDER BY hour DESC;\n\n    -- Field completeness by adapter\n    SELECT adapter,\n           AVG(field_completeness_pct) AS avg_completeness\n    FROM ingestion_metric\n    WHERE measured_at >= NOW() - INTERVAL '7 days'\n    GROUP BY adapter\n    ORDER BY avg_completeness DESC;",
      "category": "business_logic"
    },
    {
      "name": "inventory_attribute_values",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/custom_fields_backfill.py",
      "line": 15,
      "signature": "async inventory_attribute_values(db: AsyncSession, entity: str) -> dict[str, list[Any]]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "infer_field_shape",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/custom_fields_backfill.py",
      "line": 37,
      "signature": "infer_field_shape(values: Iterable[Any]) -> tuple[str, dict[str, Any] | None, list[str] | None]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "backfill_field_definitions",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/custom_fields_backfill.py",
      "line": 67,
      "signature": "async backfill_field_definitions(db: AsyncSession, actor: str | None, service: CustomFieldService | None) -> list[CustomFieldDefinition]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "FieldMeta",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 21,
      "signature": "class FieldMeta",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "EntityMeta",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 34,
      "signature": "class EntityMeta",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "RecordPayload",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 43,
      "signature": "class RecordPayload",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "FieldRegistry",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 48,
      "signature": "class FieldRegistry",
      "summary": "Central registry for catalog entities and their field metadata.",
      "layer": "service",
      "docstring": "Central registry for catalog entities and their field metadata.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 51,
      "signature": "__init__(self, custom_field_service: CustomFieldService | None) -> None",
      "summary": "",
      "layer": "service",
      "parent": "FieldRegistry",
      "category": "business_logic"
    },
    {
      "name": "get_entities",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 67,
      "signature": "get_entities(self) -> list[EntityMeta]",
      "summary": "",
      "layer": "service",
      "parent": "FieldRegistry",
      "category": "business_logic"
    },
    {
      "name": "schema_for",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 70,
      "signature": "async schema_for(self, db: AsyncSession, entity: str) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "FieldRegistry",
      "category": "business_logic"
    },
    {
      "name": "list_records",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 100,
      "signature": "async list_records(self, db: AsyncSession, entity: str, limit: int, offset: int) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "FieldRegistry",
      "category": "business_logic"
    },
    {
      "name": "create_record",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 134,
      "signature": "async create_record(self, db: AsyncSession, entity: str, payload: Mapping[str, Any]) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "FieldRegistry",
      "category": "business_logic"
    },
    {
      "name": "update_record",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/field_registry.py",
      "line": 156,
      "signature": "async update_record(self, db: AsyncSession, entity: str, record_id: int, payload: Mapping[str, Any]) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "FieldRegistry",
      "category": "business_logic"
    },
    {
      "name": "RulePreviewService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/rule_preview.py",
      "line": 17,
      "signature": "class RulePreviewService",
      "summary": "Service for previewing impact of valuation rules",
      "layer": "service",
      "docstring": "Service for previewing impact of valuation rules",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/rule_preview.py",
      "line": 20,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "service",
      "parent": "RulePreviewService",
      "category": "business_logic"
    },
    {
      "name": "preview_rule",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rule_preview.py",
      "line": 23,
      "signature": "async preview_rule(self, session: AsyncSession, conditions: list[dict[str, Any]], actions: list[dict[str, Any]], sample_size: int, category_filter: dict[str, Any] | None) -> dict[str, Any]",
      "summary": "Preview impact of a rule before saving.",
      "layer": "service",
      "parent": "RulePreviewService",
      "docstring": "Preview impact of a rule before saving.\n\nArgs:\n    session: Database session\n    conditions: List of condition dictionaries\n    actions: List of action dictionaries\n    sample_size: Number of sample listings to return\n    category_filter: Optional filters for listing selection\n\nReturns:\n    Dictionary with preview data including sample listings and statistics",
      "category": "business_logic"
    },
    {
      "name": "preview_ruleset",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rule_preview.py",
      "line": 141,
      "signature": "async preview_ruleset(self, session: AsyncSession, ruleset_id: int, sample_size: int) -> dict[str, Any]",
      "summary": "Preview impact of an entire ruleset.",
      "layer": "service",
      "parent": "RulePreviewService",
      "docstring": "Preview impact of an entire ruleset.\n\nArgs:\n    session: Database session\n    ruleset_id: Ruleset ID to preview\n    sample_size: Number of sample listings\n\nReturns:\n    Preview data with aggregated statistics",
      "category": "business_logic"
    },
    {
      "name": "compare_rulesets",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rule_preview.py",
      "line": 227,
      "signature": "async compare_rulesets(self, session: AsyncSession, ruleset_id_a: int, ruleset_id_b: int, sample_size: int) -> dict[str, Any]",
      "summary": "Compare impact of two rulesets.",
      "layer": "service",
      "parent": "RulePreviewService",
      "docstring": "Compare impact of two rulesets.\n\nArgs:\n    session: Database session\n    ruleset_id_a: First ruleset ID\n    ruleset_id_b: Second ruleset ID\n    sample_size: Number of listings to compare\n\nReturns:\n    Comparison data",
      "category": "business_logic"
    },
    {
      "name": "OperatorDefinition",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_metadata.py",
      "line": 14,
      "signature": "class OperatorDefinition",
      "summary": "Operator metadata for frontend.",
      "layer": "service",
      "docstring": "Operator metadata for frontend.",
      "category": "business_logic"
    },
    {
      "name": "FieldMetadata",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_metadata.py",
      "line": 22,
      "signature": "class FieldMetadata",
      "summary": "Field metadata for condition builder.",
      "layer": "service",
      "docstring": "Field metadata for condition builder.",
      "category": "business_logic"
    },
    {
      "name": "EntityMetadata",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_metadata.py",
      "line": 34,
      "signature": "class EntityMetadata",
      "summary": "Entity metadata for condition builder.",
      "layer": "service",
      "docstring": "Entity metadata for condition builder.",
      "category": "business_logic"
    },
    {
      "name": "FieldMetadataService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/field_metadata.py",
      "line": 41,
      "signature": "class FieldMetadataService",
      "summary": "Provides structured metadata for rule builder UI.",
      "layer": "service",
      "docstring": "Provides structured metadata for rule builder UI.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/field_metadata.py",
      "line": 59,
      "signature": "__init__(self, field_registry: FieldRegistry | None)",
      "summary": "",
      "layer": "service",
      "parent": "FieldMetadataService",
      "category": "business_logic"
    },
    {
      "name": "get_entities_metadata",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/field_metadata.py",
      "line": 62,
      "signature": "async get_entities_metadata(self, db: AsyncSession) -> list[EntityMetadata]",
      "summary": "Fetch all entities with their fields.",
      "layer": "service",
      "parent": "FieldMetadataService",
      "docstring": "Fetch all entities with their fields.",
      "category": "business_logic"
    },
    {
      "name": "get_operators_for_field_type",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/field_metadata.py",
      "line": 167,
      "signature": "get_operators_for_field_type(self, field_type: str) -> list[OperatorDefinition]",
      "summary": "Get valid operators for a given field type.",
      "layer": "service",
      "parent": "FieldMetadataService",
      "docstring": "Get valid operators for a given field type.",
      "category": "business_logic"
    },
    {
      "name": "SettingsService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/settings.py",
      "line": 10,
      "signature": "class SettingsService",
      "summary": "Service for managing application settings.",
      "layer": "service",
      "docstring": "Service for managing application settings.",
      "category": "business_logic"
    },
    {
      "name": "get_setting",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/settings.py",
      "line": 13,
      "signature": "async get_setting(self, session: AsyncSession, key: str) -> dict[str, Any] | None",
      "summary": "Get a setting by key.",
      "layer": "service",
      "parent": "SettingsService",
      "docstring": "Get a setting by key.\n\nArgs:\n    session: Database session\n    key: Setting key\n\nReturns:\n    Setting value as dict, or None if not found",
      "category": "business_logic"
    },
    {
      "name": "update_setting",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/settings.py",
      "line": 29,
      "signature": "async update_setting(self, session: AsyncSession, key: str, value: dict[str, Any], description: str | None) -> dict[str, Any]",
      "summary": "Update or create a setting.",
      "layer": "service",
      "parent": "SettingsService",
      "docstring": "Update or create a setting.\n\nArgs:\n    session: Database session\n    key: Setting key\n    value: Setting value as dict\n    description: Optional description\n\nReturns:\n    Updated setting value",
      "category": "business_logic"
    },
    {
      "name": "get_valuation_thresholds",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/settings.py",
      "line": 64,
      "signature": "async get_valuation_thresholds(self, session: AsyncSession) -> dict[str, float]",
      "summary": "Get valuation thresholds with defaults.",
      "layer": "service",
      "parent": "SettingsService",
      "docstring": "Get valuation thresholds with defaults.\n\nArgs:\n    session: Database session\n\nReturns:\n    Thresholds dict with good_deal, great_deal, premium_warning",
      "category": "business_logic"
    },
    {
      "name": "FieldUsageSummary",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 57,
      "signature": "class FieldUsageSummary",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "total",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 64,
      "signature": "total(self) -> int",
      "summary": "",
      "layer": "service",
      "parent": "FieldUsageSummary",
      "category": "business_logic"
    },
    {
      "name": "FieldDependencyError",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 68,
      "signature": "class FieldDependencyError(RuntimeError)",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 69,
      "signature": "__init__(self, message: str, usage: FieldUsageSummary) -> None",
      "summary": "",
      "layer": "service",
      "parent": "FieldDependencyError",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 74,
      "signature": "class CustomFieldService",
      "summary": "CRUD helpers for custom fields.",
      "layer": "service",
      "docstring": "CRUD helpers for custom fields.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 77,
      "signature": "__init__(self, allowed_types: Iterable[str] | None) -> None",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "list_fields",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 80,
      "signature": "async list_fields(self, db: AsyncSession, entity: str | None, include_inactive: bool, include_deleted: bool) -> list[CustomFieldDefinition]",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "get_field",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 103,
      "signature": "async get_field(self, db: AsyncSession, field_id: int) -> CustomFieldDefinition",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "create_field",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 109,
      "signature": "async create_field(self, db: AsyncSession, entity: str, key: str, label: str, data_type: str, description: str | None, required: bool, default_value: object | None, options: list[str] | None, is_active: bool, is_locked: bool, visibility: str, created_by: str | None, validation: dict | None, display_order: int | None, actor: str | None) -> CustomFieldDefinition",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "update_field",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 175,
      "signature": "async update_field(self, db: AsyncSession, field_id: int, label: str | None, data_type: str | None, description: str | None, required: bool | None, default_value: object | None, options: list[str] | None, is_active: bool | None, is_locked: bool | None, visibility: str | None, created_by: str | None, validation: dict | None, display_order: int | None, force: bool, actor: str | None) -> CustomFieldDefinition",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "add_field_option",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 297,
      "signature": "async add_field_option(self, db: AsyncSession, field_id: int, value: str, actor: str | None) -> CustomFieldDefinition",
      "summary": "Add an option to a dropdown/multi-select field.",
      "layer": "service",
      "parent": "CustomFieldService",
      "docstring": "Add an option to a dropdown/multi-select field.\n\nArgs:\n    db: Database session\n    field_id: ID of the field to modify\n    value: Option value to add\n    actor: Username of user making the change\n\nReturns:\n    Updated field definition\n\nRaises:\n    LookupError: If field not found\n    ValueError: If field type doesn't support options or value already exists",
      "category": "business_logic"
    },
    {
      "name": "delete_field",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 359,
      "signature": "async delete_field(self, db: AsyncSession, field_id: int, hard_delete: bool, force: bool, actor: str | None) -> FieldUsageSummary",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "field_usage",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 411,
      "signature": "async field_usage(self, db: AsyncSession, field: CustomFieldDefinition) -> FieldUsageSummary",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "list_usage",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 429,
      "signature": "async list_usage(self, db: AsyncSession, entity: str | None, field_ids: Sequence[int] | None) -> list[FieldUsageSummary]",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "history",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/custom_fields.py",
      "line": 450,
      "signature": "async history(self, db: AsyncSession, field_id: int, limit: int) -> list[CustomFieldAuditLog]",
      "summary": "",
      "layer": "service",
      "parent": "CustomFieldService",
      "category": "business_logic"
    },
    {
      "name": "get_or_create_ports_profile",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/ports.py",
      "line": 12,
      "signature": "async get_or_create_ports_profile(session: AsyncSession, listing_id: int) -> PortsProfile",
      "summary": "Get existing ports profile or create new one for listing.",
      "layer": "service",
      "docstring": "Get existing ports profile or create new one for listing.\n\nArgs:\n    session: Database session\n    listing_id: Listing ID\n\nReturns:\n    PortsProfile instance (existing or new)\n\nRaises:\n    ValueError: If listing not found",
      "category": "business_logic"
    },
    {
      "name": "update_listing_ports",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/ports.py",
      "line": 51,
      "signature": "async update_listing_ports(session: AsyncSession, listing_id: int, ports_data: list[dict]) -> PortsProfile",
      "summary": "Update ports for a listing.",
      "layer": "service",
      "docstring": "Update ports for a listing.\n\nArgs:\n    session: Database session\n    listing_id: Listing ID\n    ports_data: List of dicts with 'port_type' and 'quantity' keys\n\nReturns:\n    Updated PortsProfile with ports\n\nExample:\n    ports_data = [\n        {\"port_type\": \"USB-A\", \"quantity\": 4},\n        {\"port_type\": \"HDMI\", \"quantity\": 1}\n    ]",
      "category": "business_logic"
    },
    {
      "name": "get_listing_ports",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/ports.py",
      "line": 93,
      "signature": "async get_listing_ports(session: AsyncSession, listing_id: int) -> list[dict]",
      "summary": "Get ports for a listing as simple dict list.",
      "layer": "service",
      "docstring": "Get ports for a listing as simple dict list.\n\nReturns:\n    List of dicts with port_type and quantity, or empty list if none.",
      "category": "business_logic"
    },
    {
      "name": "CpuMetricSummary",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/admin_tasks.py",
      "line": 16,
      "signature": "class CpuMetricSummary",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/admin_tasks.py",
      "line": 23,
      "signature": "to_dict(self) -> dict[str, int]",
      "summary": "",
      "layer": "service",
      "parent": "CpuMetricSummary",
      "category": "business_logic"
    },
    {
      "name": "recalculate_cpu_mark_metrics",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/admin_tasks.py",
      "line": 33,
      "signature": "async recalculate_cpu_mark_metrics(session: AsyncSession, listing_ids: Sequence[int] | None) -> CpuMetricSummary",
      "summary": "Recalculate CPU dollar-per-mark metrics for listings with CPUs.",
      "layer": "service",
      "docstring": "Recalculate CPU dollar-per-mark metrics for listings with CPUs.",
      "category": "business_logic"
    },
    {
      "name": "PassmarkImportSummary",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 22,
      "signature": "class PassmarkImportSummary",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 28,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "PassmarkImportSummary",
      "category": "business_logic"
    },
    {
      "name": "parse_int",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 37,
      "signature": "parse_int(value: str | int | float | None) -> int | None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "parse_string",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 60,
      "signature": "parse_string(value: str | None) -> str | None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "extract_release_year",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 67,
      "signature": "extract_release_year(raw_date: str | None) -> int | None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "infer_manufacturer",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 79,
      "signature": "infer_manufacturer(name: str | None) -> str | None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "build_passmark_url",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 96,
      "signature": "build_passmark_url(href: str | None) -> tuple[str | None, str | None]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "update_cpu_from_passmark",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 114,
      "signature": "update_cpu_from_passmark(cpu: Cpu, data: dict[str, Any]) -> None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "import_passmark_file",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/passmark.py",
      "line": 192,
      "signature": "async import_passmark_file(path: Path) -> PassmarkImportSummary",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "normalize_int",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 15,
      "signature": "normalize_int(value: Any) -> int | None",
      "summary": "Convert arbitrary value to non-negative integer or ``None``.",
      "layer": "service",
      "docstring": "Convert arbitrary value to non-negative integer or ``None``.",
      "category": "business_logic"
    },
    {
      "name": "normalize_str",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 26,
      "signature": "normalize_str(value: Any) -> str | None",
      "summary": "Coerce arbitrary value to trimmed string or ``None``.",
      "layer": "service",
      "docstring": "Coerce arbitrary value to trimmed string or ``None``.",
      "category": "business_logic"
    },
    {
      "name": "normalize_ram_generation",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 34,
      "signature": "normalize_ram_generation(value: Any) -> RamGeneration",
      "summary": "Resolve various user inputs into a canonical ``RamGeneration``.",
      "layer": "service",
      "docstring": "Resolve various user inputs into a canonical ``RamGeneration``.",
      "category": "business_logic"
    },
    {
      "name": "format_ram_label",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 59,
      "signature": "format_ram_label(generation: RamGeneration, speed_mhz: int | None, total_capacity_gb: int | None, module_count: int | None, capacity_per_module_gb: int | None) -> str | None",
      "summary": "Construct a human-readable RAM label.",
      "layer": "service",
      "docstring": "Construct a human-readable RAM label.",
      "category": "business_logic"
    },
    {
      "name": "normalize_ram_spec_payload",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 82,
      "signature": "normalize_ram_spec_payload(data: dict[str, Any] | None, fallback_total_gb: int | None, fallback_generation: RamGeneration | None, fallback_speed: int | None) -> dict[str, Any] | None",
      "summary": "Normalize raw RAM spec payload into ORM-ready fields.",
      "layer": "service",
      "docstring": "Normalize raw RAM spec payload into ORM-ready fields.",
      "category": "business_logic"
    },
    {
      "name": "get_or_create_ram_spec",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 142,
      "signature": "async get_or_create_ram_spec(session: AsyncSession, spec_data: dict[str, Any]) -> RamSpec",
      "summary": "Return existing RAM spec matching payload or create a new one.",
      "layer": "service",
      "docstring": "Return existing RAM spec matching payload or create a new one.",
      "category": "business_logic"
    },
    {
      "name": "normalize_storage_medium",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 187,
      "signature": "normalize_storage_medium(value: Any) -> StorageMedium",
      "summary": "Map free-form storage descriptors to canonical medium enum.",
      "layer": "service",
      "docstring": "Map free-form storage descriptors to canonical medium enum.",
      "category": "business_logic"
    },
    {
      "name": "format_storage_label",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 214,
      "signature": "format_storage_label(medium: StorageMedium, capacity_gb: int | None, interface: str | None, form_factor: str | None) -> str | None",
      "summary": "Construct a concise storage profile label.",
      "layer": "service",
      "docstring": "Construct a concise storage profile label.",
      "category": "business_logic"
    },
    {
      "name": "normalize_storage_profile_payload",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 235,
      "signature": "normalize_storage_profile_payload(data: dict[str, Any] | None, fallback_capacity_gb: int | None, fallback_type: Any | None) -> dict[str, Any] | None",
      "summary": "Normalize raw storage profile payload into ORM-ready fields.",
      "layer": "service",
      "docstring": "Normalize raw storage profile payload into ORM-ready fields.",
      "category": "business_logic"
    },
    {
      "name": "get_or_create_storage_profile",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 276,
      "signature": "async get_or_create_storage_profile(session: AsyncSession, profile_data: dict[str, Any]) -> StorageProfile",
      "summary": "Return existing storage profile matching payload or create a new one.",
      "layer": "service",
      "docstring": "Return existing storage profile matching payload or create a new one.",
      "category": "business_logic"
    },
    {
      "name": "storage_medium_display",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/component_catalog.py",
      "line": 318,
      "signature": "storage_medium_display(medium: StorageMedium) -> str | None",
      "summary": "Provide human-friendly medium label for UI surfaces.",
      "layer": "service",
      "docstring": "Provide human-friendly medium label for UI surfaces.",
      "category": "business_logic"
    },
    {
      "name": "RulesService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 29,
      "signature": "class RulesService",
      "summary": "Service for managing valuation rules",
      "layer": "service",
      "docstring": "Service for managing valuation rules",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 32,
      "signature": "__init__(self, trigger_recalculation: bool) -> None",
      "summary": "Initialize rules service.",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Initialize rules service.\n\nArgs:\n    trigger_recalculation: If False, skip enqueuing recalculation tasks.\n                          Useful for batch operations or when Redis is unavailable.",
      "category": "business_logic"
    },
    {
      "name": "create_ruleset",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 48,
      "signature": "async create_ruleset(self, session: AsyncSession, name: str | BaseModel | dict[str, Any], description: str | None, version: str, created_by: str | None, metadata: dict[str, Any] | None, priority: int, conditions: dict[str, Any] | None, is_active: bool) -> ValuationRuleset",
      "summary": "Create a new ruleset.",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Create a new ruleset.\n\nAccepts either explicit parameters or a schema/dict payload supplied via the `name` argument.",
      "category": "business_logic"
    },
    {
      "name": "get_ruleset",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 120,
      "signature": "async get_ruleset(self, session: AsyncSession, ruleset_id: int) -> ValuationRuleset | None",
      "summary": "Get ruleset by ID with all related data",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Get ruleset by ID with all related data",
      "category": "business_logic"
    },
    {
      "name": "list_rulesets",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 134,
      "signature": "async list_rulesets(self, session: AsyncSession, active_only: bool, skip: int, limit: int) -> list[ValuationRuleset]",
      "summary": "List all rulesets",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "List all rulesets",
      "category": "business_logic"
    },
    {
      "name": "update_ruleset",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 159,
      "signature": "async update_ruleset(self, session: AsyncSession, ruleset_id: int, updates: dict[str, Any] | BaseModel, updated_by: str | None) -> ValuationRuleset | None",
      "summary": "Update ruleset",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Update ruleset",
      "category": "business_logic"
    },
    {
      "name": "delete_ruleset",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 207,
      "signature": "async delete_ruleset(self, session: AsyncSession, ruleset_id: int, deleted_by: str | None) -> bool",
      "summary": "Delete ruleset (cascades to groups and rules)",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Delete ruleset (cascades to groups and rules)",
      "category": "business_logic"
    },
    {
      "name": "create_rule_group",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 235,
      "signature": "async create_rule_group(self, session: AsyncSession, ruleset_id: int, name: str | BaseModel | dict[str, Any], category: str | None, description: str | None, display_order: int, weight: float, is_active: bool, metadata: dict[str, Any] | None) -> ValuationRuleGroup",
      "summary": "Create a new rule group",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Create a new rule group",
      "category": "business_logic"
    },
    {
      "name": "get_rule_group",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 288,
      "signature": "async get_rule_group(self, session: AsyncSession, group_id: int) -> ValuationRuleGroup | None",
      "summary": "Get rule group by ID",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Get rule group by ID",
      "category": "business_logic"
    },
    {
      "name": "update_rule_group",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 302,
      "signature": "async update_rule_group(self, session: AsyncSession, group_id: int, updates: dict[str, Any] | BaseModel, updated_by: str | None) -> ValuationRuleGroup | None",
      "summary": "Update a rule group",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Update a rule group",
      "category": "business_logic"
    },
    {
      "name": "list_rule_groups",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 337,
      "signature": "async list_rule_groups(self, session: AsyncSession, ruleset_id: int | None, category: str | None) -> list[ValuationRuleGroup]",
      "summary": "List rule groups",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "List rule groups",
      "category": "business_logic"
    },
    {
      "name": "create_rule",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 358,
      "signature": "async create_rule(self, session: AsyncSession, group_id: int, name: str, description: str | None, priority: int, evaluation_order: int, conditions: list[dict[str, Any]] | None, actions: list[dict[str, Any]] | None, created_by: str | None, metadata: dict[str, Any] | None) -> ValuationRuleV2",
      "summary": "Create a new rule with conditions and actions",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Create a new rule with conditions and actions",
      "category": "business_logic"
    },
    {
      "name": "get_rule",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 437,
      "signature": "async get_rule(self, session: AsyncSession, rule_id: int) -> ValuationRuleV2 | None",
      "summary": "Get rule by ID with all related data",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Get rule by ID with all related data",
      "category": "business_logic"
    },
    {
      "name": "list_rules",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 455,
      "signature": "async list_rules(self, session: AsyncSession, group_id: int | None, active_only: bool, skip: int, limit: int) -> list[ValuationRuleV2]",
      "summary": "List rules",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "List rules",
      "category": "business_logic"
    },
    {
      "name": "update_rule",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 480,
      "signature": "async update_rule(self, session: AsyncSession, rule_id: int, updates: dict[str, Any], updated_by: str | None, change_summary: str | None) -> ValuationRuleV2 | None",
      "summary": "Update rule and create version snapshot",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Update rule and create version snapshot",
      "category": "business_logic"
    },
    {
      "name": "delete_rule",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 567,
      "signature": "async delete_rule(self, session: AsyncSession, rule_id: int, deleted_by: str | None) -> bool",
      "summary": "Delete rule",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Delete rule",
      "category": "business_logic"
    },
    {
      "name": "get_audit_log",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rules.py",
      "line": 678,
      "signature": "async get_audit_log(self, session: AsyncSession, rule_id: int | None, limit: int) -> list[ValuationRuleAudit]",
      "summary": "Get audit log entries",
      "layer": "service",
      "parent": "RulesService",
      "docstring": "Get audit log entries",
      "category": "business_logic"
    },
    {
      "name": "RulesetPackagingService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ruleset_packaging.py",
      "line": 43,
      "signature": "class RulesetPackagingService",
      "summary": "Service for packaging and installing rulesets.",
      "layer": "service",
      "docstring": "Service for packaging and installing rulesets.",
      "category": "business_logic"
    },
    {
      "name": "export_ruleset_to_package",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/ruleset_packaging.py",
      "line": 46,
      "signature": "async export_ruleset_to_package(self, session: AsyncSession, ruleset_id: int, metadata: PackageMetadata, include_examples: bool, include_baseline: bool, active_only: bool) -> RulesetPackage",
      "summary": "Export a ruleset to a complete package.",
      "layer": "service",
      "parent": "RulesetPackagingService",
      "docstring": "Export a ruleset to a complete package.\n\nArgs:\n    session: Database session\n    ruleset_id: ID of the ruleset to export\n    metadata: Package metadata\n    include_examples: Whether to include example listings\n    include_baseline: Whether to include baseline rulesets (default: False)\n    active_only: Whether to only include active rules (default: False)\n\nReturns:\n    Complete RulesetPackage ready for export",
      "category": "business_logic"
    },
    {
      "name": "export_to_file",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/ruleset_packaging.py",
      "line": 199,
      "signature": "async export_to_file(self, session: AsyncSession, ruleset_id: int, metadata: PackageMetadata, output_path: str, include_baseline: bool) -> None",
      "summary": "Export ruleset to a .dbrs file.",
      "layer": "service",
      "parent": "RulesetPackagingService",
      "docstring": "Export ruleset to a .dbrs file.\n\nArgs:\n    session: Database session\n    ruleset_id: ID of the ruleset to export\n    metadata: Package metadata\n    output_path: Path to output file\n    include_baseline: Whether to include baseline rulesets",
      "category": "business_logic"
    },
    {
      "name": "install_package",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/ruleset_packaging.py",
      "line": 225,
      "signature": "async install_package(self, session: AsyncSession, package: RulesetPackage, actor: str, merge_strategy: Literal['replace', 'skip', 'merge', 'version'], baseline_import_mode: Literal['version', 'replace']) -> Dict[str, Any]",
      "summary": "Install a ruleset package into the database.",
      "layer": "service",
      "parent": "RulesetPackagingService",
      "docstring": "Install a ruleset package into the database.\n\nArgs:\n    session: Database session\n    package: Package to install\n    actor: User performing the installation\n    merge_strategy: How to handle conflicts for normal rulesets\n    baseline_import_mode: How to handle baseline imports (\"version\" or \"replace\")\n\nReturns:\n    Dict with installation results",
      "category": "business_logic"
    },
    {
      "name": "install_from_file",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/ruleset_packaging.py",
      "line": 612,
      "signature": "async install_from_file(self, session: AsyncSession, file_path: str, actor: str, merge_strategy: Literal['replace', 'skip', 'merge', 'version'], baseline_import_mode: Literal['version', 'replace']) -> Dict[str, Any]",
      "summary": "Install a package from a .dbrs file.",
      "layer": "service",
      "parent": "RulesetPackagingService",
      "docstring": "Install a package from a .dbrs file.\n\nArgs:\n    session: Database session\n    file_path: Path to .dbrs file\n    actor: User performing the installation\n    merge_strategy: How to handle conflicts for normal rulesets\n    baseline_import_mode: How to handle baseline imports\n\nReturns:\n    Installation results",
      "category": "business_logic"
    },
    {
      "name": "BaselineAuditService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/baseline_audit.py",
      "line": 14,
      "signature": "class BaselineAuditService",
      "summary": "Service for logging baseline operations.",
      "layer": "service",
      "docstring": "Service for logging baseline operations.",
      "category": "business_logic"
    },
    {
      "name": "log_instantiation",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_audit.py",
      "line": 17,
      "signature": "async log_instantiation(self, session: AsyncSession, actor: str | None, source_hash: str, version: str, ruleset_id: int | None, success: bool, error: str | None, payload: dict[str, Any] | None) -> BaselineAuditLog",
      "summary": "Log baseline instantiation operation.",
      "layer": "service",
      "parent": "BaselineAuditService",
      "docstring": "Log baseline instantiation operation.\n\nArgs:\n    session: Database session\n    actor: Actor name or ID\n    source_hash: Hash of baseline source\n    version: Baseline version\n    ruleset_id: Created ruleset ID\n    success: Whether operation succeeded\n    error: Error message if failed\n    payload: Additional operation data\n\nReturns:\n    Created audit log entry",
      "category": "business_logic"
    },
    {
      "name": "log_diff_request",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_audit.py",
      "line": 65,
      "signature": "async log_diff_request(self, session: AsyncSession, actor: str | None, candidate_hash: str, current_hash: str | None, payload: dict[str, Any] | None) -> BaselineAuditLog",
      "summary": "Log baseline diff request.",
      "layer": "service",
      "parent": "BaselineAuditService",
      "docstring": "Log baseline diff request.\n\nArgs:\n    session: Database session\n    actor: Actor name or ID\n    candidate_hash: Hash of candidate baseline\n    current_hash: Hash of current baseline\n    payload: Diff results\n\nReturns:\n    Created audit log entry",
      "category": "business_logic"
    },
    {
      "name": "log_adoption",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_audit.py",
      "line": 108,
      "signature": "async log_adoption(self, session: AsyncSession, actor: str | None, changes_applied: int, new_version: str, old_version: str | None, new_hash: str, old_hash: str | None, affected_listings: int | None, payload: dict[str, Any] | None) -> BaselineAuditLog",
      "summary": "Log baseline adoption operation.",
      "layer": "service",
      "parent": "BaselineAuditService",
      "docstring": "Log baseline adoption operation.\n\nArgs:\n    session: Database session\n    actor: Actor name or ID\n    changes_applied: Number of changes applied\n    new_version: New baseline version\n    old_version: Previous baseline version\n    new_hash: New baseline hash\n    old_hash: Previous baseline hash\n    affected_listings: Number of affected listings\n    payload: Additional operation data\n\nReturns:\n    Created audit log entry",
      "category": "business_logic"
    },
    {
      "name": "log_override_operation",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_audit.py",
      "line": 164,
      "signature": "async log_override_operation(self, session: AsyncSession, operation: str, actor: str | None, entity_key: str, field_name: str, old_value: Any, new_value: Any, success: bool, error: str | None) -> BaselineAuditLog",
      "summary": "Log override operation.",
      "layer": "service",
      "parent": "BaselineAuditService",
      "docstring": "Log override operation.\n\nArgs:\n    session: Database session\n    operation: Type of override operation\n    actor: Actor name or ID\n    entity_key: Entity identifier\n    field_name: Field being overridden\n    old_value: Previous value\n    new_value: New value\n    success: Whether operation succeeded\n    error: Error message if failed\n\nReturns:\n    Created audit log entry",
      "category": "business_logic"
    },
    {
      "name": "log_bulk_operation",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_audit.py",
      "line": 217,
      "signature": "async log_bulk_operation(self, session: AsyncSession, operation: str, actor: str | None, affected_count: int, total_adjustment_change: float | None, success: bool, error: str | None, payload: dict[str, Any] | None) -> BaselineAuditLog",
      "summary": "Log bulk baseline operation.",
      "layer": "service",
      "parent": "BaselineAuditService",
      "docstring": "Log bulk baseline operation.\n\nArgs:\n    session: Database session\n    operation: Type of bulk operation\n    actor: Actor name or ID\n    affected_count: Number of entities affected\n    total_adjustment_change: Total valuation change\n    success: Whether operation succeeded\n    error: Error message if failed\n    payload: Additional operation data\n\nReturns:\n    Created audit log entry",
      "category": "business_logic"
    },
    {
      "name": "get_recent_operations",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_audit.py",
      "line": 264,
      "signature": "async get_recent_operations(self, session: AsyncSession, limit: int, operation_type: str | None, actor: str | None) -> list[BaselineAuditLog]",
      "summary": "Get recent audit log entries.",
      "layer": "service",
      "parent": "BaselineAuditService",
      "docstring": "Get recent audit log entries.\n\nArgs:\n    session: Database session\n    limit: Maximum number of entries to return\n    operation_type: Filter by operation type\n    actor: Filter by actor\n\nReturns:\n    List of audit log entries",
      "category": "business_logic"
    },
    {
      "name": "BaselineLoadResult",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 32,
      "signature": "class BaselineLoadResult",
      "summary": "Summary of a baseline ingestion run.",
      "layer": "service",
      "docstring": "Summary of a baseline ingestion run.",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 44,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "Return a serialisable representation.",
      "layer": "service",
      "parent": "BaselineLoadResult",
      "docstring": "Return a serialisable representation.",
      "category": "business_logic"
    },
    {
      "name": "BaselineLoaderService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 58,
      "signature": "class BaselineLoaderService",
      "summary": "Map curated baseline JSON into system rulesets.",
      "layer": "service",
      "docstring": "Map curated baseline JSON into system rulesets.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 61,
      "signature": "__init__(self, rules_service: RulesService | None) -> None",
      "summary": "",
      "layer": "service",
      "parent": "BaselineLoaderService",
      "category": "business_logic"
    },
    {
      "name": "load_from_path",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 66,
      "signature": "async load_from_path(self, session: AsyncSession, source_path: Path | str, actor: str | None, ensure_basic_for_ruleset: int | None) -> BaselineLoadResult",
      "summary": "Load baseline data from a JSON file.",
      "layer": "service",
      "parent": "BaselineLoaderService",
      "docstring": "Load baseline data from a JSON file.",
      "category": "business_logic"
    },
    {
      "name": "load_from_payload",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 89,
      "signature": "async load_from_payload(self, session: AsyncSession, payload: dict[str, Any], actor: str | None, ensure_basic_for_ruleset: int | None, source_reference: str | None) -> BaselineLoadResult",
      "summary": "Create a baseline ruleset from an in-memory payload.",
      "layer": "service",
      "parent": "BaselineLoaderService",
      "docstring": "Create a baseline ruleset from an in-memory payload.",
      "category": "business_logic"
    },
    {
      "name": "ensure_basic_adjustments_group",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 213,
      "signature": "async ensure_basic_adjustments_group(self, session: AsyncSession, target_ruleset_id: int | None, actor: str | None) -> ValuationRuleGroup | None",
      "summary": "Guarantee the presence of a managed Basic Adjustments group.",
      "layer": "service",
      "parent": "BaselineLoaderService",
      "docstring": "Guarantee the presence of a managed Basic Adjustments group.",
      "category": "business_logic"
    },
    {
      "name": "get_baseline_metadata",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 413,
      "signature": "async get_baseline_metadata(self, session: AsyncSession) -> BaselineMetadataResponse | None",
      "summary": "Extract metadata from the currently active baseline ruleset.",
      "layer": "service",
      "parent": "BaselineLoaderService",
      "docstring": "Extract metadata from the currently active baseline ruleset.\n\nReturns:\n    BaselineMetadataResponse if active baseline exists, None otherwise.",
      "category": "business_logic"
    },
    {
      "name": "diff_baseline",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 508,
      "signature": "async diff_baseline(self, session: AsyncSession, candidate_json: dict[str, Any]) -> BaselineDiffResponse",
      "summary": "Compare candidate baseline against the current active baseline.",
      "layer": "service",
      "parent": "BaselineLoaderService",
      "docstring": "Compare candidate baseline against the current active baseline.\n\nArgs:\n    session: Database session\n    candidate_json: Candidate baseline JSON structure\n\nReturns:\n    BaselineDiffResponse with added, changed, and removed fields",
      "category": "business_logic"
    },
    {
      "name": "adopt_baseline",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_loader.py",
      "line": 663,
      "signature": "async adopt_baseline(self, session: AsyncSession, candidate_json: dict[str, Any], selected_changes: list[str] | None, actor: str | None) -> dict[str, Any]",
      "summary": "Adopt selected changes from candidate baseline, creating a new version.",
      "layer": "service",
      "parent": "BaselineLoaderService",
      "docstring": "Adopt selected changes from candidate baseline, creating a new version.\n\nArgs:\n    session: Database session\n    candidate_json: Candidate baseline JSON structure\n    selected_changes: Optional list of field IDs to adopt (entity.field format)\n                    If None, all changes are adopted\n    actor: User/system actor performing adoption\n\nReturns:\n    Dict with adoption results including new ruleset ID, version, and audit log",
      "category": "business_logic"
    },
    {
      "name": "BaselineMetricsService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/baseline_metrics.py",
      "line": 22,
      "signature": "class BaselineMetricsService",
      "summary": "Service for calculating and aggregating baseline metrics.",
      "layer": "service",
      "docstring": "Service for calculating and aggregating baseline metrics.",
      "category": "business_logic"
    },
    {
      "name": "calculate_layer_influence",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_metrics.py",
      "line": 25,
      "signature": "async calculate_layer_influence(self, session: AsyncSession) -> dict[str, float]",
      "summary": "Calculate percentage of listings influenced by each layer.",
      "layer": "service",
      "parent": "BaselineMetricsService",
      "docstring": "Calculate percentage of listings influenced by each layer.\n\nReturns:\n    Dictionary with layer names and percentages",
      "category": "business_logic"
    },
    {
      "name": "get_top_rules_by_contribution",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_metrics.py",
      "line": 64,
      "signature": "async get_top_rules_by_contribution(self, session: AsyncSession, limit: int, days_back: int) -> list[dict[str, Any]]",
      "summary": "Get top rules by absolute contribution amount.",
      "layer": "service",
      "parent": "BaselineMetricsService",
      "docstring": "Get top rules by absolute contribution amount.\n\nArgs:\n    session: Database session\n    limit: Number of top rules to return\n    days_back: Number of days to look back for aggregation\n\nReturns:\n    List of rule dictionaries with contribution data",
      "category": "business_logic"
    },
    {
      "name": "calculate_override_churn",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_metrics.py",
      "line": 130,
      "signature": "async calculate_override_churn(self, session: AsyncSession, days_back: int) -> dict[str, Any]",
      "summary": "Calculate override churn rate over specified period.",
      "layer": "service",
      "parent": "BaselineMetricsService",
      "docstring": "Calculate override churn rate over specified period.\n\nArgs:\n    session: Database session\n    days_back: Number of days to analyze\n\nReturns:\n    Dictionary with churn metrics\n\nNote:\n    This method currently returns placeholder data until the EntityFieldValue\n    model is implemented. This is part of the baseline valuation enhancement\n    feature and will be fully functional once the field value storage model\n    is created.",
      "category": "business_logic"
    },
    {
      "name": "get_baseline_summary",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_metrics.py",
      "line": 166,
      "signature": "async get_baseline_summary(self, session: AsyncSession) -> dict[str, Any]",
      "summary": "Get comprehensive baseline metrics summary.",
      "layer": "service",
      "parent": "BaselineMetricsService",
      "docstring": "Get comprehensive baseline metrics summary.\n\nReturns:\n    Dictionary with all baseline metrics",
      "category": "business_logic"
    },
    {
      "name": "store_metrics_snapshot",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_metrics.py",
      "line": 219,
      "signature": "async store_metrics_snapshot(self, session: AsyncSession, metrics: dict[str, Any]) -> None",
      "summary": "Store metrics snapshot for historical tracking.",
      "layer": "service",
      "parent": "BaselineMetricsService",
      "docstring": "Store metrics snapshot for historical tracking.\n\nArgs:\n    session: Database session\n    metrics: Metrics to store",
      "category": "business_logic"
    },
    {
      "name": "HydrationResult",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/baseline_hydration.py",
      "line": 24,
      "signature": "class HydrationResult",
      "summary": "Result of hydrating baseline rules in a ruleset.",
      "layer": "service",
      "docstring": "Result of hydrating baseline rules in a ruleset.",
      "category": "business_logic"
    },
    {
      "name": "BaselineHydrationService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/baseline_hydration.py",
      "line": 34,
      "signature": "class BaselineHydrationService",
      "summary": "Service for hydrating baseline placeholder rules into editable rule structures.",
      "layer": "service",
      "docstring": "Service for hydrating baseline placeholder rules into editable rule structures.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/baseline_hydration.py",
      "line": 40,
      "signature": "__init__(self, rules_service: RulesService | None) -> None",
      "summary": "Initialize the hydration service.",
      "layer": "service",
      "parent": "BaselineHydrationService",
      "docstring": "Initialize the hydration service.\n\nArgs:\n    rules_service: RulesService instance for creating rules.\n                  If None, creates a new instance with recalculation disabled.",
      "category": "business_logic"
    },
    {
      "name": "hydrate_baseline_rules",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_hydration.py",
      "line": 69,
      "signature": "async hydrate_baseline_rules(self, session: AsyncSession, ruleset_id: int, actor: str) -> HydrationResult",
      "summary": "Hydrate all placeholder baseline rules in a ruleset.",
      "layer": "service",
      "parent": "BaselineHydrationService",
      "docstring": "Hydrate all placeholder baseline rules in a ruleset.\n\nThis method:\n1. Finds all rules marked as baseline_placeholder in the ruleset\n2. Expands each placeholder into full rules with conditions/actions\n3. Marks original placeholders as hydrated and deactivates them\n4. Returns a summary of the hydration operation\n\nArgs:\n    session: Database session\n    ruleset_id: ID of the ruleset to hydrate\n    actor: User or system identifier performing the hydration\n\nReturns:\n    HydrationResult with status, counts, and summary",
      "category": "business_logic"
    },
    {
      "name": "hydrate_single_rule",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/baseline_hydration.py",
      "line": 143,
      "signature": "async hydrate_single_rule(self, session: AsyncSession, rule_id: int, actor: str) -> list[ValuationRuleV2]",
      "summary": "Hydrate a single placeholder rule into expanded rules.",
      "layer": "service",
      "parent": "BaselineHydrationService",
      "docstring": "Hydrate a single placeholder rule into expanded rules.\n\nRoutes to the appropriate hydration strategy based on field_type metadata:\n- enum_multiplier: Creates one rule per enum value with conditions\n- formula: Creates single rule with formula action\n- fixed/additive: Creates single rule with fixed value action\n- scalar: Skipped (represents FK relationships, not valuation rules)\n\nArgs:\n    session: Database session\n    rule_id: ID of the placeholder rule to hydrate\n    actor: User or system identifier performing the hydration\n\nReturns:\n    List of expanded rules created from the placeholder.\n    Empty list if rule is scalar type (FK relationship).\n\nRaises:\n    ValueError: If rule not found or not a baseline placeholder",
      "category": "business_logic"
    },
    {
      "name": "get_field_distinct_values",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/field_values.py",
      "line": 17,
      "signature": "async get_field_distinct_values(session: AsyncSession, field_name: str, limit: int, search: str | None) -> list[str]",
      "summary": "Get distinct values for a given field across all entities.",
      "layer": "service",
      "docstring": "Get distinct values for a given field across all entities.\n\nArgs:\n    session: Database session\n    field_name: Field name in format \"entity.field\" (e.g., \"listing.condition\")\n    limit: Maximum number of values to return\n    search: Optional search filter\n\nReturns:\n    List of distinct string values\n\nRaises:\n    ValueError: If field_name format is invalid or field not found",
      "category": "business_logic"
    },
    {
      "name": "get_listing_column",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/field_values.py",
      "line": 85,
      "signature": "get_listing_column(field_key: str) -> InstrumentedAttribute[Any] | None",
      "summary": "Map field key to Listing model column.",
      "layer": "service",
      "docstring": "Map field key to Listing model column.",
      "category": "business_logic"
    },
    {
      "name": "get_cpu_column",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/field_values.py",
      "line": 105,
      "signature": "get_cpu_column(field_key: str) -> InstrumentedAttribute[Any] | None",
      "summary": "Map field key to CPU model column.",
      "layer": "service",
      "docstring": "Map field key to CPU model column.",
      "category": "business_logic"
    },
    {
      "name": "get_gpu_column",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/field_values.py",
      "line": 117,
      "signature": "get_gpu_column(field_key: str) -> InstrumentedAttribute[Any] | None",
      "summary": "Map field key to GPU model column.",
      "layer": "service",
      "docstring": "Map field key to GPU model column.",
      "category": "business_logic"
    },
    {
      "name": "FormulaValidationService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/formula_validation.py",
      "line": 17,
      "signature": "class FormulaValidationService",
      "summary": "Service for validating formulas and providing preview calculations",
      "layer": "service",
      "docstring": "Service for validating formulas and providing preview calculations",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/formula_validation.py",
      "line": 20,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "service",
      "parent": "FormulaValidationService",
      "category": "business_logic"
    },
    {
      "name": "get_available_fields",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/formula_validation.py",
      "line": 25,
      "signature": "async get_available_fields(self, session: AsyncSession, entity_type: str) -> set[str]",
      "summary": "Get available field names for an entity type.",
      "layer": "service",
      "parent": "FormulaValidationService",
      "docstring": "Get available field names for an entity type.\n\nArgs:\n    session: Database session\n    entity_type: Entity type (Listing, CPU, GPU, etc.)\n\nReturns:\n    Set of available field names",
      "category": "business_logic"
    },
    {
      "name": "get_sample_context",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/formula_validation.py",
      "line": 165,
      "signature": "async get_sample_context(self, session: AsyncSession, entity_type: str, provided_context: dict[str, Any] | None) -> dict[str, Any]",
      "summary": "Get sample context data for formula preview.",
      "layer": "service",
      "parent": "FormulaValidationService",
      "docstring": "Get sample context data for formula preview.\n\nArgs:\n    session: Database session\n    entity_type: Entity type (Listing, CPU, GPU, etc.)\n    provided_context: Optional user-provided context values\n\nReturns:\n    Dictionary with sample field values",
      "category": "business_logic"
    },
    {
      "name": "validate_formula",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/formula_validation.py",
      "line": 334,
      "signature": "async validate_formula(self, session: AsyncSession, formula: str, entity_type: str, sample_context: dict[str, Any] | None) -> dict[str, Any]",
      "summary": "Validate a formula and provide preview calculation.",
      "layer": "service",
      "parent": "FormulaValidationService",
      "docstring": "Validate a formula and provide preview calculation.\n\nArgs:\n    session: Database session\n    formula: Formula string to validate\n    entity_type: Entity type for field context\n    sample_context: Optional sample context for preview\n\nReturns:\n    Dictionary with validation results",
      "category": "business_logic"
    },
    {
      "name": "apply_listing_metrics",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 284,
      "signature": "async apply_listing_metrics(session: AsyncSession, listing: Listing) -> None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "build_component_inputs",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 435,
      "signature": "build_component_inputs(listing: Listing) -> Iterable[ComponentValuationInput]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "storage_component_type",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 470,
      "signature": "storage_component_type(storage_type: str | None) -> ComponentType",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "get_default_profile",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 479,
      "signature": "async get_default_profile(session: AsyncSession) -> Profile | None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "create_listing",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 488,
      "signature": "async create_listing(session: AsyncSession, payload: dict) -> Listing",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "update_listing",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 507,
      "signature": "async update_listing(session: AsyncSession, listing: Listing, payload: dict) -> Listing",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "sync_listing_components",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 522,
      "signature": "async sync_listing_components(session: AsyncSession, listing: Listing, components_payload: list[dict] | None) -> None",
      "summary": "Replace listing components using explicit SQL to avoid lazy relationship access.",
      "layer": "service",
      "docstring": "Replace listing components using explicit SQL to avoid lazy relationship access.",
      "category": "business_logic"
    },
    {
      "name": "partial_update_listing",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 559,
      "signature": "async partial_update_listing(session: AsyncSession, listing: Listing, fields: dict[str, Any] | None, attributes: dict[str, Any] | None, run_metrics: bool) -> Listing",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "update_listing_overrides",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 618,
      "signature": "async update_listing_overrides(session: AsyncSession, listing: Listing, mode: str, ruleset_id: int | None, disabled_rulesets: Iterable[Any] | None) -> Listing",
      "summary": "Update listing valuation overrides (static assignment and disabled dynamic rulesets).",
      "layer": "service",
      "docstring": "Update listing valuation overrides (static assignment and disabled dynamic rulesets).",
      "category": "business_logic"
    },
    {
      "name": "bulk_update_listings",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 646,
      "signature": "async bulk_update_listings(session: AsyncSession, listing_ids: list[int], fields: dict[str, Any] | None, attributes: dict[str, Any] | None) -> list[Listing]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "calculate_cpu_performance_metrics",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 706,
      "signature": "calculate_cpu_performance_metrics(listing: Listing) -> dict[str, float]",
      "summary": "Calculate all CPU-based performance metrics for a listing.",
      "layer": "service",
      "docstring": "Calculate all CPU-based performance metrics for a listing.\n\nReturns\n-------\n    Dictionary with metric keys and calculated values.\n    Empty dict if CPU not assigned or missing benchmark data.",
      "category": "business_logic"
    },
    {
      "name": "update_listing_metrics",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 737,
      "signature": "async update_listing_metrics(session: AsyncSession, listing_id: int) -> Listing",
      "summary": "Recalculate and persist all performance metrics for a listing.",
      "layer": "service",
      "docstring": "Recalculate and persist all performance metrics for a listing.\n\nArgs:\n----\n    session: Database session\n    listing_id: ID of listing to update\n\nReturns:\n-------\n    Updated listing with recalculated metrics\n\nRaises:\n------\n    ValueError: If listing not found",
      "category": "business_logic"
    },
    {
      "name": "bulk_update_listing_metrics",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 779,
      "signature": "async bulk_update_listing_metrics(session: AsyncSession, listing_ids: list[int] | None) -> int",
      "summary": "Recalculate metrics for multiple listings.",
      "layer": "service",
      "docstring": "Recalculate metrics for multiple listings.\n\nArgs:\n----\n    session: Database session\n    listing_ids: List of IDs to update. If None, updates all listings.\n\nReturns:\n-------\n    Count of listings updated",
      "category": "business_logic"
    },
    {
      "name": "upsert_from_url",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/services/listings.py",
      "line": 820,
      "signature": "async upsert_from_url(session: AsyncSession, normalized: NormalizedListingSchema, dedupe_result: DeduplicationResult) -> Listing",
      "summary": "Upsert listing from URL ingestion.",
      "layer": "service",
      "docstring": "Upsert listing from URL ingestion.\n\nIf dedup match found, updates existing listing with new data.\nIf new listing, creates listing with URL ingestion metadata.\n\nThis method integrates URL ingestion with existing ListingsService,\nmaintaining backward compatibility with Excel import flow.\n\nArgs:\n----\n    session: Database session (caller controls transaction)\n    normalized: Normalized listing data from adapter\n    dedupe_result: Deduplication result with match info\n\nReturns:\n-------\n    Created or updated Listing instance\n\nRaises:\n------\n    ValueError: If normalized data invalid or condition cannot be mapped\n\nExample:\n-------\n    >>> from dealbrain_core.schemas.ingestion import NormalizedListingSchema\n    >>> from dealbrain_api.services.ingestion import DeduplicationResult\n    >>>\n    >>> normalized = NormalizedListingSchema(\n    ...     title=\"Gaming PC\",\n    ...     price=Decimal(\"599.99\"),\n    ...     currency=\"USD\",\n    ...     condition=\"new\",\n    ...     marketplace=\"ebay\",\n    ...     vendor_item_id=\"123456789012\",\n    ...     provenance=\"ebay_api\",\n    ...     dedup_hash=\"abc123...\",\n    ... )\n    >>> dedupe_result = DeduplicationResult(\n    ...     exists=False,\n    ...     existing_listing=None,\n    ...     is_exact_match=False,\n    ...     confidence=0.0,\n    ...     dedup_hash=\"abc123...\",\n    ... )\n    >>> listing = await upsert_from_url(session, normalized, dedupe_result)",
      "category": "business_logic"
    },
    {
      "name": "RuleEvaluationService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/rule_evaluation.py",
      "line": 52,
      "signature": "class RuleEvaluationService",
      "summary": "Service for evaluating valuation rules against listings",
      "layer": "service",
      "docstring": "Service for evaluating valuation rules against listings",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/rule_evaluation.py",
      "line": 55,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "service",
      "parent": "RuleEvaluationService",
      "category": "business_logic"
    },
    {
      "name": "evaluate_listing",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rule_evaluation.py",
      "line": 59,
      "signature": "async evaluate_listing(self, session: AsyncSession, listing_id: int, ruleset_id: int | None) -> dict[str, Any]",
      "summary": "Evaluate a listing against one or more rulesets.",
      "layer": "service",
      "parent": "RuleEvaluationService",
      "docstring": "Evaluate a listing against one or more rulesets.\n\nIf ruleset_id is provided, only that ruleset is evaluated.\nOtherwise, evaluates all active rulesets in priority order.\n\nArgs:\n    session: Database session\n    listing_id: Listing ID to evaluate\n    ruleset_id: Specific ruleset to use (optional)\n\nReturns:\n    Dictionary with valuation results including layer attribution",
      "category": "business_logic"
    },
    {
      "name": "evaluate_multiple_listings",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rule_evaluation.py",
      "line": 251,
      "signature": "async evaluate_multiple_listings(self, session: AsyncSession, listing_ids: list[int], ruleset_id: int | None) -> list[dict[str, Any]]",
      "summary": "Evaluate multiple listings against rulesets.",
      "layer": "service",
      "parent": "RuleEvaluationService",
      "docstring": "Evaluate multiple listings against rulesets.\n\nArgs:\n    session: Database session\n    listing_ids: List of listing IDs\n    ruleset_id: Specific ruleset to use (uses all active if None)\n\nReturns:\n    List of evaluation results",
      "category": "business_logic"
    },
    {
      "name": "apply_ruleset_to_listing",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rule_evaluation.py",
      "line": 287,
      "signature": "async apply_ruleset_to_listing(self, session: AsyncSession, listing_id: int, ruleset_id: int | None, commit: bool) -> dict[str, Any]",
      "summary": "Evaluate rulesets and update the listing's valuation data.",
      "layer": "service",
      "parent": "RuleEvaluationService",
      "docstring": "Evaluate rulesets and update the listing's valuation data.\n\nArgs:\n    session: Database session\n    listing_id: Listing ID\n    ruleset_id: Specific ruleset to apply (uses all active if None)\n    commit: Whether to commit changes\n\nReturns:\n    Evaluation result",
      "category": "business_logic"
    },
    {
      "name": "apply_ruleset_to_all_listings",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/rule_evaluation.py",
      "line": 331,
      "signature": "async apply_ruleset_to_all_listings(self, session: AsyncSession, ruleset_id: int | None, batch_size: int) -> dict[str, Any]",
      "summary": "Apply rulesets to all active listings in batches.",
      "layer": "service",
      "parent": "RuleEvaluationService",
      "docstring": "Apply rulesets to all active listings in batches.\n\nArgs:\n    session: Database session\n    ruleset_id: Specific ruleset to apply (uses all active if None)\n    batch_size: Number of listings to process at once\n\nReturns:\n    Summary of application",
      "category": "business_logic"
    },
    {
      "name": "clear_cache",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/rule_evaluation.py",
      "line": 621,
      "signature": "clear_cache(self)",
      "summary": "Clear evaluation cache",
      "layer": "service",
      "parent": "RuleEvaluationService",
      "docstring": "Clear evaluation cache",
      "category": "business_logic"
    },
    {
      "name": "DeduplicationResult",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 31,
      "signature": "class DeduplicationResult",
      "summary": "Result of deduplication check.",
      "layer": "service",
      "docstring": "Result of deduplication check.\n\nAttributes:\n    exists: Whether listing already exists in database\n    existing_listing: The existing listing if found, None otherwise\n    is_exact_match: True if vendor ID match, False if hash match\n    confidence: Match confidence (1.0 for vendor ID, 0.95 for hash)\n    dedup_hash: SHA-256 hash used for deduplication (if applicable)",
      "category": "business_logic"
    },
    {
      "name": "DeduplicationService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 49,
      "signature": "class DeduplicationService",
      "summary": "Service for detecting duplicate listings.",
      "layer": "service",
      "docstring": "Service for detecting duplicate listings.\n\nUses a two-tier deduplication strategy:\n1. Vendor ID match (highest priority, 100% confidence)\n2. Hash-based match (fallback, 95% confidence)\n\nHash formula: SHA-256(normalize(title) + normalize(seller) + normalize(price))\n\nExample:\n    >>> async with session_scope() as session:\n    ...     service = DeduplicationService(session)\n    ...     result = await service.find_existing_listing(normalized_data)\n    ...     if result.exists:\n    ...         print(f\"Duplicate found: {result.existing_listing.id}\")",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 66,
      "signature": "__init__(self, session: AsyncSession)",
      "summary": "Initialize deduplication service.",
      "layer": "service",
      "parent": "DeduplicationService",
      "docstring": "Initialize deduplication service.\n\nArgs:\n    session: Async SQLAlchemy session for database queries",
      "category": "business_logic"
    },
    {
      "name": "find_existing_listing",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 74,
      "signature": "async find_existing_listing(self, normalized_data: NormalizedListingSchema) -> DeduplicationResult",
      "summary": "Find existing listing using vendor ID or hash-based deduplication.",
      "layer": "service",
      "parent": "DeduplicationService",
      "docstring": "Find existing listing using vendor ID or hash-based deduplication.\n\nChecks for duplicates in the following order:\n1. Vendor ID + marketplace match (if available)\n2. Hash-based match (title + seller + price)\n\nArgs:\n    normalized_data: Normalized listing data from adapter\n\nReturns:\n    DeduplicationResult with exists flag and existing listing if found\n\nExample:\n    >>> normalized = NormalizedListingSchema(\n    ...     title=\"Gaming PC\",\n    ...     price=Decimal(\"599.99\"),\n    ...     vendor_item_id=\"123456789012\",\n    ...     marketplace=\"ebay\",\n    ...     condition=\"used\"\n    ... )\n    >>> result = await service.find_existing_listing(normalized)\n    >>> print(f\"Exists: {result.exists}, Confidence: {result.confidence}\")",
      "category": "business_logic"
    },
    {
      "name": "ListingNormalizer",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 296,
      "signature": "class ListingNormalizer",
      "summary": "Normalizes and enriches listing data from adapters.",
      "layer": "service",
      "docstring": "Normalizes and enriches listing data from adapters.\n\nPerforms the following transformations:\n1. Currency conversion to USD using fixed exchange rates\n2. Condition string normalization to standard enum values\n3. Spec extraction from descriptions (CPU/RAM/storage)\n4. CPU canonicalization against catalog with benchmark enrichment\n5. Data quality assessment (full/partial based on field coverage)\n\nExample:\n    >>> async with session_scope() as session:\n    ...     normalizer = ListingNormalizer(session)\n    ...     enriched = await normalizer.normalize(raw_data)\n    ...     quality = normalizer.assess_quality(enriched)\n    ...     print(f\"Enriched CPU: {enriched.cpu_model}, Quality: {quality}\")",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 353,
      "signature": "__init__(self, session: AsyncSession)",
      "summary": "Initialize listing normalizer.",
      "layer": "service",
      "parent": "ListingNormalizer",
      "docstring": "Initialize listing normalizer.\n\nArgs:\n    session: Async SQLAlchemy session for database queries",
      "category": "business_logic"
    },
    {
      "name": "normalize",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 426,
      "signature": "async normalize(self, raw_data: NormalizedListingSchema) -> NormalizedListingSchema",
      "summary": "Normalize and enrich listing data.",
      "layer": "service",
      "parent": "ListingNormalizer",
      "docstring": "Normalize and enrich listing data.\n\nApplies currency conversion, condition normalization, spec extraction,\nand CPU canonicalization to produce a standardized, enriched listing.\n\nArgs:\n    raw_data: Raw normalized data from adapter\n\nReturns:\n    Enriched NormalizedListingSchema with standardized fields\n\nExample:\n    >>> raw = NormalizedListingSchema(\n    ...     title=\"Gaming PC\",\n    ...     price=Decimal(\"500\"),\n    ...     currency=\"EUR\",\n    ...     condition=\"Brand New\",\n    ...     description=\"PC with Intel Core i7-12700K, 16GB RAM, 512GB SSD\",\n    ...     marketplace=\"other\"\n    ... )\n    >>> enriched = await normalizer.normalize(raw)\n    >>> print(f\"Price: ${enriched.price}, CPU: {enriched.cpu_model}\")",
      "category": "business_logic"
    },
    {
      "name": "assess_quality",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 659,
      "signature": "assess_quality(self, normalized: NormalizedListingSchema) -> str",
      "summary": "Return 'full' or 'partial' based on field completeness.",
      "layer": "service",
      "parent": "ListingNormalizer",
      "docstring": "Return 'full' or 'partial' based on field completeness.\n\nQuality assessment:\n- Full: has title, price, condition, CPU, RAM, storage, images (4+ optional fields)\n- Partial: missing one or more optional fields (<4 optional fields)\n\nArgs:\n    normalized: Normalized listing schema\n\nReturns:\n    Quality level: \"full\" or \"partial\"\n\nRaises:\n    ValueError: If required fields (title, price) are missing\n\nExample:\n    >>> data = NormalizedListingSchema(\n    ...     title=\"PC\",\n    ...     price=Decimal(\"599.99\"),\n    ...     condition=\"new\",\n    ...     cpu_model=\"i7-12700K\",\n    ...     ram_gb=16,\n    ...     storage_gb=512,\n    ...     images=[\"http://example.com/img.jpg\"],\n    ...     marketplace=\"other\"\n    ... )\n    >>> normalizer.assess_quality(data)\n    'full'",
      "category": "business_logic"
    },
    {
      "name": "ListingCreatedEvent",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 713,
      "signature": "class ListingCreatedEvent",
      "summary": "Event emitted when a new listing is created.",
      "layer": "service",
      "docstring": "Event emitted when a new listing is created.\n\nAttributes:\n    listing_id: Database ID of the created listing\n    title: Listing title\n    price: Current price in USD\n    marketplace: Marketplace identifier (ebay|amazon|other)\n    vendor_item_id: Marketplace-specific item ID (optional)\n    provenance: Data source (ebay_api|jsonld)\n    quality: Data quality assessment (full|partial)\n    created_at: Timestamp when listing was created",
      "category": "business_logic"
    },
    {
      "name": "PriceChangedEvent",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 738,
      "signature": "class PriceChangedEvent",
      "summary": "Event emitted when a listing's price changes significantly.",
      "layer": "service",
      "docstring": "Event emitted when a listing's price changes significantly.\n\nAttributes:\n    listing_id: Database ID of the listing\n    title: Listing title\n    old_price: Previous price in USD\n    new_price: Current price in USD\n    change_amount: Price difference (new - old, negative = price drop)\n    change_percent: Percentage change ((new - old) / old * 100)\n    marketplace: Marketplace identifier (ebay|amazon|other)\n    vendor_item_id: Marketplace-specific item ID (optional)\n    changed_at: Timestamp when price change was detected",
      "category": "business_logic"
    },
    {
      "name": "should_emit_price_change",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 764,
      "signature": "should_emit_price_change(old_price: Decimal, new_price: Decimal, threshold_abs: Decimal, threshold_pct: Decimal) -> bool",
      "summary": "Determine if price change is significant enough to emit event.",
      "layer": "service",
      "docstring": "Determine if price change is significant enough to emit event.\n\nEmits if EITHER:\n- Absolute change >= threshold_abs\n- Percent change >= threshold_pct\n\nArgs:\n    old_price: Previous price in USD\n    new_price: Current price in USD\n    threshold_abs: Minimum absolute change threshold (e.g., $1.00)\n    threshold_pct: Minimum percent change threshold (e.g., 2.0 for 2%)\n\nReturns:\n    True if price change is significant, False otherwise\n\nExample:\n    >>> should_emit_price_change(\n    ...     Decimal(\"100.00\"),\n    ...     Decimal(\"98.00\"),\n    ...     Decimal(\"1.00\"),\n    ...     Decimal(\"2.0\")\n    ... )\n    True  # $2 change >= $1 threshold AND 2% >= 2% threshold",
      "category": "business_logic"
    },
    {
      "name": "IngestionEventService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 807,
      "signature": "class IngestionEventService",
      "summary": "Service for emitting ingestion-related events.",
      "layer": "service",
      "docstring": "Service for emitting ingestion-related events.\n\nEmits events for:\n- listing.created - When a new listing is imported\n- price.changed - When an existing listing's price changes significantly\n\nPhase 2 Implementation:\n- Uses in-memory event storage for testing\n- Future phases will integrate with Celery, webhooks, or event bus\n\nExample:\n    >>> event_service = IngestionEventService()\n    >>> event_service.emit_listing_created(\n    ...     listing=new_listing,\n    ...     provenance=\"ebay_api\",\n    ...     quality=\"full\"\n    ... )\n    >>> events = event_service.get_events()\n    >>> print(f\"Emitted {len(events)} events\")",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 829,
      "signature": "__init__(self)",
      "summary": "Initialize event service with in-memory event storage.",
      "layer": "service",
      "parent": "IngestionEventService",
      "docstring": "Initialize event service with in-memory event storage.",
      "category": "business_logic"
    },
    {
      "name": "emit_listing_created",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 833,
      "signature": "emit_listing_created(self, listing: Listing, provenance: str, quality: str) -> None",
      "summary": "Emit event when new listing is created.",
      "layer": "service",
      "parent": "IngestionEventService",
      "docstring": "Emit event when new listing is created.\n\nArgs:\n    listing: Newly created listing instance\n    provenance: Data source (ebay_api|jsonld)\n    quality: Data quality assessment (full|partial)\n\nExample:\n    >>> listing = Listing(\n    ...     id=1,\n    ...     title=\"Gaming PC\",\n    ...     price_usd=599.99,\n    ...     marketplace=\"ebay\",\n    ...     vendor_item_id=\"123456789012\"\n    ... )\n    >>> event_service.emit_listing_created(listing, \"ebay_api\", \"full\")",
      "category": "business_logic"
    },
    {
      "name": "emit_price_changed",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 870,
      "signature": "emit_price_changed(self, listing: Listing, old_price: Decimal, new_price: Decimal) -> None",
      "summary": "Emit event when listing price changes significantly.",
      "layer": "service",
      "parent": "IngestionEventService",
      "docstring": "Emit event when listing price changes significantly.\n\nArgs:\n    listing: Listing instance with updated price\n    old_price: Previous price in USD\n    new_price: Current price in USD\n\nExample:\n    >>> listing = Listing(\n    ...     id=1,\n    ...     title=\"Gaming PC\",\n    ...     price_usd=549.99,\n    ...     marketplace=\"ebay\"\n    ... )\n    >>> event_service.emit_price_changed(\n    ...     listing,\n    ...     Decimal(\"599.99\"),\n    ...     Decimal(\"549.99\")\n    ... )",
      "category": "business_logic"
    },
    {
      "name": "check_and_emit_price_change",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 919,
      "signature": "check_and_emit_price_change(self, listing: Listing, old_price: Decimal, new_price: Decimal) -> bool",
      "summary": "Check if price change is significant and emit event if so.",
      "layer": "service",
      "parent": "IngestionEventService",
      "docstring": "Check if price change is significant and emit event if so.\n\nReads thresholds from application settings and emits price.changed\nevent if either threshold is met.\n\nArgs:\n    listing: Listing instance with updated price\n    old_price: Previous price in USD\n    new_price: Current price in USD\n\nReturns:\n    True if event was emitted, False otherwise\n\nExample:\n    >>> # Assuming settings.ingestion.price_change_threshold_abs = 1.0\n    >>> # and settings.ingestion.price_change_threshold_pct = 2.0\n    >>> listing = Listing(id=1, title=\"PC\", price_usd=98.00, marketplace=\"ebay\")\n    >>> emitted = event_service.check_and_emit_price_change(\n    ...     listing,\n    ...     Decimal(\"100.00\"),\n    ...     Decimal(\"98.00\")\n    ... )\n    >>> print(f\"Event emitted: {emitted}\")\n    Event emitted: True",
      "category": "business_logic"
    },
    {
      "name": "get_events",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 963,
      "signature": "get_events(self) -> list[ListingCreatedEvent | PriceChangedEvent]",
      "summary": "Get all emitted events (for testing).",
      "layer": "service",
      "parent": "IngestionEventService",
      "docstring": "Get all emitted events (for testing).\n\nReturns:\n    Copy of all emitted events\n\nExample:\n    >>> events = event_service.get_events()\n    >>> for event in events:\n    ...     if isinstance(event, ListingCreatedEvent):\n    ...         print(f\"Created: {event.title}\")\n    ...     elif isinstance(event, PriceChangedEvent):\n    ...         print(f\"Price changed: {event.title}\")",
      "category": "business_logic"
    },
    {
      "name": "clear_events",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 979,
      "signature": "clear_events(self) -> None",
      "summary": "Clear all events (for testing).",
      "layer": "service",
      "parent": "IngestionEventService",
      "docstring": "Clear all events (for testing).\n\nResets the in-memory event storage to empty list.\nUseful for test isolation and cleanup.\n\nExample:\n    >>> event_service.emit_listing_created(listing, \"ebay_api\", \"full\")\n    >>> len(event_service.get_events())\n    1\n    >>> event_service.clear_events()\n    >>> len(event_service.get_events())\n    0",
      "category": "business_logic"
    },
    {
      "name": "IngestionResult",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 997,
      "signature": "class IngestionResult",
      "summary": "Result of ingesting a single URL.",
      "layer": "service",
      "docstring": "Result of ingesting a single URL.\n\nAttributes:\n    success: Whether ingestion completed successfully\n    listing_id: Database ID of created/updated listing (None if failed)\n    status: Ingestion status (created|updated|failed)\n    provenance: Data source used (ebay_api|jsonld)\n    quality: Data quality assessment (full|partial)\n    url: Source URL that was ingested\n    dedup_result: Deduplication check result (optional)\n    error: Error message if ingestion failed (optional)\n    title: Listing title (optional)\n    price: Listing price in USD (optional)\n    vendor_item_id: Marketplace-specific item ID (optional)\n    marketplace: Marketplace identifier (ebay|amazon|other)",
      "category": "business_logic"
    },
    {
      "name": "IngestionService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 1032,
      "signature": "class IngestionService",
      "summary": "Orchestrates URL ingestion workflow.",
      "layer": "service",
      "docstring": "Orchestrates URL ingestion workflow.\n\nCoordinates the complete ingestion pipeline:\n1. Select adapter (AdapterRouter)\n2. Extract raw data (adapter.extract())\n3. Normalize and enrich (ListingNormalizer)\n4. Check for duplicates (DeduplicationService)\n5. Upsert listing (create or update)\n6. Emit events (IngestionEventService)\n7. Store raw payload (RawPayload model)\n\nExample:\n    >>> async with session_scope() as session:\n    ...     service = IngestionService(session)\n    ...     result = await service.ingest_single_url(\"https://ebay.com/itm/123\")\n    ...     if result.success:\n    ...         print(f\"Created listing {result.listing_id}\")",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 1052,
      "signature": "__init__(self, session: AsyncSession)",
      "summary": "Initialize ingestion service.",
      "layer": "service",
      "parent": "IngestionService",
      "docstring": "Initialize ingestion service.\n\nArgs:\n    session: Async SQLAlchemy session for database operations",
      "category": "business_logic"
    },
    {
      "name": "ingest_single_url",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/ingestion.py",
      "line": 1064,
      "signature": "async ingest_single_url(self, url: str) -> IngestionResult",
      "summary": "Ingest a single URL through complete workflow.",
      "layer": "service",
      "parent": "IngestionService",
      "docstring": "Ingest a single URL through complete workflow.\n\nOrchestrates the full ingestion pipeline from URL to persisted listing.\nHandles errors gracefully and returns result with detailed status.\n\nArgs:\n    url: The URL to ingest\n\nReturns:\n    IngestionResult with outcome details (success/failure, listing_id, etc.)\n\nExample:\n    >>> result = await service.ingest_single_url(\"https://ebay.com/itm/123\")\n    >>> if result.success:\n    ...     print(f\"{result.status}: listing {result.listing_id}\")\n    ... else:\n    ...     print(f\"Failed: {result.error}\")",
      "category": "business_logic"
    },
    {
      "name": "SchemaField",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 11,
      "signature": "class SchemaField",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "all_keys",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 20,
      "signature": "all_keys(self) -> tuple[str, ...]",
      "summary": "",
      "layer": "service",
      "parent": "SchemaField",
      "category": "business_logic"
    },
    {
      "name": "ImportSchema",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 25,
      "signature": "class ImportSchema",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "field_by_key",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 31,
      "signature": "field_by_key(self, key: str) -> SchemaField | None",
      "summary": "",
      "layer": "service",
      "parent": "ImportSchema",
      "category": "business_logic"
    },
    {
      "name": "required_fields",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 34,
      "signature": "required_fields(self) -> tuple[SchemaField, ...]",
      "summary": "",
      "layer": "service",
      "parent": "ImportSchema",
      "category": "business_logic"
    },
    {
      "name": "optional_fields",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 37,
      "signature": "optional_fields(self) -> tuple[SchemaField, ...]",
      "summary": "",
      "layer": "service",
      "parent": "ImportSchema",
      "category": "business_logic"
    },
    {
      "name": "score_columns",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 40,
      "signature": "score_columns(self, columns: Sequence[str]) -> float",
      "summary": "Return a confidence score that a sheet with these columns fits this schema.",
      "layer": "service",
      "parent": "ImportSchema",
      "docstring": "Return a confidence score that a sheet with these columns fits this schema.",
      "category": "business_logic"
    },
    {
      "name": "keyword_bonus",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 52,
      "signature": "keyword_bonus(self, sheet_name: str) -> float",
      "summary": "",
      "layer": "service",
      "parent": "ImportSchema",
      "category": "business_logic"
    },
    {
      "name": "normalize_column",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 63,
      "signature": "normalize_column(value: str) -> str",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "iter_schemas",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/imports/specs.py",
      "line": 145,
      "signature": "iter_schemas() -> Iterable[ImportSchema]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "normalize_text",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/imports/utils.py",
      "line": 17,
      "signature": "normalize_text(value: str | None) -> str",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "checksum_bytes",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/imports/utils.py",
      "line": 23,
      "signature": "checksum_bytes(payload: bytes) -> str",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "load_dataframe_preview",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/imports/utils.py",
      "line": 27,
      "signature": "load_dataframe_preview(dataframe: DataFrame, limit: int) -> list[dict[str, Any]]",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "ensure_directory",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/imports/utils.py",
      "line": 37,
      "signature": "ensure_directory(path: Path) -> None",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "dumps_json",
      "kind": "function",
      "path": "apps/api/dealbrain_api/services/imports/utils.py",
      "line": 41,
      "signature": "dumps_json(value: Any) -> str",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "MappingCandidate",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 40,
      "signature": "class MappingCandidate",
      "summary": "",
      "layer": "service",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 45,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "MappingCandidate",
      "category": "business_logic"
    },
    {
      "name": "ImportSessionService",
      "kind": "class",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 53,
      "signature": "class ImportSessionService",
      "summary": "Coordinates the importer workflow: upload, mapping, preview, and conflicts.",
      "layer": "service",
      "docstring": "Coordinates the importer workflow: upload, mapping, preview, and conflicts.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 56,
      "signature": "__init__(self, settings: Settings | None) -> None",
      "summary": "",
      "layer": "service",
      "parent": "ImportSessionService",
      "category": "business_logic"
    },
    {
      "name": "create_session",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 59,
      "signature": "async create_session(self, db: AsyncSession, upload: UploadFile, declared_entities: Mapping[str, str] | None, created_by: str | None) -> ImportSession",
      "summary": "",
      "layer": "service",
      "parent": "ImportSessionService",
      "category": "business_logic"
    },
    {
      "name": "refresh_preview",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 128,
      "signature": "async refresh_preview(self, db: AsyncSession, import_session: ImportSession, limit: int) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "ImportSessionService",
      "category": "business_logic"
    },
    {
      "name": "update_mappings",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 142,
      "signature": "async update_mappings(self, db: AsyncSession, import_session: ImportSession, mappings: dict[str, Any]) -> ImportSession",
      "summary": "",
      "layer": "service",
      "parent": "ImportSessionService",
      "category": "business_logic"
    },
    {
      "name": "compute_conflicts",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 155,
      "signature": "async compute_conflicts(self, db: AsyncSession, import_session: ImportSession) -> dict[str, Any]",
      "summary": "",
      "layer": "service",
      "parent": "ImportSessionService",
      "category": "business_logic"
    },
    {
      "name": "commit",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 168,
      "signature": "async commit(self, db: AsyncSession, import_session: ImportSession, conflict_resolutions: Mapping[str, str], component_overrides: Mapping[int, dict[str, Any]]) -> tuple[dict[str, int], list[str]]",
      "summary": "",
      "layer": "service",
      "parent": "ImportSessionService",
      "category": "business_logic"
    },
    {
      "name": "attach_custom_field",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/services/imports/service.py",
      "line": 998,
      "signature": "async attach_custom_field(self, db: AsyncSession, import_session: ImportSession, field: CustomFieldDefinition) -> ImportSession",
      "summary": "",
      "layer": "service",
      "parent": "ImportSessionService",
      "category": "business_logic"
    },
    {
      "name": "drop_all_tables",
      "kind": "function",
      "path": "apps/api/dealbrain_api/scripts/drop_db_objects.py",
      "line": 25,
      "signature": "drop_all_tables(engine)",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "drop_all_enums",
      "kind": "function",
      "path": "apps/api/dealbrain_api/scripts/drop_db_objects.py",
      "line": 31,
      "signature": "drop_all_enums(engine)",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": "apps/api/dealbrain_api/scripts/drop_db_objects.py",
      "line": 55,
      "signature": "main()",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "ConditionSchema",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 11,
      "signature": "class ConditionSchema(BaseModel)",
      "summary": "Schema for a rule condition",
      "layer": "schema",
      "docstring": "Schema for a rule condition",
      "category": "business_logic"
    },
    {
      "name": "ActionSchema",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 23,
      "signature": "class ActionSchema(BaseModel)",
      "summary": "Schema for a rule action",
      "layer": "schema",
      "docstring": "Schema for a rule action",
      "category": "business_logic"
    },
    {
      "name": "validate_metric_requirements",
      "kind": "method",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 36,
      "signature": "validate_metric_requirements(self) -> 'ActionSchema'",
      "summary": "Ensure metric is provided for metric-dependent action types.",
      "layer": "schema",
      "parent": "ActionSchema",
      "docstring": "Ensure metric is provided for metric-dependent action types.",
      "category": "business_logic"
    },
    {
      "name": "RuleCreateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 45,
      "signature": "class RuleCreateRequest(BaseModel)",
      "summary": "Request schema for creating a rule",
      "layer": "schema",
      "docstring": "Request schema for creating a rule",
      "category": "business_logic"
    },
    {
      "name": "RuleUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 58,
      "signature": "class RuleUpdateRequest(BaseModel)",
      "summary": "Request schema for updating a rule",
      "layer": "schema",
      "docstring": "Request schema for updating a rule",
      "category": "business_logic"
    },
    {
      "name": "RuleResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 70,
      "signature": "class RuleResponse(BaseModel)",
      "summary": "Response schema for a rule",
      "layer": "schema",
      "docstring": "Response schema for a rule",
      "category": "business_logic"
    },
    {
      "name": "Config",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 87,
      "signature": "class Config",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "RuleGroupCreateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 93,
      "signature": "class RuleGroupCreateRequest(BaseModel)",
      "summary": "Request schema for creating a rule group",
      "layer": "schema",
      "docstring": "Request schema for creating a rule group",
      "category": "business_logic"
    },
    {
      "name": "validate_basic_managed_requirements",
      "kind": "method",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 107,
      "signature": "validate_basic_managed_requirements(self) -> 'RuleGroupCreateRequest'",
      "summary": "Ensure basic_managed groups have entity_key.",
      "layer": "schema",
      "parent": "RuleGroupCreateRequest",
      "docstring": "Ensure basic_managed groups have entity_key.",
      "category": "business_logic"
    },
    {
      "name": "RuleGroupUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 114,
      "signature": "class RuleGroupUpdateRequest(BaseModel)",
      "summary": "Request schema for updating a rule group",
      "layer": "schema",
      "docstring": "Request schema for updating a rule group",
      "category": "business_logic"
    },
    {
      "name": "validate_basic_managed_requirements",
      "kind": "method",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 129,
      "signature": "validate_basic_managed_requirements(self) -> 'RuleGroupUpdateRequest'",
      "summary": "Ensure basic_managed groups have entity_key.",
      "layer": "schema",
      "parent": "RuleGroupUpdateRequest",
      "docstring": "Ensure basic_managed groups have entity_key.",
      "category": "business_logic"
    },
    {
      "name": "RuleGroupResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 136,
      "signature": "class RuleGroupResponse(BaseModel)",
      "summary": "Response schema for a rule group",
      "layer": "schema",
      "docstring": "Response schema for a rule group",
      "category": "business_logic"
    },
    {
      "name": "Config",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 153,
      "signature": "class Config",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "RulesetCreateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 159,
      "signature": "class RulesetCreateRequest(BaseModel)",
      "summary": "Request schema for creating a ruleset",
      "layer": "schema",
      "docstring": "Request schema for creating a ruleset",
      "category": "business_logic"
    },
    {
      "name": "RulesetUpdateRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 177,
      "signature": "class RulesetUpdateRequest(BaseModel)",
      "summary": "Request schema for updating a ruleset",
      "layer": "schema",
      "docstring": "Request schema for updating a ruleset",
      "category": "business_logic"
    },
    {
      "name": "RulesetResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 195,
      "signature": "class RulesetResponse(BaseModel)",
      "summary": "Response schema for a ruleset",
      "layer": "schema",
      "docstring": "Response schema for a ruleset",
      "category": "business_logic"
    },
    {
      "name": "Config",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 210,
      "signature": "class Config",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "RulePreviewRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 216,
      "signature": "class RulePreviewRequest(BaseModel)",
      "summary": "Request schema for previewing a rule",
      "layer": "schema",
      "docstring": "Request schema for previewing a rule",
      "category": "business_logic"
    },
    {
      "name": "SampleListingResult",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 224,
      "signature": "class SampleListingResult(BaseModel)",
      "summary": "Sample listing evaluation result",
      "layer": "schema",
      "docstring": "Sample listing evaluation result",
      "category": "business_logic"
    },
    {
      "name": "RulePreviewResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 234,
      "signature": "class RulePreviewResponse(BaseModel)",
      "summary": "Response schema for rule preview",
      "layer": "schema",
      "docstring": "Response schema for rule preview",
      "category": "business_logic"
    },
    {
      "name": "RuleEvaluationResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 243,
      "signature": "class RuleEvaluationResponse(BaseModel)",
      "summary": "Response schema for rule evaluation",
      "layer": "schema",
      "docstring": "Response schema for rule evaluation",
      "category": "business_logic"
    },
    {
      "name": "BulkEvaluationRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 255,
      "signature": "class BulkEvaluationRequest(BaseModel)",
      "summary": "Request schema for bulk evaluation",
      "layer": "schema",
      "docstring": "Request schema for bulk evaluation",
      "category": "business_logic"
    },
    {
      "name": "ApplyRulesetRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 261,
      "signature": "class ApplyRulesetRequest(BaseModel)",
      "summary": "Request schema for applying a ruleset",
      "layer": "schema",
      "docstring": "Request schema for applying a ruleset",
      "category": "business_logic"
    },
    {
      "name": "AuditLogResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 269,
      "signature": "class AuditLogResponse(BaseModel)",
      "summary": "Response schema for audit log entry",
      "layer": "schema",
      "docstring": "Response schema for audit log entry",
      "category": "business_logic"
    },
    {
      "name": "Config",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 279,
      "signature": "class Config",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "RuleExportRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 285,
      "signature": "class RuleExportRequest(BaseModel)",
      "summary": "Request schema for exporting rules",
      "layer": "schema",
      "docstring": "Request schema for exporting rules",
      "category": "business_logic"
    },
    {
      "name": "RuleImportRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 292,
      "signature": "class RuleImportRequest(BaseModel)",
      "summary": "Request schema for importing rules",
      "layer": "schema",
      "docstring": "Request schema for importing rules",
      "category": "business_logic"
    },
    {
      "name": "PackageMetadataRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 302,
      "signature": "class PackageMetadataRequest(BaseModel)",
      "summary": "Request schema for package metadata",
      "layer": "schema",
      "docstring": "Request schema for package metadata",
      "category": "business_logic"
    },
    {
      "name": "PackageExportResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 314,
      "signature": "class PackageExportResponse(BaseModel)",
      "summary": "Response schema for package export preview",
      "layer": "schema",
      "docstring": "Response schema for package export preview",
      "category": "business_logic"
    },
    {
      "name": "PackageInstallResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 327,
      "signature": "class PackageInstallResponse(BaseModel)",
      "summary": "Response schema for package installation",
      "layer": "schema",
      "docstring": "Response schema for package installation",
      "category": "business_logic"
    },
    {
      "name": "FormulaValidationRequest",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 340,
      "signature": "class FormulaValidationRequest(BaseModel)",
      "summary": "Request schema for validating a formula",
      "layer": "schema",
      "docstring": "Request schema for validating a formula",
      "category": "business_logic"
    },
    {
      "name": "FormulaValidationError",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 347,
      "signature": "class FormulaValidationError(BaseModel)",
      "summary": "Schema for a formula validation error",
      "layer": "schema",
      "docstring": "Schema for a formula validation error",
      "category": "business_logic"
    },
    {
      "name": "FormulaValidationResponse",
      "kind": "class",
      "path": "apps/api/dealbrain_api/schemas/rules.py",
      "line": 355,
      "signature": "class FormulaValidationResponse(BaseModel)",
      "summary": "Response schema for formula validation",
      "layer": "schema",
      "docstring": "Response schema for formula validation",
      "category": "business_logic"
    },
    {
      "name": "seed_sample_ruleset",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/seed_scripts/valuation_rules_v2.py",
      "line": 14,
      "signature": "async seed_sample_ruleset()",
      "summary": "Create a sample ruleset with example rules",
      "layer": "core",
      "docstring": "Create a sample ruleset with example rules",
      "category": "business_logic"
    },
    {
      "name": "recalculate_metrics_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/admin.py",
      "line": 26,
      "signature": "recalculate_metrics_task(listing_ids: list[int] | None) -> dict[str, int]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "recalculate_cpu_mark_metrics_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/admin.py",
      "line": 38,
      "signature": "recalculate_cpu_mark_metrics_task(listing_ids: list[int] | None) -> dict[str, int]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "import_passmark_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/admin.py",
      "line": 48,
      "signature": "import_passmark_task(file_path: str) -> dict[str, object]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "import_entities_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/admin.py",
      "line": 70,
      "signature": "import_entities_task(entity: str, file_path: str, dry_run: bool) -> dict[str, object]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "load_baseline_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/baseline.py",
      "line": 37,
      "signature": "load_baseline_task(source_path: str, actor: str | None, ensure_basic_for_ruleset: int | None) -> dict[str, object]",
      "summary": "Ingest a baseline JSON artifact into the system.",
      "layer": "core",
      "docstring": "Ingest a baseline JSON artifact into the system.",
      "category": "business_logic"
    },
    {
      "name": "ingest_url_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/ingestion.py",
      "line": 176,
      "signature": "ingest_url_task(self, job_id: str, url: str, adapter_config: dict[str, Any] | None) -> dict[str, Any]",
      "summary": "Celery task for async URL ingestion.",
      "layer": "core",
      "docstring": "Celery task for async URL ingestion.\n\nFollows the async event loop pattern from valuation.py for consistency.\nImplements retry logic with exponential backoff for transient errors.\n\nArgs:\n    job_id: ImportSession UUID as string\n    url: URL to ingest\n    adapter_config: Optional adapter configuration (reserved for future use)\n\nReturns:\n    Dict with ingestion result containing:\n    - success: bool\n    - listing_id: int | None\n    - status: str (complete|partial|failed)\n    - provenance: str\n    - quality: str\n    - error: str | None\n\nRaises:\n    Retry: For transient errors (timeout, connection errors)",
      "category": "business_logic"
    },
    {
      "name": "cleanup_expired_payloads_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/ingestion.py",
      "line": 340,
      "signature": "cleanup_expired_payloads_task() -> dict[str, Any]",
      "summary": "Celery task for cleaning up expired raw payloads.",
      "layer": "core",
      "docstring": "Celery task for cleaning up expired raw payloads.\n\nRuns as a periodic task (configured via Celery Beat) to remove\nRawPayload records older than configured TTL. Prevents unbounded\nstorage growth while preserving recent payloads for debugging.\n\nReturns:\n    Dict with cleanup statistics containing:\n    - deleted_count: Number of records deleted\n    - ttl_days: Configured TTL in days\n    - cutoff_date: ISO timestamp of cutoff date\n\nExample:\n    >>> result = cleanup_expired_payloads_task.delay()\n    >>> result.get()\n    {'deleted_count': 42, 'ttl_days': 30, 'cutoff_date': '2025-09-19T...'}",
      "category": "business_logic"
    },
    {
      "name": "recalculate_listings_task",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/valuation.py",
      "line": 120,
      "signature": "recalculate_listings_task(self, listing_ids: Iterable[int | str | None] | None, ruleset_id: int | None, batch_size: int, include_inactive: bool, reason: str | None) -> dict[str, int]",
      "summary": "Celery task entry-point for listing recalculation.",
      "layer": "core",
      "docstring": "Celery task entry-point for listing recalculation.",
      "category": "business_logic"
    },
    {
      "name": "enqueue_listing_recalculation",
      "kind": "function",
      "path": "apps/api/dealbrain_api/tasks/valuation.py",
      "line": 168,
      "signature": "enqueue_listing_recalculation(listing_ids: Iterable[int | str | None] | None, ruleset_id: int | None, reason: str | None, use_celery: bool) -> None",
      "summary": "Schedule listing valuation recalculation.",
      "layer": "core",
      "docstring": "Schedule listing valuation recalculation.\n\nFalls back to synchronous execution in environments where Celery workers\nare unavailable (e.g., unit tests).",
      "category": "business_logic"
    },
    {
      "name": "seed_component_catalog",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/seeds/component_catalog.py",
      "line": 115,
      "signature": "async seed_component_catalog(session: AsyncSession) -> None",
      "summary": "Ensure canonical RAM specs and storage profiles exist.",
      "layer": "core",
      "docstring": "Ensure canonical RAM specs and storage profiles exist.",
      "category": "business_logic"
    },
    {
      "name": "apply_seed",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/seeds/__init__.py",
      "line": 25,
      "signature": "async apply_seed(seed: SpreadsheetSeed) -> None",
      "summary": "",
      "layer": "core",
      "category": "config"
    },
    {
      "name": "seed_from_workbook",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/seeds/__init__.py",
      "line": 112,
      "signature": "async seed_from_workbook(path: Path) -> None",
      "summary": "",
      "layer": "core",
      "category": "config"
    },
    {
      "name": "run",
      "kind": "async_function",
      "path": "apps/api/dealbrain_api/seeds/__init__.py",
      "line": 126,
      "signature": "async run() -> None",
      "summary": "",
      "layer": "core",
      "category": "config"
    },
    {
      "name": "main",
      "kind": "function",
      "path": "apps/api/dealbrain_api/cli/__main__.py",
      "line": 6,
      "signature": "main() -> None",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "load_baseline",
      "kind": "function",
      "path": "apps/api/dealbrain_api/cli/baselines.py",
      "line": 18,
      "signature": "load_baseline(source: Path, actor: str, ensure_basic_ruleset_id: int, output_json: bool) -> None",
      "summary": "Populate the System Baseline ruleset from a JSON artifact.",
      "layer": "core",
      "docstring": "Populate the System Baseline ruleset from a JSON artifact.",
      "category": "business_logic"
    },
    {
      "name": "validate_basic_managed_group",
      "kind": "function",
      "path": "apps/api/dealbrain_api/validation/rules_validation.py",
      "line": 17,
      "signature": "validate_basic_managed_group(group_metadata: dict[str, Any] | None, operation: str) -> None",
      "summary": "Prevent manual edits to basic-managed groups.",
      "layer": "core",
      "docstring": "Prevent manual edits to basic-managed groups.\n\nArgs:\n    group_metadata: The metadata_json from the group\n    operation: The operation being attempted (e.g., 'update', 'delete')\n\nRaises:\n    HTTPException: 403 Forbidden if group is basic-managed",
      "category": "business_logic"
    },
    {
      "name": "validate_entity_key",
      "kind": "function",
      "path": "apps/api/dealbrain_api/validation/rules_validation.py",
      "line": 38,
      "signature": "validate_entity_key(entity_key: str | None) -> None",
      "summary": "Ensure entity key is from valid set.",
      "layer": "core",
      "docstring": "Ensure entity key is from valid set.\n\nArgs:\n    entity_key: The entity key to validate\n\nRaises:\n    HTTPException: 400 Bad Request if entity key is invalid",
      "category": "business_logic"
    },
    {
      "name": "validate_modifiers_json",
      "kind": "function",
      "path": "apps/api/dealbrain_api/validation/rules_validation.py",
      "line": 55,
      "signature": "validate_modifiers_json(modifiers: dict[str, Any] | None, action_type: str) -> None",
      "summary": "Validate modifiers match action type.",
      "layer": "core",
      "docstring": "Validate modifiers match action type.\n\nArgs:\n    modifiers: The modifiers dictionary from the action\n    action_type: The action type (e.g., 'fixed_value', 'per_unit')\n\nRaises:\n    HTTPException: 400 Bad Request if modifiers are invalid",
      "category": "business_logic"
    },
    {
      "name": "extract_metadata_fields",
      "kind": "function",
      "path": "apps/api/dealbrain_api/validation/rules_validation.py",
      "line": 108,
      "signature": "extract_metadata_fields(metadata: dict[str, Any] | None) -> tuple[bool | None, str | None]",
      "summary": "Extract basic_managed and entity_key from metadata.",
      "layer": "core",
      "docstring": "Extract basic_managed and entity_key from metadata.\n\nArgs:\n    metadata: The metadata dictionary\n\nReturns:\n    Tuple of (basic_managed, entity_key)",
      "category": "business_logic"
    },
    {
      "name": "merge_metadata_fields",
      "kind": "function",
      "path": "apps/api/dealbrain_api/validation/rules_validation.py",
      "line": 126,
      "signature": "merge_metadata_fields(existing_metadata: dict[str, Any] | None, basic_managed: bool | None, entity_key: str | None, additional_metadata: dict[str, Any] | None) -> dict[str, Any]",
      "summary": "Merge basic_managed and entity_key into metadata dictionary.",
      "layer": "core",
      "docstring": "Merge basic_managed and entity_key into metadata dictionary.\n\nArgs:\n    existing_metadata: Current metadata dictionary\n    basic_managed: Basic managed flag to set\n    entity_key: Entity key to set\n    additional_metadata: Additional metadata to merge\n\nReturns:\n    Merged metadata dictionary",
      "category": "business_logic"
    },
    {
      "name": "AdapterError",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 16,
      "signature": "class AdapterError(str, Enum)",
      "summary": "Error types for adapter operations.",
      "layer": "core",
      "docstring": "Error types for adapter operations.\n\nThese standardized error codes allow the ingestion service to handle\nfailures consistently across different adapters and implement appropriate\nretry strategies.\n\nAttributes:\n    TIMEOUT: Request exceeded configured timeout\n    INVALID_SCHEMA: Response data failed validation\n    ADAPTER_DISABLED: Adapter is disabled in settings\n    RATE_LIMITED: Rate limit exceeded, retry later\n    ITEM_NOT_FOUND: Resource not found (404 or equivalent)\n    NETWORK_ERROR: Network connectivity issue\n    PARSE_ERROR: Failed to parse response data\n    NO_STRUCTURED_DATA: No structured data (JSON-LD/Microdata) found\n    NO_ADAPTER_FOUND: No adapter matches the given URL\n    CONFIGURATION_ERROR: Adapter configuration is missing or invalid\n    ALL_ADAPTERS_FAILED: All adapters attempted and failed",
      "category": "business_logic"
    },
    {
      "name": "AdapterException",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 51,
      "signature": "class AdapterException(Exception)",
      "summary": "Base exception for adapter errors.",
      "layer": "core",
      "docstring": "Base exception for adapter errors.\n\nAttributes:\n    error_type: AdapterError enum value\n    message: Human-readable error message\n    metadata: Additional context (optional)",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 61,
      "signature": "__init__(self, error_type: AdapterError, message: str, metadata: dict[str, Any] | None)",
      "summary": "",
      "layer": "core",
      "parent": "AdapterException",
      "category": "business_logic"
    },
    {
      "name": "RateLimitConfig",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 73,
      "signature": "class RateLimitConfig",
      "summary": "Rate limiting configuration for an adapter.",
      "layer": "core",
      "docstring": "Rate limiting configuration for an adapter.\n\nAttributes:\n    requests_per_minute: Maximum requests per minute\n    current_count: Current request count in the time window\n    window_start: Start time of current rate limit window",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 83,
      "signature": "__init__(self, requests_per_minute: int)",
      "summary": "",
      "layer": "core",
      "parent": "RateLimitConfig",
      "category": "business_logic"
    },
    {
      "name": "check_and_wait",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 88,
      "signature": "async check_and_wait(self) -> None",
      "summary": "Check rate limit and wait if necessary.",
      "layer": "core",
      "parent": "RateLimitConfig",
      "docstring": "Check rate limit and wait if necessary.\n\nRaises:\n    AdapterException: If rate limit is exceeded and cannot wait",
      "category": "business_logic"
    },
    {
      "name": "RetryConfig",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 118,
      "signature": "class RetryConfig",
      "summary": "Retry configuration for adapter requests.",
      "layer": "core",
      "docstring": "Retry configuration for adapter requests.\n\nAttributes:\n    max_retries: Maximum number of retry attempts\n    backoff_factor: Exponential backoff multiplier (seconds)\n    retryable_errors: Error types that should trigger a retry",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 128,
      "signature": "__init__(self, max_retries: int, backoff_factor: float, retryable_errors: set[AdapterError] | None)",
      "summary": "",
      "layer": "core",
      "parent": "RetryConfig",
      "category": "business_logic"
    },
    {
      "name": "execute_with_retry",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 142,
      "signature": "async execute_with_retry(self, operation: Any) -> Any",
      "summary": "Execute an async operation with retry logic.",
      "layer": "core",
      "parent": "RetryConfig",
      "docstring": "Execute an async operation with retry logic.\n\nArgs:\n    operation: Async function to execute\n    *args: Positional arguments for operation\n    **kwargs: Keyword arguments for operation\n\nReturns:\n    Result from successful operation execution\n\nRaises:\n    AdapterException: If all retries are exhausted",
      "category": "business_logic"
    },
    {
      "name": "BaseAdapter",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 192,
      "signature": "class BaseAdapter(ABC)",
      "summary": "Abstract base class for all URL ingestion adapters.",
      "layer": "core",
      "docstring": "Abstract base class for all URL ingestion adapters.\n\nAll adapters (eBay API, JSON-LD, generic scraper) must inherit from this\nclass and implement the extract() method. The base class provides common\nfunctionality like rate limiting, retry logic, and timeout handling.\n\nAdapter Pattern:\n----------------\n1. Each adapter handles a specific data source (eBay API, JSON-LD, etc.)\n2. All adapters produce the same output: NormalizedListingSchema\n3. The ingestion service tries adapters in priority order\n4. First successful extraction wins\n\nHow to Implement a New Adapter:\n--------------------------------\n1. Inherit from BaseAdapter\n2. Set adapter metadata (name, supported_domains, priority)\n3. Implement async extract(url: str) -> NormalizedListingSchema\n4. Use self.retry_config.execute_with_retry() for HTTP requests\n5. Raise AdapterException with appropriate error_type on failure\n\nExample:\n--------\n```python\nclass EbayApiAdapter(BaseAdapter):\n    def __init__(self, api_key: str, timeout_s: int = 6):\n        super().__init__(\n            name=\"ebay_api\",\n            supported_domains=[\"ebay.com\", \"ebay.co.uk\"],\n            priority=1,  # Highest priority\n            timeout_s=timeout_s,\n            max_retries=2,\n        )\n        self.api_key = api_key\n\n    async def extract(self, url: str) -> NormalizedListingSchema:\n        # Extract item ID from URL\n        item_id = self._parse_item_id(url)\n\n        # Fetch from API with retry\n        data = await self.retry_config.execute_with_retry(\n            self._fetch_item, item_id\n        )\n\n        # Transform to normalized schema\n        return self._transform(data)\n```\n\nAttributes:\n    name: Adapter identifier (e.g., \"ebay_api\", \"jsonld\")\n    supported_domains: List of domains this adapter can handle\n    priority: Adapter priority (lower = higher priority)\n    timeout_s: Request timeout in seconds\n    rate_limit_config: Rate limiting configuration\n    retry_config: Retry strategy configuration",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 251,
      "signature": "__init__(self, name: str, supported_domains: list[str], priority: int, timeout_s: int, max_retries: int, requests_per_minute: int)",
      "summary": "Initialize base adapter.",
      "layer": "core",
      "parent": "BaseAdapter",
      "docstring": "Initialize base adapter.\n\nArgs:\n    name: Adapter identifier (e.g., \"ebay_api\")\n    supported_domains: List of domains (e.g., [\"ebay.com\"])\n    priority: Adapter priority (lower = higher priority)\n    timeout_s: Request timeout in seconds\n    max_retries: Maximum retry attempts\n    requests_per_minute: Rate limit threshold",
      "category": "business_logic"
    },
    {
      "name": "extract",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 279,
      "signature": "async extract(self, url: str) -> NormalizedListingSchema",
      "summary": "Extract listing data from URL and return normalized schema.",
      "layer": "core",
      "parent": "BaseAdapter",
      "docstring": "Extract listing data from URL and return normalized schema.\n\nThis is the main method that each adapter must implement. It should:\n1. Parse the URL to extract necessary identifiers\n2. Fetch data from the source (API, webpage, etc.)\n3. Transform the raw data into NormalizedListingSchema\n4. Validate the schema before returning\n\nArgs:\n    url: URL to extract listing data from\n\nReturns:\n    NormalizedListingSchema with normalized listing data\n\nRaises:\n    AdapterException: If extraction fails for any reason",
      "category": "business_logic"
    },
    {
      "name": "supports_url",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/base.py",
      "line": 300,
      "signature": "supports_url(self, url: str) -> bool",
      "summary": "Check if this adapter supports the given URL.",
      "layer": "core",
      "parent": "BaseAdapter",
      "docstring": "Check if this adapter supports the given URL.\n\nArgs:\n    url: URL to check\n\nReturns:\n    True if URL domain matches supported_domains",
      "category": "business_logic"
    },
    {
      "name": "EbayAdapter",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/ebay.py",
      "line": 19,
      "signature": "class EbayAdapter(BaseAdapter)",
      "summary": "eBay Browse API adapter for extracting listing data.",
      "layer": "core",
      "docstring": "eBay Browse API adapter for extracting listing data.\n\nThis adapter uses the eBay Browse API v1 to fetch item details from eBay URLs.\nIt parses item IDs from various eBay URL formats, calls the Browse API with\nOAuth authentication, and maps the response to NormalizedListingSchema.\n\nURL Formats Supported:\n----------------------\n- https://www.ebay.com/itm/123456789012\n- https://www.ebay.com/itm/Product-Name/123456789012\n- https://ebay.com/itm/123456789012?hash=...\n- https://www.ebay.com/itm/123456789012?_trkparms=...\n\neBay API Integration:\n--------------------\n- Endpoint: GET /buy/browse/v1/item/{item_id}\n- Authentication: OAuth 2.0 Application token (from settings)\n- Headers: Authorization: Bearer {access_token}\n          X-EBAY-C-MARKETPLACE-ID: EBAY_US\n\nData Mapping:\n------------\nMaps eBay Browse API response fields to NormalizedListingSchema:\n- title: item.title\n- price: item.price.value (converted to Decimal)\n- currency: item.price.currency\n- condition: Normalized from item.condition\n- images: [item.image.imageUrl] (primary image only)\n- seller: item.seller.username\n- marketplace: \"ebay\"\n- vendor_item_id: item.itemId\n- description: item.description\n\nItem specifics (CPU, RAM, storage) are extracted from item.localizedAspects\nor item.itemSpecifics array.\n\nError Handling:\n--------------\n- ITEM_NOT_FOUND (404): Item does not exist or has been removed\n- INVALID_CREDENTIALS (401): Invalid or expired OAuth token\n- RATE_LIMITED (429): API rate limit exceeded\n- TIMEOUT: Request timeout (retries with exponential backoff)\n- PARSE_ERROR: Failed to parse item ID from URL\n\nRetry Logic:\n-----------\n- Exponential backoff: 1s, 2s, 4s\n- Max retries: Configured from settings (default 2)\n- Retry on: 429, 500, 503, timeout\n- Don't retry: 400, 401, 404",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/ebay.py",
      "line": 78,
      "signature": "__init__(self) -> None",
      "summary": "Initialize eBay adapter.",
      "layer": "core",
      "parent": "EbayAdapter",
      "docstring": "Initialize eBay adapter.\n\nLoads configuration from settings including API key, timeout, and retries.\nAPI key validation is deferred to extract() method to allow adapter\ninitialization to succeed even without API key (enables fallback chain).",
      "category": "business_logic"
    },
    {
      "name": "extract",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/adapters/ebay.py",
      "line": 108,
      "signature": "async extract(self, url: str) -> NormalizedListingSchema",
      "summary": "Extract listing data from eBay URL.",
      "layer": "core",
      "parent": "EbayAdapter",
      "docstring": "Extract listing data from eBay URL.\n\nThis is the main entry point that orchestrates the extraction workflow:\n1. Validate API key is configured\n2. Parse item ID from URL\n3. Fetch item data from eBay Browse API (with retry)\n4. Map API response to NormalizedListingSchema\n\nArgs:\n    url: eBay item URL to extract data from\n\nReturns:\n    NormalizedListingSchema with normalized listing data\n\nRaises:\n    AdapterException: If extraction fails at any step",
      "category": "business_logic"
    },
    {
      "name": "JsonLdAdapter",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/jsonld.py",
      "line": 38,
      "signature": "class JsonLdAdapter(BaseAdapter)",
      "summary": "Generic JSON-LD/Microdata adapter using Schema.org Product extraction.",
      "layer": "core",
      "docstring": "Generic JSON-LD/Microdata adapter using Schema.org Product extraction.\n\nThis adapter serves as a universal fallback for any retailer website that\nimplements structured data using JSON-LD, Microdata, or RDFa. It uses the\nextruct library to extract Schema.org Product data and maps it to\nNormalizedListingSchema.\n\nStructured Data Support:\n-----------------------\nExtraction priority order:\n1. JSON-LD (most common, easiest to parse)\n2. Microdata (embedded in HTML with itemscope/itemtype)\n3. RDFa (least common, most complex)\n\nSchema.org Product Mapping:\n---------------------------\nThis adapter looks for Schema.org Product type and extracts:\n- name -> title\n- offers.price / offers[0].price -> price\n- offers.priceCurrency -> currency\n- offers.availability -> condition (InStock = new, Refurbished = refurb)\n- image / images[0] -> images\n- offers.seller.name or brand.name -> seller\n- description -> description (parsed for CPU/RAM/storage)\n\nSpec Extraction:\n---------------\nSince most retailers don't include CPU/RAM/storage in structured data,\nthis adapter uses regex patterns to extract them from the description:\n- CPU: \"Intel Core i7-12700K\", \"AMD Ryzen 7 5800X\"\n- RAM: \"16GB RAM\", \"32 GB DDR4\"\n- Storage: \"512GB SSD\", \"1TB NVMe\", \"2 TB\"\n\nPrice Parsing:\n-------------\nHandles various price formats:\n- String: \"599.99\", \"$599.99\", \"USD 599.99\"\n- Number: 599.99\n- With separators: \"1,599.99\"\n\nNested Offers:\n-------------\nSome sites have multiple offers (different sellers, conditions):\n- Takes the lowest price by default\n- Extracts seller from first offer\n\nError Handling:\n--------------\n- NO_STRUCTURED_DATA: No Product schema found in page\n- INVALID_SCHEMA: Product schema missing required fields (name, price)\n- PARSE_ERROR: Unable to parse price or specs\n- NETWORK_ERROR: HTTP fetch failed\n- TIMEOUT: Request timeout\n\nPriority:\n--------\nPriority 5 (lower than domain-specific adapters like eBay)\nSupports all domains via wildcard [\"*\"]",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/jsonld.py",
      "line": 105,
      "signature": "__init__(self) -> None",
      "summary": "Initialize JSON-LD adapter.",
      "layer": "core",
      "parent": "JsonLdAdapter",
      "docstring": "Initialize JSON-LD adapter.\n\nLoads configuration from settings including timeout and retries.\nUses wildcard domain matching to support any URL.",
      "category": "business_logic"
    },
    {
      "name": "extract",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/adapters/jsonld.py",
      "line": 129,
      "signature": "async extract(self, url: str) -> NormalizedListingSchema",
      "summary": "Extract listing data from any URL using JSON-LD/Microdata.",
      "layer": "core",
      "parent": "JsonLdAdapter",
      "docstring": "Extract listing data from any URL using JSON-LD/Microdata.\n\nWorkflow:\n1. Fetch HTML from URL\n2. Extract structured data using extruct\n3. Find Product schema (JSON-LD \u2192 Microdata \u2192 RDFa)\n4. Map to NormalizedListingSchema\n5. Parse specs from description\n\nArgs:\n    url: URL to extract listing data from\n\nReturns:\n    NormalizedListingSchema with normalized listing data\n\nRaises:\n    AdapterException: If extraction fails at any step",
      "category": "business_logic"
    },
    {
      "name": "supports_url",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/jsonld.py",
      "line": 173,
      "signature": "supports_url(self, url: str) -> bool",
      "summary": "Check if this adapter supports the given URL.",
      "layer": "core",
      "parent": "JsonLdAdapter",
      "docstring": "Check if this adapter supports the given URL.\n\nSince this is a wildcard adapter, it supports all URLs.\nHowever, it should be used as a fallback after domain-specific\nadapters have been tried.\n\nArgs:\n    url: URL to check\n\nReturns:\n    Always True (supports all domains)",
      "category": "business_logic"
    },
    {
      "name": "AdapterRouter",
      "kind": "class",
      "path": "apps/api/dealbrain_api/adapters/router.py",
      "line": 23,
      "signature": "class AdapterRouter",
      "summary": "Routes URLs to appropriate adapter based on domain and priority.",
      "layer": "router",
      "docstring": "Routes URLs to appropriate adapter based on domain and priority.\n\nThis router serves as the entry point for the ingestion system. It:\n1. Auto-discovers available adapters from AVAILABLE_ADAPTERS registry\n2. Matches URLs to adapters based on domain patterns\n3. Selects highest priority adapter when multiple match\n4. Validates adapter is enabled in settings before use\n\nSelection Algorithm:\n-------------------\n1. Parse domain from URL (e.g., \"ebay.com\" from \"https://www.ebay.com/itm/123\")\n2. Find all adapters whose supported_domains match the URL domain\n3. Sort matches by priority (lower number = higher priority)\n4. Select first match (highest priority)\n5. Check if adapter is enabled in settings\n6. Return initialized adapter instance\n\nDomain Matching Rules:\n---------------------\n- Wildcard \"*\" matches all domains (used by JsonLdAdapter)\n- Exact match: \"ebay.com\" matches \"ebay.com\", \"www.ebay.com\", \"m.ebay.com\"\n- TLD preserved: \"ebay.com\" does NOT match \"ebay.co.uk\"\n- Subdomain normalization: \"www.\" and \"m.\" prefixes stripped for matching\n\nPriority System:\n---------------\n- Lower number = higher priority\n- EbayAdapter: priority 1 (highest)\n- JsonLdAdapter: priority 5 (fallback)\n- If two adapters have same priority, first in registry wins\n\nExample Usage:\n-------------\n```python\nrouter = AdapterRouter()\n\n# Select adapter for eBay URL\nadapter = router.select_adapter(\"https://www.ebay.com/itm/123456789012\")\n# Returns EbayAdapter instance (priority 1)\n\n# Select adapter for generic URL\nadapter = router.select_adapter(\"https://www.bestbuy.com/product/123\")\n# Returns JsonLdAdapter instance (wildcard, priority 5)\n\n# Convenience method: select and extract in one call\nlisting = await router.extract(\"https://www.ebay.com/itm/123456789012\")\n```\n\nError Handling:\n--------------\n- NO_ADAPTER_FOUND: No adapter matches URL (rare with wildcard JsonLdAdapter)\n- ADAPTER_DISABLED: Matched adapter is disabled in settings\n- PARSE_ERROR: Invalid URL format",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/router.py",
      "line": 80,
      "signature": "__init__(self) -> None",
      "summary": "Initialize adapter router.",
      "layer": "router",
      "parent": "AdapterRouter",
      "docstring": "Initialize adapter router.\n\nLoads available adapters from registry and prepares for routing.",
      "category": "business_logic"
    },
    {
      "name": "select_adapter",
      "kind": "method",
      "path": "apps/api/dealbrain_api/adapters/router.py",
      "line": 89,
      "signature": "select_adapter(self, url: str) -> BaseAdapter",
      "summary": "Select the best adapter for the given URL.",
      "layer": "router",
      "parent": "AdapterRouter",
      "docstring": "Select the best adapter for the given URL.\n\nThis is the main routing method that implements the selection algorithm:\n1. Extract domain from URL\n2. Find all matching adapters\n3. Sort by priority\n4. Validate enabled status\n5. Return initialized adapter\n\nArgs:\n    url: The URL to extract data from\n\nReturns:\n    Initialized adapter instance ready to call extract()\n\nRaises:\n    AdapterException: If no adapter found, adapter disabled, or invalid URL",
      "category": "business_logic"
    },
    {
      "name": "extract",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/adapters/router.py",
      "line": 157,
      "signature": "async extract(self, url: str) -> tuple[NormalizedListingSchema, str]",
      "summary": "Extract data using fallback chain.",
      "layer": "router",
      "parent": "AdapterRouter",
      "docstring": "Extract data using fallback chain.\n\nTries adapters in priority order until one succeeds. This implements\nthe adapter fallback mechanism:\n1. Get list of matching adapters sorted by priority\n2. Try each adapter in order\n3. Log each attempt\n4. Catch AdapterException and ValueError (init failures)\n5. Continue to next adapter if one fails\n6. Raise ALL_ADAPTERS_FAILED if all fail\n\nFast-fail conditions:\n- ITEM_NOT_FOUND: Don't retry if item doesn't exist\n- ADAPTER_DISABLED: Don't retry if adapter is disabled\n\nArgs:\n    url: The URL to extract data from\n\nReturns:\n    Tuple of (normalized listing data, adapter name used)\n\nRaises:\n    AdapterException: If all adapters fail or item not found",
      "category": "business_logic"
    },
    {
      "name": "new_request_id",
      "kind": "function",
      "path": "apps/api/dealbrain_api/telemetry/context.py",
      "line": 15,
      "signature": "new_request_id() -> str",
      "summary": "Generate a correlation id for requests/tasks.",
      "layer": "core",
      "docstring": "Generate a correlation id for requests/tasks.",
      "category": "business_logic"
    },
    {
      "name": "bind_request_context",
      "kind": "function",
      "path": "apps/api/dealbrain_api/telemetry/context.py",
      "line": 20,
      "signature": "bind_request_context(request_id: str) -> None",
      "summary": "Bind request-id and optional fields into the structlog context.",
      "layer": "core",
      "docstring": "Bind request-id and optional fields into the structlog context.",
      "category": "business_logic"
    },
    {
      "name": "bind_user_context",
      "kind": "function",
      "path": "apps/api/dealbrain_api/telemetry/context.py",
      "line": 26,
      "signature": "bind_user_context(user_id: str | None) -> None",
      "summary": "Augment the context with a user identifier when available.",
      "layer": "core",
      "docstring": "Augment the context with a user identifier when available.",
      "category": "business_logic"
    },
    {
      "name": "clear_context",
      "kind": "function",
      "path": "apps/api/dealbrain_api/telemetry/context.py",
      "line": 35,
      "signature": "clear_context() -> None",
      "summary": "Clear context variables, optionally scoping to specific keys.",
      "layer": "core",
      "docstring": "Clear context variables, optionally scoping to specific keys.",
      "category": "business_logic"
    },
    {
      "name": "current_context",
      "kind": "function",
      "path": "apps/api/dealbrain_api/telemetry/context.py",
      "line": 45,
      "signature": "current_context() -> Mapping[str, Any]",
      "summary": "Return the current context dictionary.",
      "layer": "core",
      "docstring": "Return the current context dictionary.",
      "category": "business_logic"
    },
    {
      "name": "init_telemetry",
      "kind": "function",
      "path": "apps/api/dealbrain_api/telemetry/core.py",
      "line": 146,
      "signature": "init_telemetry(settings: Settings) -> None",
      "summary": "Initialise logging and tracing according to settings.",
      "layer": "core",
      "docstring": "Initialise logging and tracing according to settings.",
      "category": "business_logic"
    },
    {
      "name": "get_logger",
      "kind": "function",
      "path": "apps/api/dealbrain_api/telemetry/core.py",
      "line": 189,
      "signature": "get_logger(name: str | None) -> structlog.stdlib.BoundLogger",
      "summary": "Convenience helper mirroring logging.getLogger.",
      "layer": "core",
      "docstring": "Convenience helper mirroring logging.getLogger.",
      "category": "business_logic"
    },
    {
      "name": "ObservabilityMiddleware",
      "kind": "class",
      "path": "apps/api/dealbrain_api/telemetry/middleware.py",
      "line": 16,
      "signature": "class ObservabilityMiddleware",
      "summary": "ASGI middleware that enriches requests with telemetry context and logging.",
      "layer": "middleware",
      "docstring": "ASGI middleware that enriches requests with telemetry context and logging.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "apps/api/dealbrain_api/telemetry/middleware.py",
      "line": 19,
      "signature": "__init__(self, app: ASGIApp, record_headers: bool) -> None",
      "summary": "",
      "layer": "middleware",
      "parent": "ObservabilityMiddleware",
      "category": "business_logic"
    },
    {
      "name": "__call__",
      "kind": "async_method",
      "path": "apps/api/dealbrain_api/telemetry/middleware.py",
      "line": 23,
      "signature": "async __call__(self, scope: Scope, receive: Receive, send: Send) -> None",
      "summary": "",
      "layer": "middleware",
      "parent": "ObservabilityMiddleware",
      "category": "business_logic"
    },
    {
      "name": "version",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 38,
      "signature": "version() -> None",
      "summary": "Print the installed Deal Brain version.",
      "layer": "core",
      "docstring": "Print the installed Deal Brain version.",
      "category": "business_logic"
    },
    {
      "name": "import_workbook",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 46,
      "signature": "import_workbook(path: Path) -> None",
      "summary": "Import an Excel workbook into the database.",
      "layer": "core",
      "docstring": "Import an Excel workbook into the database.",
      "category": "business_logic"
    },
    {
      "name": "add",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 59,
      "signature": "add(title: str, price: float, condition: str, cpu_id: Optional[int], ram_gb: int, storage_gb: int, storage_type: Optional[str]) -> None",
      "summary": "Add a new listing and compute valuation metrics.",
      "layer": "core",
      "docstring": "Add a new listing and compute valuation metrics.",
      "category": "business_logic"
    },
    {
      "name": "top",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 104,
      "signature": "top(metric: str, limit: int) -> None",
      "summary": "Show top listings by metric.",
      "layer": "core",
      "docstring": "Show top listings by metric.",
      "category": "business_logic"
    },
    {
      "name": "explain",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 130,
      "signature": "explain(listing_id: int) -> None",
      "summary": "Print the valuation breakdown for a listing.",
      "layer": "core",
      "docstring": "Print the valuation breakdown for a listing.",
      "category": "business_logic"
    },
    {
      "name": "export",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 147,
      "signature": "export(metric: str, limit: int, output: Optional[Path]) -> None",
      "summary": "Export top listings to JSON.",
      "layer": "core",
      "docstring": "Export top listings to JSON.",
      "category": "business_logic"
    },
    {
      "name": "cleanup_field_options",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 184,
      "signature": "cleanup_field_options(entity: Optional[str], dry_run: bool) -> None",
      "summary": "Archive orphaned field attribute values for deleted dropdown options.",
      "layer": "core",
      "docstring": "Archive orphaned field attribute values for deleted dropdown options.",
      "category": "business_logic"
    },
    {
      "name": "listing_to_dict",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/main.py",
      "line": 233,
      "signature": "listing_to_dict(listing: Listing) -> dict[str, object]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "list_rules",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 38,
      "signature": "list_rules(category: Optional[str], ruleset: Optional[str], active_only: bool) -> None",
      "summary": "List all valuation rules",
      "layer": "core",
      "docstring": "List all valuation rules",
      "category": "business_logic"
    },
    {
      "name": "show_rule",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 111,
      "signature": "show_rule(rule_id: int) -> None",
      "summary": "Show detailed information about a rule",
      "layer": "core",
      "docstring": "Show detailed information about a rule",
      "category": "business_logic"
    },
    {
      "name": "create_rule",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 157,
      "signature": "create_rule(file: Path) -> None",
      "summary": "Create a new rule from a YAML file",
      "layer": "core",
      "docstring": "Create a new rule from a YAML file",
      "category": "business_logic"
    },
    {
      "name": "update_rule",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 193,
      "signature": "update_rule(rule_id: int, file: Path) -> None",
      "summary": "Update a rule from a YAML file",
      "layer": "core",
      "docstring": "Update a rule from a YAML file",
      "category": "business_logic"
    },
    {
      "name": "import_rules",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 222,
      "signature": "import_rules(file: Path, format: str, mapping: Optional[Path]) -> None",
      "summary": "Import rules from a file",
      "layer": "core",
      "docstring": "Import rules from a file",
      "category": "business_logic"
    },
    {
      "name": "export_rules",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 256,
      "signature": "export_rules(format: str, output: Path, ruleset_id: Optional[int]) -> None",
      "summary": "Export rules to a file",
      "layer": "core",
      "docstring": "Export rules to a file",
      "category": "business_logic"
    },
    {
      "name": "preview_rule",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 338,
      "signature": "preview_rule(rule_id: int, sample_size: int) -> None",
      "summary": "Preview the impact of a rule",
      "layer": "core",
      "docstring": "Preview the impact of a rule",
      "category": "business_logic"
    },
    {
      "name": "apply_ruleset",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 407,
      "signature": "apply_ruleset(ruleset_name: str, category: Optional[str], dry_run: bool) -> None",
      "summary": "Apply a ruleset to listings",
      "layer": "core",
      "docstring": "Apply a ruleset to listings",
      "category": "business_logic"
    },
    {
      "name": "package_ruleset",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 441,
      "signature": "package_ruleset(ruleset_name: str, output: Path, version: str, author: str, description: Optional[str]) -> None",
      "summary": "Package a ruleset for distribution",
      "layer": "core",
      "docstring": "Package a ruleset for distribution",
      "category": "business_logic"
    },
    {
      "name": "install_package",
      "kind": "function",
      "path": "apps/cli/dealbrain_cli/commands/rules.py",
      "line": 500,
      "signature": "install_package(file: Path, merge_strategy: str) -> None",
      "summary": "Install a ruleset package from a .dbrs file",
      "layer": "core",
      "docstring": "Install a ruleset package from a .dbrs file",
      "category": "business_logic"
    },
    {
      "name": "compute_gpu_score",
      "kind": "function",
      "path": "packages/core/dealbrain_core/gpu.py",
      "line": 8,
      "signature": "compute_gpu_score(gpu_mark: Optional[float], metal_score: Optional[float], is_apple: bool) -> Optional[float]",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleData",
      "kind": "class",
      "path": "packages/core/dealbrain_core/valuation.py",
      "line": 12,
      "signature": "class ValuationRuleData",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "multiplier_for",
      "kind": "method",
      "path": "packages/core/dealbrain_core/valuation.py",
      "line": 20,
      "signature": "multiplier_for(self, condition: Condition) -> float",
      "summary": "",
      "layer": "core",
      "parent": "ValuationRuleData",
      "category": "business_logic"
    },
    {
      "name": "ComponentValuationInput",
      "kind": "class",
      "path": "packages/core/dealbrain_core/valuation.py",
      "line": 31,
      "signature": "class ComponentValuationInput",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ValuationLine",
      "kind": "class",
      "path": "packages/core/dealbrain_core/valuation.py",
      "line": 38,
      "signature": "class ValuationLine",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ValuationResult",
      "kind": "class",
      "path": "packages/core/dealbrain_core/valuation.py",
      "line": 48,
      "signature": "class ValuationResult",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "total_deductions",
      "kind": "method",
      "path": "packages/core/dealbrain_core/valuation.py",
      "line": 54,
      "signature": "total_deductions(self) -> float",
      "summary": "",
      "layer": "core",
      "parent": "ValuationResult",
      "category": "business_logic"
    },
    {
      "name": "compute_adjusted_price",
      "kind": "function",
      "path": "packages/core/dealbrain_core/valuation.py",
      "line": 58,
      "signature": "compute_adjusted_price(listing_price_usd: float, condition: Condition, rules: Iterable[ValuationRuleData], components: Iterable[ComponentValuationInput]) -> ValuationResult",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ListingMetrics",
      "kind": "class",
      "path": "packages/core/dealbrain_core/scoring.py",
      "line": 10,
      "signature": "class ListingMetrics",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "compute_composite_score",
      "kind": "function",
      "path": "packages/core/dealbrain_core/scoring.py",
      "line": 21,
      "signature": "compute_composite_score(weights: Mapping[str, float], metrics: ListingMetrics) -> float",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "dollar_per_metric",
      "kind": "function",
      "path": "packages/core/dealbrain_core/scoring.py",
      "line": 36,
      "signature": "dollar_per_metric(price_usd: float, metric: float | None) -> float | None",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "apply_rule_group_weights",
      "kind": "function",
      "path": "packages/core/dealbrain_core/scoring.py",
      "line": 42,
      "signature": "apply_rule_group_weights(rule_group_adjustments: dict[str, float], rule_group_weights: dict[str, float]) -> float",
      "summary": "Apply weighted rule group adjustments to compute total valuation adjustment.",
      "layer": "core",
      "docstring": "Apply weighted rule group adjustments to compute total valuation adjustment.\n\nArgs:\n    rule_group_adjustments: Dict mapping rule group names to their adjustment amounts\n    rule_group_weights: Dict mapping rule group names to their weights (should sum to 1.0)\n\nReturns:\n    Total weighted adjustment amount\n\nExample:\n    >>> adjustments = {\"cpu_valuation\": 50.0, \"ram_valuation\": 20.0, \"gpu_valuation\": 100.0}\n    >>> weights = {\"cpu_valuation\": 0.3, \"ram_valuation\": 0.2, \"gpu_valuation\": 0.5}\n    >>> apply_rule_group_weights(adjustments, weights)\n    75.0  # (50*0.3 + 20*0.2 + 100*0.5)",
      "category": "business_logic"
    },
    {
      "name": "validate_rule_group_weights",
      "kind": "function",
      "path": "packages/core/dealbrain_core/scoring.py",
      "line": 74,
      "signature": "validate_rule_group_weights(weights: dict[str, float]) -> tuple[bool, str | None]",
      "summary": "Validate that rule group weights are valid.",
      "layer": "core",
      "docstring": "Validate that rule group weights are valid.\n\nArgs:\n    weights: Dict mapping rule group names to weights\n\nReturns:\n    Tuple of (is_valid, error_message)",
      "category": "business_logic"
    },
    {
      "name": "ConditionNode",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rule_evaluator.py",
      "line": 8,
      "signature": "class ConditionNode",
      "summary": "Tree node representing a condition or condition group.",
      "layer": "core",
      "docstring": "Tree node representing a condition or condition group.",
      "category": "business_logic"
    },
    {
      "name": "is_group",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rule_evaluator.py",
      "line": 16,
      "signature": "is_group(self) -> bool",
      "summary": "",
      "layer": "core",
      "parent": "ConditionNode",
      "category": "business_logic"
    },
    {
      "name": "evaluate",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rule_evaluator.py",
      "line": 19,
      "signature": "evaluate(self, context: dict[str, Any]) -> bool",
      "summary": "Recursively evaluate this condition/group against context.",
      "layer": "core",
      "parent": "ConditionNode",
      "docstring": "Recursively evaluate this condition/group against context.",
      "category": "business_logic"
    },
    {
      "name": "parse_conditions_tree",
      "kind": "function",
      "path": "packages/core/dealbrain_core/rule_evaluator.py",
      "line": 91,
      "signature": "parse_conditions_tree(conditions: list[dict]) -> list[ConditionNode]",
      "summary": "Parse flat condition list into tree structure.",
      "layer": "core",
      "docstring": "Parse flat condition list into tree structure.",
      "category": "business_logic"
    },
    {
      "name": "evaluate_conditions",
      "kind": "function",
      "path": "packages/core/dealbrain_core/rule_evaluator.py",
      "line": 111,
      "signature": "evaluate_conditions(conditions: list[dict], context: dict[str, Any]) -> tuple[bool, list[dict]]",
      "summary": "Evaluate a list of conditions against a context.",
      "layer": "core",
      "docstring": "Evaluate a list of conditions against a context.\n\nReturns:\n    Tuple of (matched: bool, condition_results: list[dict])",
      "category": "business_logic"
    },
    {
      "name": "Condition",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 8,
      "signature": "class Condition(str, Enum)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "RamGeneration",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 14,
      "signature": "class RamGeneration(str, Enum)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ComponentType",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 27,
      "signature": "class ComponentType(str, Enum)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ComponentMetric",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 37,
      "signature": "class ComponentMetric(str, Enum)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "ListingStatus",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 47,
      "signature": "class ListingStatus(str, Enum)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "PortType",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 53,
      "signature": "class PortType(str, Enum)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "StorageMedium",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 71,
      "signature": "class StorageMedium(str, Enum)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "Marketplace",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 81,
      "signature": "class Marketplace(str, Enum)",
      "summary": "Source marketplace for URL-ingested listings.",
      "layer": "core",
      "docstring": "Source marketplace for URL-ingested listings.",
      "category": "business_logic"
    },
    {
      "name": "SourceType",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 88,
      "signature": "class SourceType(str, Enum)",
      "summary": "Type of import source for ImportSession.",
      "layer": "core",
      "docstring": "Type of import source for ImportSession.",
      "category": "business_logic"
    },
    {
      "name": "SourceDataType",
      "kind": "class",
      "path": "packages/core/dealbrain_core/enums.py",
      "line": 95,
      "signature": "class SourceDataType(str, Enum)",
      "summary": "Type of raw payload data stored.",
      "layer": "core",
      "docstring": "Type of raw payload data stored.",
      "category": "business_logic"
    },
    {
      "name": "DealBrainModel",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/base.py",
      "line": 8,
      "signature": "class DealBrainModel(BaseModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "SpreadsheetSeed",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/imports.py",
      "line": 22,
      "signature": "class SpreadsheetSeed(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldDefinitionBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/custom_field.py",
      "line": 11,
      "signature": "class CustomFieldDefinitionBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldDefinitionCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/custom_field.py",
      "line": 28,
      "signature": "class CustomFieldDefinitionCreate(CustomFieldDefinitionBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldDefinitionUpdate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/custom_field.py",
      "line": 32,
      "signature": "class CustomFieldDefinitionUpdate(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldDefinitionRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/custom_field.py",
      "line": 47,
      "signature": "class CustomFieldDefinitionRead(CustomFieldDefinitionBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CpuBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 14,
      "signature": "class CpuBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CpuCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 33,
      "signature": "class CpuCreate(CpuBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "CpuRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 37,
      "signature": "class CpuRead(CpuBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "GpuBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 43,
      "signature": "class GpuBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "GpuCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 52,
      "signature": "class GpuCreate(GpuBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "GpuRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 56,
      "signature": "class GpuRead(GpuBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 62,
      "signature": "class ValuationRuleBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 75,
      "signature": "class ValuationRuleCreate(ValuationRuleBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ValuationRuleRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 79,
      "signature": "class ValuationRuleRead(ValuationRuleBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ProfileBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 85,
      "signature": "class ProfileBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ProfileCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 92,
      "signature": "class ProfileCreate(ProfileBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ProfileRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 96,
      "signature": "class ProfileRead(ProfileBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "PortsProfileBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 102,
      "signature": "class PortsProfileBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "PortsProfileCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 108,
      "signature": "class PortsProfileCreate(PortsProfileBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "PortsProfileRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 112,
      "signature": "class PortsProfileRead(PortsProfileBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "RamSpecBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 119,
      "signature": "class RamSpecBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "RamSpecCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 130,
      "signature": "class RamSpecCreate(RamSpecBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "RamSpecRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 134,
      "signature": "class RamSpecRead(RamSpecBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "StorageProfileBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 140,
      "signature": "class StorageProfileBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "StorageProfileCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 151,
      "signature": "class StorageProfileCreate(StorageProfileBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "StorageProfileRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 155,
      "signature": "class StorageProfileRead(StorageProfileBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "PortBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 161,
      "signature": "class PortBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "PortCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 167,
      "signature": "class PortCreate(PortBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "PortRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/catalog.py",
      "line": 171,
      "signature": "class PortRead(PortBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "BaselineFieldMetadata",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 11,
      "signature": "class BaselineFieldMetadata(BaseModel)",
      "summary": "Metadata for a single baseline field",
      "layer": "schema",
      "docstring": "Metadata for a single baseline field",
      "category": "business_logic"
    },
    {
      "name": "BaselineEntityMetadata",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 31,
      "signature": "class BaselineEntityMetadata(BaseModel)",
      "summary": "Metadata for a baseline entity",
      "layer": "schema",
      "docstring": "Metadata for a baseline entity",
      "category": "business_logic"
    },
    {
      "name": "BaselineMetadataResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 40,
      "signature": "class BaselineMetadataResponse(DealBrainModel)",
      "summary": "Response schema for baseline metadata endpoint",
      "layer": "schema",
      "docstring": "Response schema for baseline metadata endpoint",
      "category": "business_logic"
    },
    {
      "name": "BaselineInstantiateRequest",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 55,
      "signature": "class BaselineInstantiateRequest(BaseModel)",
      "summary": "Request schema for baseline instantiation",
      "layer": "schema",
      "docstring": "Request schema for baseline instantiation",
      "category": "business_logic"
    },
    {
      "name": "BaselineInstantiateResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 66,
      "signature": "class BaselineInstantiateResponse(DealBrainModel)",
      "summary": "Response schema for baseline instantiation",
      "layer": "schema",
      "docstring": "Response schema for baseline instantiation",
      "category": "business_logic"
    },
    {
      "name": "BaselineFieldDiff",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 82,
      "signature": "class BaselineFieldDiff(BaseModel)",
      "summary": "Diff for a single field",
      "layer": "schema",
      "docstring": "Diff for a single field",
      "category": "business_logic"
    },
    {
      "name": "BaselineDiffSummary",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 94,
      "signature": "class BaselineDiffSummary(BaseModel)",
      "summary": "Summary statistics for diff operation",
      "layer": "schema",
      "docstring": "Summary statistics for diff operation",
      "category": "business_logic"
    },
    {
      "name": "BaselineDiffRequest",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 103,
      "signature": "class BaselineDiffRequest(BaseModel)",
      "summary": "Request schema for baseline diff",
      "layer": "schema",
      "docstring": "Request schema for baseline diff",
      "category": "business_logic"
    },
    {
      "name": "BaselineDiffResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 110,
      "signature": "class BaselineDiffResponse(DealBrainModel)",
      "summary": "Response schema for baseline diff",
      "layer": "schema",
      "docstring": "Response schema for baseline diff",
      "category": "business_logic"
    },
    {
      "name": "BaselineAdoptRequest",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 123,
      "signature": "class BaselineAdoptRequest(BaseModel)",
      "summary": "Request schema for baseline adoption",
      "layer": "schema",
      "docstring": "Request schema for baseline adoption",
      "category": "business_logic"
    },
    {
      "name": "BaselineAdoptResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 138,
      "signature": "class BaselineAdoptResponse(DealBrainModel)",
      "summary": "Response schema for baseline adoption",
      "layer": "schema",
      "docstring": "Response schema for baseline adoption",
      "category": "business_logic"
    },
    {
      "name": "HydrateBaselineRequest",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 153,
      "signature": "class HydrateBaselineRequest(BaseModel)",
      "summary": "Request schema for baseline rule hydration",
      "layer": "schema",
      "docstring": "Request schema for baseline rule hydration",
      "category": "business_logic"
    },
    {
      "name": "HydrationSummaryItem",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 159,
      "signature": "class HydrationSummaryItem(BaseModel)",
      "summary": "Summary item for a single hydrated rule",
      "layer": "schema",
      "docstring": "Summary item for a single hydrated rule",
      "category": "business_logic"
    },
    {
      "name": "HydrateBaselineResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/baseline.py",
      "line": 168,
      "signature": "class HydrateBaselineResponse(DealBrainModel)",
      "summary": "Response schema for baseline rule hydration",
      "layer": "schema",
      "docstring": "Response schema for baseline rule hydration",
      "category": "business_logic"
    },
    {
      "name": "NormalizedListingSchema",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 14,
      "signature": "class NormalizedListingSchema(DealBrainModel)",
      "summary": "Normalized listing data extracted from any adapter.",
      "layer": "schema",
      "docstring": "Normalized listing data extracted from any adapter.\n\nThis schema represents the canonical format that all adapters\n(eBay API, JSON-LD, generic scraper) must produce. It contains\nthe essential listing information needed to create a Listing record.\n\nAttributes:\n    title: Product title/name\n    price: Listing price (always positive)\n    currency: ISO currency code (default USD)\n    condition: Product condition (maps to Condition enum)\n    images: List of image URLs\n    seller: Seller name or identifier (optional)\n    marketplace: Source marketplace (ebay|amazon|other)\n    vendor_item_id: Marketplace-specific item ID (optional)\n    cpu_model: Extracted CPU model string (optional)\n    ram_gb: Extracted RAM amount in GB (optional)\n    storage_gb: Extracted storage amount in GB (optional)\n    description: Full product description text (optional)",
      "category": "business_logic"
    },
    {
      "name": "validate_condition",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 108,
      "signature": "validate_condition(cls, value: str) -> str",
      "summary": "Validate condition maps to valid Condition enum value.",
      "layer": "schema",
      "parent": "NormalizedListingSchema",
      "docstring": "Validate condition maps to valid Condition enum value.",
      "category": "business_logic"
    },
    {
      "name": "validate_marketplace",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 122,
      "signature": "validate_marketplace(cls, value: str) -> str",
      "summary": "Validate marketplace maps to valid Marketplace enum value.",
      "layer": "schema",
      "parent": "NormalizedListingSchema",
      "docstring": "Validate marketplace maps to valid Marketplace enum value.",
      "category": "business_logic"
    },
    {
      "name": "validate_images",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 136,
      "signature": "validate_images(cls, value: Any) -> list[str]",
      "summary": "Ensure images is always a list.",
      "layer": "schema",
      "parent": "NormalizedListingSchema",
      "docstring": "Ensure images is always a list.",
      "category": "business_logic"
    },
    {
      "name": "IngestionRequest",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 145,
      "signature": "class IngestionRequest(DealBrainModel)",
      "summary": "Request schema for single URL import.",
      "layer": "schema",
      "docstring": "Request schema for single URL import.\n\nAttributes:\n    url: Valid HTTP/HTTPS URL to import\n    priority: Import priority level (normal|high)",
      "category": "business_logic"
    },
    {
      "name": "IngestionResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 165,
      "signature": "class IngestionResponse(DealBrainModel)",
      "summary": "Response schema for single URL import.",
      "layer": "schema",
      "docstring": "Response schema for single URL import.\n\nAttributes:\n    job_id: Unique job identifier (UUID or session ID)\n    status: Job status (queued|running|complete|partial|failed)\n    progress_pct: Progress percentage (0-100)\n    listing_id: Created listing ID if successful (optional)\n    provenance: Data source used (ebay_api|jsonld|scraper)\n    quality: Data quality level (full|partial)\n    errors: List of error details if any issues occurred",
      "category": "business_logic"
    },
    {
      "name": "BulkIngestionRequest",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 214,
      "signature": "class BulkIngestionRequest(DealBrainModel)",
      "summary": "Request schema for bulk URL import.",
      "layer": "schema",
      "docstring": "Request schema for bulk URL import.\n\nAttributes:\n    urls: List of URLs to import (1-100 URLs)",
      "category": "business_logic"
    },
    {
      "name": "validate_urls",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 231,
      "signature": "validate_urls(cls, value: list[str]) -> list[str]",
      "summary": "Validate all URLs are valid HTTP/HTTPS URLs.",
      "layer": "schema",
      "parent": "BulkIngestionRequest",
      "docstring": "Validate all URLs are valid HTTP/HTTPS URLs.",
      "category": "business_logic"
    },
    {
      "name": "BulkIngestionResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 244,
      "signature": "class BulkIngestionResponse(DealBrainModel)",
      "summary": "Response schema for bulk URL import.",
      "layer": "schema",
      "docstring": "Response schema for bulk URL import.\n\nAttributes:\n    bulk_job_id: Unique bulk job identifier\n    total_urls: Total number of URLs submitted\n    per_row_statuses: Per-URL status information (optional)",
      "category": "business_logic"
    },
    {
      "name": "PerRowStatus",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 269,
      "signature": "class PerRowStatus(DealBrainModel)",
      "summary": "Per-URL status information for bulk ingestion.",
      "layer": "schema",
      "docstring": "Per-URL status information for bulk ingestion.\n\nAttributes:\n    url: The URL being processed\n    status: Job status (queued|running|complete|partial|failed)\n    listing_id: Created listing ID if successful (optional)\n    error: Error message if failed (optional)",
      "category": "business_logic"
    },
    {
      "name": "BulkIngestionStatusResponse",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/ingestion.py",
      "line": 299,
      "signature": "class BulkIngestionStatusResponse(DealBrainModel)",
      "summary": "Response schema for bulk ingestion status poll endpoint.",
      "layer": "schema",
      "docstring": "Response schema for bulk ingestion status poll endpoint.\n\nAttributes:\n    bulk_job_id: Unique bulk job identifier\n    status: Overall bulk job status (queued|running|complete|partial|failed)\n    total_urls: Total number of URLs in the bulk job\n    completed: Number of URLs that finished processing (complete + partial + failed)\n    success: Number of URLs successfully completed (complete only)\n    partial: Number of URLs partially completed\n    failed: Number of URLs that failed\n    running: Number of URLs currently running\n    queued: Number of URLs still queued\n    per_row_status: Per-URL status information with pagination\n    offset: Pagination offset\n    limit: Pagination limit\n    has_more: Whether there are more results beyond current page",
      "category": "business_logic"
    },
    {
      "name": "ListingLink",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 28,
      "signature": "class ListingLink(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "validate_url",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 34,
      "signature": "validate_url(cls, value: str) -> str",
      "summary": "",
      "layer": "schema",
      "parent": "ListingLink",
      "category": "business_logic"
    },
    {
      "name": "normalize_label",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 42,
      "signature": "normalize_label(cls, value: str | None) -> str | None",
      "summary": "",
      "layer": "schema",
      "parent": "ListingLink",
      "category": "business_logic"
    },
    {
      "name": "ListingComponentBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 49,
      "signature": "class ListingComponentBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ListingComponentCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 58,
      "signature": "class ListingComponentCreate(ListingComponentBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ListingComponentRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 62,
      "signature": "class ListingComponentRead(ListingComponentBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ListingBase",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 68,
      "signature": "class ListingBase(DealBrainModel)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "validate_listing_url",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 110,
      "signature": "validate_listing_url(cls, value: Any) -> Any",
      "summary": "",
      "layer": "schema",
      "parent": "ListingBase",
      "category": "business_logic"
    },
    {
      "name": "coerce_other_urls",
      "kind": "method",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 117,
      "signature": "coerce_other_urls(cls, value: Any) -> Any",
      "summary": "",
      "layer": "schema",
      "parent": "ListingBase",
      "category": "business_logic"
    },
    {
      "name": "ListingCreate",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 138,
      "signature": "class ListingCreate(ListingBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ListingRead",
      "kind": "class",
      "path": "packages/core/dealbrain_core/schemas/listing.py",
      "line": 142,
      "signature": "class ListingRead(ListingBase)",
      "summary": "",
      "layer": "schema",
      "category": "business_logic"
    },
    {
      "name": "ConditionOperator",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 9,
      "signature": "class ConditionOperator(str, Enum)",
      "summary": "Supported condition operators",
      "layer": "core",
      "docstring": "Supported condition operators",
      "category": "business_logic"
    },
    {
      "name": "LogicalOperator",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 37,
      "signature": "class LogicalOperator(str, Enum)",
      "summary": "Logical operators for combining conditions",
      "layer": "core",
      "docstring": "Logical operators for combining conditions",
      "category": "business_logic"
    },
    {
      "name": "Condition",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 44,
      "signature": "class Condition",
      "summary": "Individual condition that can be evaluated against a context",
      "layer": "core",
      "docstring": "Individual condition that can be evaluated against a context",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 47,
      "signature": "__init__(self, field_name: str, field_type: str, operator: ConditionOperator | str, value: Any)",
      "summary": "",
      "layer": "core",
      "parent": "Condition",
      "category": "business_logic"
    },
    {
      "name": "evaluate",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 61,
      "signature": "evaluate(self, context: dict[str, Any]) -> bool",
      "summary": "Evaluate condition against a context dictionary.",
      "layer": "core",
      "parent": "Condition",
      "docstring": "Evaluate condition against a context dictionary.\n\nArgs:\n    context: Dictionary with field values (supports nested access via dot notation)\n\nReturns:\n    True if condition is satisfied, False otherwise",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 174,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "Convert condition to dictionary representation",
      "layer": "core",
      "parent": "Condition",
      "docstring": "Convert condition to dictionary representation",
      "category": "business_logic"
    },
    {
      "name": "ConditionGroup",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 184,
      "signature": "class ConditionGroup",
      "summary": "Group of conditions combined with logical operators",
      "layer": "core",
      "docstring": "Group of conditions combined with logical operators",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 187,
      "signature": "__init__(self, conditions: list[Condition | 'ConditionGroup'], logical_operator: LogicalOperator | str)",
      "summary": "",
      "layer": "core",
      "parent": "ConditionGroup",
      "category": "business_logic"
    },
    {
      "name": "evaluate",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 201,
      "signature": "evaluate(self, context: dict[str, Any]) -> bool",
      "summary": "Evaluate all conditions in the group with the logical operator.",
      "layer": "core",
      "parent": "ConditionGroup",
      "docstring": "Evaluate all conditions in the group with the logical operator.\n\nArgs:\n    context: Dictionary with field values\n\nReturns:\n    True if the group conditions are satisfied, False otherwise",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 226,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "Convert condition group to dictionary representation",
      "layer": "core",
      "parent": "ConditionGroup",
      "docstring": "Convert condition group to dictionary representation",
      "category": "business_logic"
    },
    {
      "name": "build_condition_from_dict",
      "kind": "function",
      "path": "packages/core/dealbrain_core/rules/conditions.py",
      "line": 234,
      "signature": "build_condition_from_dict(data: dict[str, Any]) -> Condition | ConditionGroup",
      "summary": "Build a Condition or ConditionGroup from dictionary representation.",
      "layer": "core",
      "docstring": "Build a Condition or ConditionGroup from dictionary representation.\n\nArgs:\n    data: Dictionary with condition data\n\nReturns:\n    Condition or ConditionGroup instance",
      "category": "business_logic"
    },
    {
      "name": "PackageMetadata",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 16,
      "signature": "class PackageMetadata(BaseModel)",
      "summary": "Metadata for a ruleset package.",
      "layer": "core",
      "docstring": "Metadata for a ruleset package.",
      "category": "business_logic"
    },
    {
      "name": "validate_version",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 31,
      "signature": "validate_version(cls, v: str) -> str",
      "summary": "Validate semantic version format.",
      "layer": "core",
      "parent": "PackageMetadata",
      "docstring": "Validate semantic version format.",
      "category": "business_logic"
    },
    {
      "name": "RulesetExport",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 41,
      "signature": "class RulesetExport(BaseModel)",
      "summary": "Exported ruleset data.",
      "layer": "core",
      "docstring": "Exported ruleset data.",
      "category": "business_logic"
    },
    {
      "name": "RuleGroupExport",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 55,
      "signature": "class RuleGroupExport(BaseModel)",
      "summary": "Exported rule group data.",
      "layer": "core",
      "docstring": "Exported rule group data.",
      "category": "business_logic"
    },
    {
      "name": "RuleConditionExport",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 72,
      "signature": "class RuleConditionExport(BaseModel)",
      "summary": "Exported rule condition data.",
      "layer": "core",
      "docstring": "Exported rule condition data.",
      "category": "business_logic"
    },
    {
      "name": "RuleActionExport",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 86,
      "signature": "class RuleActionExport(BaseModel)",
      "summary": "Exported rule action data.",
      "layer": "core",
      "docstring": "Exported rule action data.",
      "category": "business_logic"
    },
    {
      "name": "RuleExport",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 100,
      "signature": "class RuleExport(BaseModel)",
      "summary": "Exported rule data with conditions and actions.",
      "layer": "core",
      "docstring": "Exported rule data with conditions and actions.",
      "category": "business_logic"
    },
    {
      "name": "CustomFieldDefinition",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 119,
      "signature": "class CustomFieldDefinition(BaseModel)",
      "summary": "Custom field definition for compatibility.",
      "layer": "core",
      "docstring": "Custom field definition for compatibility.",
      "category": "business_logic"
    },
    {
      "name": "RulesetPackage",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 130,
      "signature": "class RulesetPackage(BaseModel)",
      "summary": "Complete ruleset package in .dbrs format.",
      "layer": "core",
      "docstring": "Complete ruleset package in .dbrs format.",
      "category": "business_logic"
    },
    {
      "name": "to_json",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 144,
      "signature": "to_json(self, indent: int) -> str",
      "summary": "Serialize package to JSON string.",
      "layer": "core",
      "parent": "RulesetPackage",
      "docstring": "Serialize package to JSON string.",
      "category": "business_logic"
    },
    {
      "name": "to_file",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 148,
      "signature": "to_file(self, path: Path) -> None",
      "summary": "Write package to .dbrs file.",
      "layer": "core",
      "parent": "RulesetPackage",
      "docstring": "Write package to .dbrs file.",
      "category": "business_logic"
    },
    {
      "name": "from_json",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 154,
      "signature": "from_json(cls, json_str: str) -> 'RulesetPackage'",
      "summary": "Deserialize package from JSON string.",
      "layer": "core",
      "parent": "RulesetPackage",
      "docstring": "Deserialize package from JSON string.",
      "category": "business_logic"
    },
    {
      "name": "from_file",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 159,
      "signature": "from_file(cls, path: Path) -> 'RulesetPackage'",
      "summary": "Load package from .dbrs file.",
      "layer": "core",
      "parent": "RulesetPackage",
      "docstring": "Load package from .dbrs file.",
      "category": "business_logic"
    },
    {
      "name": "validate_compatibility",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 164,
      "signature": "validate_compatibility(self, app_version: str, available_fields: List[str]) -> Dict[str, Any]",
      "summary": "Validate package compatibility with current system.",
      "layer": "core",
      "parent": "RulesetPackage",
      "docstring": "Validate package compatibility with current system.\n\nReturns dict with:\n- compatible: bool\n- missing_fields: List[str]\n- warnings: List[str]",
      "category": "business_logic"
    },
    {
      "name": "get_dependencies",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 217,
      "signature": "get_dependencies(self) -> Dict[str, List[str]]",
      "summary": "Extract dependencies from the package.",
      "layer": "core",
      "parent": "RulesetPackage",
      "docstring": "Extract dependencies from the package.\n\nReturns dict with:\n- custom_fields: List of required custom field names\n- referenced_entities: List of entity types referenced",
      "category": "business_logic"
    },
    {
      "name": "generate_readme",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 247,
      "signature": "generate_readme(self) -> str",
      "summary": "Generate README content for the package.",
      "layer": "core",
      "parent": "RulesetPackage",
      "docstring": "Generate README content for the package.",
      "category": "business_logic"
    },
    {
      "name": "PackageBuilder",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 300,
      "signature": "class PackageBuilder",
      "summary": "Builder for creating ruleset packages.",
      "layer": "core",
      "docstring": "Builder for creating ruleset packages.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 303,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "core",
      "parent": "PackageBuilder",
      "category": "business_logic"
    },
    {
      "name": "add_ruleset",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 310,
      "signature": "add_ruleset(self, ruleset: RulesetExport) -> 'PackageBuilder'",
      "summary": "Add a ruleset to the package.",
      "layer": "core",
      "parent": "PackageBuilder",
      "docstring": "Add a ruleset to the package.",
      "category": "business_logic"
    },
    {
      "name": "add_rule_group",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 315,
      "signature": "add_rule_group(self, group: RuleGroupExport) -> 'PackageBuilder'",
      "summary": "Add a rule group to the package.",
      "layer": "core",
      "parent": "PackageBuilder",
      "docstring": "Add a rule group to the package.",
      "category": "business_logic"
    },
    {
      "name": "add_rule",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 320,
      "signature": "add_rule(self, rule: RuleExport) -> 'PackageBuilder'",
      "summary": "Add a rule to the package.",
      "layer": "core",
      "parent": "PackageBuilder",
      "docstring": "Add a rule to the package.",
      "category": "business_logic"
    },
    {
      "name": "add_custom_field",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 325,
      "signature": "add_custom_field(self, field: CustomFieldDefinition) -> 'PackageBuilder'",
      "summary": "Add a custom field definition to the package.",
      "layer": "core",
      "parent": "PackageBuilder",
      "docstring": "Add a custom field definition to the package.",
      "category": "business_logic"
    },
    {
      "name": "add_example",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 330,
      "signature": "add_example(self, example: Dict[str, Any]) -> 'PackageBuilder'",
      "summary": "Add an example to the package.",
      "layer": "core",
      "parent": "PackageBuilder",
      "docstring": "Add an example to the package.",
      "category": "business_logic"
    },
    {
      "name": "build",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 335,
      "signature": "build(self, metadata: PackageMetadata) -> RulesetPackage",
      "summary": "Build the complete package.",
      "layer": "core",
      "parent": "PackageBuilder",
      "docstring": "Build the complete package.",
      "category": "business_logic"
    },
    {
      "name": "create_package_metadata",
      "kind": "function",
      "path": "packages/core/dealbrain_core/rules/packaging.py",
      "line": 347,
      "signature": "create_package_metadata(name: str, version: str, author: str, description: str, min_app_version: Optional[str], required_custom_fields: Optional[List[str]], tags: Optional[List[str]]) -> PackageMetadata",
      "summary": "Helper to create package metadata.",
      "layer": "core",
      "docstring": "Helper to create package metadata.",
      "category": "business_logic"
    },
    {
      "name": "ActionType",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 12,
      "signature": "class ActionType(str, Enum)",
      "summary": "Supported action types for valuation rules",
      "layer": "core",
      "docstring": "Supported action types for valuation rules",
      "category": "business_logic"
    },
    {
      "name": "Action",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 22,
      "signature": "class Action",
      "summary": "Valuation action that calculates an adjustment value",
      "layer": "core",
      "docstring": "Valuation action that calculates an adjustment value",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 25,
      "signature": "__init__(self, action_type: ActionType | str, metric: str | None, value_usd: float | None, unit_type: str | None, formula: str | None, modifiers: dict[str, Any] | None)",
      "summary": "",
      "layer": "core",
      "parent": "Action",
      "category": "business_logic"
    },
    {
      "name": "calculate",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 41,
      "signature": "calculate(self, context: dict[str, Any], formula_engine: Any) -> float",
      "summary": "Calculate the valuation adjustment based on the action type.",
      "layer": "core",
      "parent": "Action",
      "docstring": "Calculate the valuation adjustment based on the action type.\n\nArgs:\n    context: Dictionary with listing data (supports dot notation)\n    formula_engine: Optional formula engine for custom formulas\n\nReturns:\n    Calculated adjustment value in USD",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 270,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "Convert action to dictionary representation",
      "layer": "core",
      "parent": "Action",
      "docstring": "Convert action to dictionary representation",
      "category": "business_logic"
    },
    {
      "name": "ActionEngine",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 282,
      "signature": "class ActionEngine",
      "summary": "Engine for executing multiple actions and combining results",
      "layer": "core",
      "docstring": "Engine for executing multiple actions and combining results",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 285,
      "signature": "__init__(self, formula_engine: Any)",
      "summary": "",
      "layer": "core",
      "parent": "ActionEngine",
      "category": "business_logic"
    },
    {
      "name": "execute_actions",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 288,
      "signature": "execute_actions(self, actions: list[Action], context: dict[str, Any]) -> dict[str, Any]",
      "summary": "Execute multiple actions and return combined results.",
      "layer": "core",
      "parent": "ActionEngine",
      "docstring": "Execute multiple actions and return combined results.\n\nArgs:\n    actions: List of Action instances to execute\n    context: Context dictionary with listing data\n\nReturns:\n    Dictionary with:\n        - total_adjustment: Sum of all action values\n        - breakdown: List of individual action results",
      "category": "business_logic"
    },
    {
      "name": "build_action_from_dict",
      "kind": "function",
      "path": "packages/core/dealbrain_core/rules/actions.py",
      "line": 332,
      "signature": "build_action_from_dict(data: dict[str, Any]) -> Action",
      "summary": "Build an Action from dictionary representation.",
      "layer": "core",
      "docstring": "Build an Action from dictionary representation.\n\nArgs:\n    data: Dictionary with action data\n\nReturns:\n    Action instance",
      "category": "business_logic"
    },
    {
      "name": "RuleEvaluationResult",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/evaluator.py",
      "line": 17,
      "signature": "class RuleEvaluationResult",
      "summary": "Result of evaluating a rule against a listing",
      "layer": "core",
      "docstring": "Result of evaluating a rule against a listing",
      "category": "business_logic"
    },
    {
      "name": "RuleEvaluator",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/evaluator.py",
      "line": 27,
      "signature": "class RuleEvaluator",
      "summary": "Orchestrates rule evaluation: condition checking + action execution",
      "layer": "core",
      "docstring": "Orchestrates rule evaluation: condition checking + action execution",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/evaluator.py",
      "line": 30,
      "signature": "__init__(self, formula_engine: FormulaEngine | None)",
      "summary": "",
      "layer": "core",
      "parent": "RuleEvaluator",
      "category": "business_logic"
    },
    {
      "name": "evaluate_rule",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/evaluator.py",
      "line": 34,
      "signature": "evaluate_rule(self, rule_id: int, rule_name: str, conditions: Condition | ConditionGroup | list[Condition | ConditionGroup], actions: list[Action], context: dict[str, Any], is_active: bool) -> RuleEvaluationResult",
      "summary": "Evaluate a single rule against a context.",
      "layer": "core",
      "parent": "RuleEvaluator",
      "docstring": "Evaluate a single rule against a context.\n\nArgs:\n    rule_id: Rule identifier\n    rule_name: Rule name for reporting\n    conditions: Condition, ConditionGroup, or list of conditions\n    actions: List of Action instances\n    context: Context dictionary with listing data\n    is_active: Whether the rule is active\n\nReturns:\n    RuleEvaluationResult with match status and calculated value",
      "category": "business_logic"
    },
    {
      "name": "evaluate_ruleset",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/evaluator.py",
      "line": 134,
      "signature": "evaluate_ruleset(self, rules: list[dict[str, Any]], context: dict[str, Any], stop_on_first_match: bool) -> list[RuleEvaluationResult]",
      "summary": "Evaluate multiple rules in a ruleset.",
      "layer": "core",
      "parent": "RuleEvaluator",
      "docstring": "Evaluate multiple rules in a ruleset.\n\nArgs:\n    rules: List of rule dictionaries with id, name, conditions, actions, is_active\n    context: Context dictionary with listing data\n    stop_on_first_match: If True, stop after first matching rule\n\nReturns:\n    List of RuleEvaluationResult for each rule",
      "category": "business_logic"
    },
    {
      "name": "calculate_total_adjustment",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/evaluator.py",
      "line": 193,
      "signature": "calculate_total_adjustment(self, evaluation_results: list[RuleEvaluationResult]) -> dict[str, Any]",
      "summary": "Calculate total adjustment from multiple rule evaluations.",
      "layer": "core",
      "parent": "RuleEvaluator",
      "docstring": "Calculate total adjustment from multiple rule evaluations.\n\nArgs:\n    evaluation_results: List of RuleEvaluationResult\n\nReturns:\n    Dictionary with total_adjustment and detailed breakdown",
      "category": "business_logic"
    },
    {
      "name": "build_context_from_listing",
      "kind": "function",
      "path": "packages/core/dealbrain_core/rules/evaluator.py",
      "line": 226,
      "signature": "build_context_from_listing(listing: Any) -> dict[str, Any]",
      "summary": "Build evaluation context from a listing object.",
      "layer": "core",
      "docstring": "Build evaluation context from a listing object.\n\nArgs:\n    listing: Listing model instance or dictionary\n\nReturns:\n    Context dictionary suitable for rule evaluation",
      "category": "business_logic"
    },
    {
      "name": "FormulaError",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 13,
      "signature": "class FormulaError(Exception)",
      "summary": "Base exception for formula parsing and evaluation errors",
      "layer": "core",
      "docstring": "Base exception for formula parsing and evaluation errors",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 16,
      "signature": "__init__(self, message: str, position: Optional[int], suggestion: Optional[str])",
      "summary": "Initialize formula error with detailed information.",
      "layer": "core",
      "parent": "FormulaError",
      "docstring": "Initialize formula error with detailed information.\n\nArgs:\n    message: Error description\n    position: Character position in formula where error occurred\n    suggestion: Optional suggestion for fixing the error",
      "category": "business_logic"
    },
    {
      "name": "FormulaSyntaxError",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 39,
      "signature": "class FormulaSyntaxError(FormulaError)",
      "summary": "Raised when formula has syntax errors",
      "layer": "core",
      "docstring": "Raised when formula has syntax errors",
      "category": "business_logic"
    },
    {
      "name": "FormulaValidationError",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 44,
      "signature": "class FormulaValidationError(FormulaError)",
      "summary": "Raised when formula contains unsafe or disallowed operations",
      "layer": "core",
      "docstring": "Raised when formula contains unsafe or disallowed operations",
      "category": "business_logic"
    },
    {
      "name": "FormulaParser",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 49,
      "signature": "class FormulaParser",
      "summary": "Parse formula strings to ensure they are safe for evaluation",
      "layer": "core",
      "docstring": "Parse formula strings to ensure they are safe for evaluation",
      "category": "business_logic"
    },
    {
      "name": "parse",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 93,
      "signature": "parse(self, formula: str) -> ast.Expression",
      "summary": "Parse a formula string and validate it's safe.",
      "layer": "core",
      "parent": "FormulaParser",
      "docstring": "Parse a formula string and validate it's safe.\n\nArgs:\n    formula: Formula string (e.g., \"ram_gb * 2.5 + cpu_mark / 1000\")\n\nReturns:\n    Parsed AST expression\n\nRaises:\n    FormulaSyntaxError: If formula has syntax errors\n    FormulaValidationError: If formula contains unsafe operations",
      "category": "business_logic"
    },
    {
      "name": "FormulaEngine",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 291,
      "signature": "class FormulaEngine",
      "summary": "Engine for evaluating safe formulas against context",
      "layer": "core",
      "docstring": "Engine for evaluating safe formulas against context",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 294,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "core",
      "parent": "FormulaEngine",
      "category": "business_logic"
    },
    {
      "name": "evaluate",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 297,
      "signature": "evaluate(self, formula: str, context: dict[str, Any]) -> float",
      "summary": "Evaluate a formula string against a context.",
      "layer": "core",
      "parent": "FormulaEngine",
      "docstring": "Evaluate a formula string against a context.\n\nArgs:\n    formula: Formula string\n    context: Dictionary with variable values\n\nReturns:\n    Calculated result as float\n\nRaises:\n    FormulaSyntaxError: If formula has syntax errors\n    FormulaValidationError: If formula is invalid\n    FormulaError: If evaluation fails",
      "category": "business_logic"
    },
    {
      "name": "test_formula",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula.py",
      "line": 390,
      "signature": "test_formula(self, formula: str, test_cases: list[dict[str, Any]]) -> list[dict[str, Any]]",
      "summary": "Test a formula against multiple test cases.",
      "layer": "core",
      "parent": "FormulaEngine",
      "docstring": "Test a formula against multiple test cases.\n\nArgs:\n    formula: Formula string to test\n    test_cases: List of context dictionaries\n\nReturns:\n    List of results with context and calculated value",
      "category": "business_logic"
    },
    {
      "name": "ValidationError",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 13,
      "signature": "class ValidationError",
      "summary": "Represents a validation error with details",
      "layer": "core",
      "docstring": "Represents a validation error with details",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 16,
      "signature": "__init__(self, message: str, severity: str, position: Optional[int], suggestion: Optional[str])",
      "summary": "Initialize validation error.",
      "layer": "core",
      "parent": "ValidationError",
      "docstring": "Initialize validation error.\n\nArgs:\n    message: Error message\n    severity: Error severity (error, warning, info)\n    position: Character position in formula\n    suggestion: Suggested fix",
      "category": "business_logic"
    },
    {
      "name": "__repr__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 37,
      "signature": "__repr__(self) -> str",
      "summary": "",
      "layer": "core",
      "parent": "ValidationError",
      "category": "business_logic"
    },
    {
      "name": "to_dict",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 45,
      "signature": "to_dict(self) -> dict[str, Any]",
      "summary": "Convert to dictionary representation",
      "layer": "core",
      "parent": "ValidationError",
      "docstring": "Convert to dictionary representation",
      "category": "business_logic"
    },
    {
      "name": "FormulaValidator",
      "kind": "class",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 58,
      "signature": "class FormulaValidator",
      "summary": "Advanced formula validator with AST analysis and field reference extraction.",
      "layer": "core",
      "docstring": "Advanced formula validator with AST analysis and field reference extraction.\n\nThis validator provides:\n- Detailed validation with multiple error reporting\n- Field reference extraction (including nested fields)\n- AST visualization for debugging\n- Context validation (checking if fields exist)",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 69,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "core",
      "parent": "FormulaValidator",
      "category": "business_logic"
    },
    {
      "name": "validate",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 72,
      "signature": "validate(self, formula: str) -> list[ValidationError]",
      "summary": "Validate a formula and return list of validation errors.",
      "layer": "core",
      "parent": "FormulaValidator",
      "docstring": "Validate a formula and return list of validation errors.\n\nArgs:\n    formula: Formula string to validate\n\nReturns:\n    List of validation errors (empty if valid)",
      "category": "business_logic"
    },
    {
      "name": "get_field_references",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 134,
      "signature": "get_field_references(self, formula: str) -> set[str]",
      "summary": "Extract all field references from a formula.",
      "layer": "core",
      "parent": "FormulaValidator",
      "docstring": "Extract all field references from a formula.\n\nThis includes:\n- Simple variables: ram_gb\n- Nested fields: cpu.cores, ram_spec.ddr_generation\n\nArgs:\n    formula: Formula string\n\nReturns:\n    Set of field reference strings",
      "category": "business_logic"
    },
    {
      "name": "get_ast_visualization",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 158,
      "signature": "get_ast_visualization(self, formula: str, indent: int) -> str",
      "summary": "Generate a readable AST visualization for debugging.",
      "layer": "core",
      "parent": "FormulaValidator",
      "docstring": "Generate a readable AST visualization for debugging.\n\nArgs:\n    formula: Formula string\n    indent: Number of spaces per indentation level\n\nReturns:\n    String representation of AST tree",
      "category": "business_logic"
    },
    {
      "name": "validate_field_availability",
      "kind": "method",
      "path": "packages/core/dealbrain_core/rules/formula_validator.py",
      "line": 178,
      "signature": "validate_field_availability(self, formula: str, available_fields: set[str]) -> list[ValidationError]",
      "summary": "Validate that all referenced fields exist in the available context.",
      "layer": "core",
      "parent": "FormulaValidator",
      "docstring": "Validate that all referenced fields exist in the available context.\n\nArgs:\n    formula: Formula string\n    available_fields: Set of field names available in context\n\nReturns:\n    List of validation errors for missing fields",
      "category": "business_logic"
    },
    {
      "name": "test_compute_adjusted_price_applies_rules",
      "kind": "function",
      "path": "tests/test_valuation.py",
      "line": 5,
      "signature": "test_compute_adjusted_price_applies_rules()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_normalize_key_strips_and_snake_cases",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 7,
      "signature": "test_normalize_key_strips_and_snake_cases()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_validate_field_type_rejects_unknown",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 12,
      "signature": "test_validate_field_type_rejects_unknown()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_normalize_options_requires_enum_options",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 18,
      "signature": "test_normalize_options_requires_enum_options()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_normalize_options_supports_multi_select",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 27,
      "signature": "test_normalize_options_supports_multi_select()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_normalize_validation_numeric_bounds",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 32,
      "signature": "test_normalize_validation_numeric_bounds()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_normalize_validation_rejects_unknown_keys",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 38,
      "signature": "test_normalize_validation_rejects_unknown_keys()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_normalize_validation_rejects_numeric_bounds_for_strings",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 44,
      "signature": "test_normalize_validation_rejects_numeric_bounds_for_strings()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_normalize_validation_allows_allowed_values",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 50,
      "signature": "test_normalize_validation_allows_allowed_values()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_infer_field_shape_for_boolean_list",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 56,
      "signature": "test_infer_field_shape_for_boolean_list()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_infer_field_shape_for_numeric_sample",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 63,
      "signature": "test_infer_field_shape_for_numeric_sample()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_infer_field_shape_for_enum_sample",
      "kind": "function",
      "path": "tests/test_custom_fields_service.py",
      "line": 70,
      "signature": "test_infer_field_shape_for_enum_sample()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "anyio_backend",
      "kind": "function",
      "path": "tests/test_custom_fields_integration.py",
      "line": 14,
      "signature": "anyio_backend()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_field_dependency_guardrails_and_audit",
      "kind": "async_function",
      "path": "tests/test_custom_fields_integration.py",
      "line": 24,
      "signature": "async test_field_dependency_guardrails_and_audit()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "TestGetOrCreatePortsProfile",
      "kind": "class",
      "path": "tests/test_ports_service.py",
      "line": 15,
      "signature": "class TestGetOrCreatePortsProfile",
      "summary": "Test get_or_create_ports_profile function.",
      "layer": "test",
      "docstring": "Test get_or_create_ports_profile function.",
      "category": "test"
    },
    {
      "name": "test_create_new_profile",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 18,
      "signature": "async test_create_new_profile(self, session: AsyncSession)",
      "summary": "Test creating new ports profile for listing.",
      "layer": "test",
      "parent": "TestGetOrCreatePortsProfile",
      "docstring": "Test creating new ports profile for listing.",
      "category": "test"
    },
    {
      "name": "test_get_existing_profile",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 30,
      "signature": "async test_get_existing_profile(self, session: AsyncSession)",
      "summary": "Test getting existing ports profile.",
      "layer": "test",
      "parent": "TestGetOrCreatePortsProfile",
      "docstring": "Test getting existing ports profile.",
      "category": "test"
    },
    {
      "name": "test_listing_not_found",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 51,
      "signature": "async test_listing_not_found(self, session: AsyncSession)",
      "summary": "Test error when listing doesn't exist.",
      "layer": "test",
      "parent": "TestGetOrCreatePortsProfile",
      "docstring": "Test error when listing doesn't exist.",
      "category": "test"
    },
    {
      "name": "TestUpdateListingPorts",
      "kind": "class",
      "path": "tests/test_ports_service.py",
      "line": 58,
      "signature": "class TestUpdateListingPorts",
      "summary": "Test update_listing_ports function.",
      "layer": "test",
      "docstring": "Test update_listing_ports function.",
      "category": "test"
    },
    {
      "name": "test_create_ports",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 61,
      "signature": "async test_create_ports(self, session: AsyncSession)",
      "summary": "Test creating ports for listing.",
      "layer": "test",
      "parent": "TestUpdateListingPorts",
      "docstring": "Test creating ports for listing.",
      "category": "test"
    },
    {
      "name": "test_update_existing_ports",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 83,
      "signature": "async test_update_existing_ports(self, session: AsyncSession)",
      "summary": "Test updating existing ports (clear and replace).",
      "layer": "test",
      "parent": "TestUpdateListingPorts",
      "docstring": "Test updating existing ports (clear and replace).",
      "category": "test"
    },
    {
      "name": "test_empty_ports_list",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 119,
      "signature": "async test_empty_ports_list(self, session: AsyncSession)",
      "summary": "Test updating with empty ports list (clears all ports).",
      "layer": "test",
      "parent": "TestUpdateListingPorts",
      "docstring": "Test updating with empty ports list (clears all ports).",
      "category": "test"
    },
    {
      "name": "TestGetListingPorts",
      "kind": "class",
      "path": "tests/test_ports_service.py",
      "line": 145,
      "signature": "class TestGetListingPorts",
      "summary": "Test get_listing_ports function.",
      "layer": "test",
      "docstring": "Test get_listing_ports function.",
      "category": "test"
    },
    {
      "name": "test_get_ports",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 148,
      "signature": "async test_get_ports(self, session: AsyncSession)",
      "summary": "Test getting ports for listing.",
      "layer": "test",
      "parent": "TestGetListingPorts",
      "docstring": "Test getting ports for listing.",
      "category": "test"
    },
    {
      "name": "test_get_ports_empty",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 174,
      "signature": "async test_get_ports_empty(self, session: AsyncSession)",
      "summary": "Test getting ports when none exist.",
      "layer": "test",
      "parent": "TestGetListingPorts",
      "docstring": "Test getting ports when none exist.",
      "category": "test"
    },
    {
      "name": "test_get_ports_listing_not_found",
      "kind": "async_method",
      "path": "tests/test_ports_service.py",
      "line": 184,
      "signature": "async test_get_ports_listing_not_found(self, session: AsyncSession)",
      "summary": "Test getting ports when listing doesn't exist.",
      "layer": "test",
      "parent": "TestGetListingPorts",
      "docstring": "Test getting ports when listing doesn't exist.",
      "category": "test"
    },
    {
      "name": "TestCalculateCpuPerformanceMetrics",
      "kind": "class",
      "path": "tests/test_listing_metrics.py",
      "line": 28,
      "signature": "class TestCalculateCpuPerformanceMetrics",
      "summary": "Test calculate_cpu_performance_metrics function.",
      "layer": "test",
      "docstring": "Test calculate_cpu_performance_metrics function.",
      "category": "test"
    },
    {
      "name": "test_calculate_metrics_with_valid_cpu",
      "kind": "method",
      "path": "tests/test_listing_metrics.py",
      "line": 31,
      "signature": "test_calculate_metrics_with_valid_cpu(self)",
      "summary": "Test metric calculation with valid CPU data.",
      "layer": "test",
      "parent": "TestCalculateCpuPerformanceMetrics",
      "docstring": "Test metric calculation with valid CPU data.",
      "category": "test"
    },
    {
      "name": "test_calculate_metrics_no_cpu",
      "kind": "method",
      "path": "tests/test_listing_metrics.py",
      "line": 65,
      "signature": "test_calculate_metrics_no_cpu(self)",
      "summary": "Test graceful handling when CPU not assigned.",
      "layer": "test",
      "parent": "TestCalculateCpuPerformanceMetrics",
      "docstring": "Test graceful handling when CPU not assigned.",
      "category": "test"
    },
    {
      "name": "test_calculate_metrics_missing_single_thread",
      "kind": "method",
      "path": "tests/test_listing_metrics.py",
      "line": 71,
      "signature": "test_calculate_metrics_missing_single_thread(self)",
      "summary": "Test handling when single-thread benchmark missing.",
      "layer": "test",
      "parent": "TestCalculateCpuPerformanceMetrics",
      "docstring": "Test handling when single-thread benchmark missing.",
      "category": "test"
    },
    {
      "name": "test_calculate_metrics_zero_cpu_mark",
      "kind": "method",
      "path": "tests/test_listing_metrics.py",
      "line": 90,
      "signature": "test_calculate_metrics_zero_cpu_mark(self)",
      "summary": "Test handling when CPU mark is zero (invalid data).",
      "layer": "test",
      "parent": "TestCalculateCpuPerformanceMetrics",
      "docstring": "Test handling when CPU mark is zero (invalid data).",
      "category": "test"
    },
    {
      "name": "test_calculate_metrics_no_adjusted_price",
      "kind": "method",
      "path": "tests/test_listing_metrics.py",
      "line": 108,
      "signature": "test_calculate_metrics_no_adjusted_price(self)",
      "summary": "Test metrics when adjusted_price_usd is None.",
      "layer": "test",
      "parent": "TestCalculateCpuPerformanceMetrics",
      "docstring": "Test metrics when adjusted_price_usd is None.",
      "category": "test"
    },
    {
      "name": "TestUpdateListingMetrics",
      "kind": "class",
      "path": "tests/test_listing_metrics.py",
      "line": 136,
      "signature": "class TestUpdateListingMetrics",
      "summary": "Test update_listing_metrics function.",
      "layer": "test",
      "docstring": "Test update_listing_metrics function.",
      "category": "test"
    },
    {
      "name": "test_update_listing_metrics",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 139,
      "signature": "async test_update_listing_metrics(self, session: AsyncSession)",
      "summary": "Test metric persistence.",
      "layer": "test",
      "parent": "TestUpdateListingMetrics",
      "docstring": "Test metric persistence.",
      "category": "test"
    },
    {
      "name": "test_update_listing_metrics_not_found",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 167,
      "signature": "async test_update_listing_metrics_not_found(self, session: AsyncSession)",
      "summary": "Test error handling when listing not found.",
      "layer": "test",
      "parent": "TestUpdateListingMetrics",
      "docstring": "Test error handling when listing not found.",
      "category": "test"
    },
    {
      "name": "TestBulkUpdateListingMetrics",
      "kind": "class",
      "path": "tests/test_listing_metrics.py",
      "line": 174,
      "signature": "class TestBulkUpdateListingMetrics",
      "summary": "Test bulk_update_listing_metrics function.",
      "layer": "test",
      "docstring": "Test bulk_update_listing_metrics function.",
      "category": "test"
    },
    {
      "name": "test_bulk_update_all_listings",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 177,
      "signature": "async test_bulk_update_all_listings(self, session: AsyncSession)",
      "summary": "Test bulk update for all listings.",
      "layer": "test",
      "parent": "TestBulkUpdateListingMetrics",
      "docstring": "Test bulk update for all listings.",
      "category": "test"
    },
    {
      "name": "test_bulk_update_specific_listings",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 207,
      "signature": "async test_bulk_update_specific_listings(self, session: AsyncSession)",
      "summary": "Test bulk update for specific listing IDs.",
      "layer": "test",
      "parent": "TestBulkUpdateListingMetrics",
      "docstring": "Test bulk update for specific listing IDs.",
      "category": "test"
    },
    {
      "name": "TestApplyListingMetricsCpuMarks",
      "kind": "class",
      "path": "tests/test_listing_metrics.py",
      "line": 241,
      "signature": "class TestApplyListingMetricsCpuMarks",
      "summary": "Test apply_listing_metrics function for CPU Mark calculations.",
      "layer": "test",
      "docstring": "Test apply_listing_metrics function for CPU Mark calculations.",
      "category": "test"
    },
    {
      "name": "test_cpu_mark_calculations_with_both_marks",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 244,
      "signature": "async test_cpu_mark_calculations_with_both_marks(self, session: AsyncSession)",
      "summary": "Test CPU Mark metrics calculated with both single and multi marks.",
      "layer": "test",
      "parent": "TestApplyListingMetricsCpuMarks",
      "docstring": "Test CPU Mark metrics calculated with both single and multi marks.",
      "category": "test"
    },
    {
      "name": "test_cpu_mark_calculations_single_only",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 279,
      "signature": "async test_cpu_mark_calculations_single_only(self, session: AsyncSession)",
      "summary": "Test metrics when only single-thread mark available.",
      "layer": "test",
      "parent": "TestApplyListingMetricsCpuMarks",
      "docstring": "Test metrics when only single-thread mark available.",
      "category": "test"
    },
    {
      "name": "test_cpu_mark_calculations_multi_only",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 308,
      "signature": "async test_cpu_mark_calculations_multi_only(self, session: AsyncSession)",
      "summary": "Test metrics when only multi-thread mark available.",
      "layer": "test",
      "parent": "TestApplyListingMetricsCpuMarks",
      "docstring": "Test metrics when only multi-thread mark available.",
      "category": "test"
    },
    {
      "name": "test_cpu_mark_calculations_no_cpu",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 337,
      "signature": "async test_cpu_mark_calculations_no_cpu(self, session: AsyncSession)",
      "summary": "Test metrics when no CPU assigned.",
      "layer": "test",
      "parent": "TestApplyListingMetricsCpuMarks",
      "docstring": "Test metrics when no CPU assigned.",
      "category": "test"
    },
    {
      "name": "test_cpu_mark_recalculation_on_price_update",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 354,
      "signature": "async test_cpu_mark_recalculation_on_price_update(self, session: AsyncSession)",
      "summary": "Test metrics recalculate when price changes.",
      "layer": "test",
      "parent": "TestApplyListingMetricsCpuMarks",
      "docstring": "Test metrics recalculate when price changes.",
      "category": "test"
    },
    {
      "name": "test_cpu_mark_recalculation_on_cpu_change",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 392,
      "signature": "async test_cpu_mark_recalculation_on_cpu_change(self, session: AsyncSession)",
      "summary": "Test metrics recalculate when CPU changes.",
      "layer": "test",
      "parent": "TestApplyListingMetricsCpuMarks",
      "docstring": "Test metrics recalculate when CPU changes.",
      "category": "test"
    },
    {
      "name": "TestApplyListingMetricsValuationRules",
      "kind": "class",
      "path": "tests/test_listing_metrics.py",
      "line": 441,
      "signature": "class TestApplyListingMetricsValuationRules",
      "summary": "Test integration between apply_listing_metrics and the valuation rule engine.",
      "layer": "test",
      "docstring": "Test integration between apply_listing_metrics and the valuation rule engine.",
      "category": "test"
    },
    {
      "name": "test_apply_listing_metrics_with_matching_ruleset",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 444,
      "signature": "async test_apply_listing_metrics_with_matching_ruleset(self, session: AsyncSession)",
      "summary": "Adjusted price should incorporate rule engine adjustments.",
      "layer": "test",
      "parent": "TestApplyListingMetricsValuationRules",
      "docstring": "Adjusted price should incorporate rule engine adjustments.",
      "category": "test"
    },
    {
      "name": "test_apply_listing_metrics_without_rulesets_defaults_to_list_price",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 504,
      "signature": "async test_apply_listing_metrics_without_rulesets_defaults_to_list_price(self, session: AsyncSession)",
      "summary": "When no rulesets exist, adjusted price should equal the listing price.",
      "layer": "test",
      "parent": "TestApplyListingMetricsValuationRules",
      "docstring": "When no rulesets exist, adjusted price should equal the listing price.",
      "category": "test"
    },
    {
      "name": "test_apply_listing_metrics_honors_static_override",
      "kind": "async_method",
      "path": "tests/test_listing_metrics.py",
      "line": 523,
      "signature": "async test_apply_listing_metrics_honors_static_override(self, session: AsyncSession)",
      "summary": "Static ruleset assignment should take precedence over dynamic matching.",
      "layer": "test",
      "parent": "TestApplyListingMetricsValuationRules",
      "docstring": "Static ruleset assignment should take precedence over dynamic matching.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_valuation_tasks.py",
      "line": 23,
      "signature": "async db_session()",
      "summary": "Provide an isolated in-memory database session for tasks tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tasks tests.",
      "category": "test"
    },
    {
      "name": "test_recalculate_listings_task_updates_adjusted_price",
      "kind": "async_function",
      "path": "tests/test_valuation_tasks.py",
      "line": 42,
      "signature": "async test_recalculate_listings_task_updates_adjusted_price(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Background task should recalculate adjusted prices for targeted listings.",
      "layer": "test",
      "docstring": "Background task should recalculate adjusted prices for targeted listings.",
      "category": "test"
    },
    {
      "name": "async_session",
      "kind": "async_function",
      "path": "tests/test_baseline_api.py",
      "line": 23,
      "signature": "async async_session()",
      "summary": "Create async database session for tests",
      "layer": "test",
      "docstring": "Create async database session for tests",
      "category": "test"
    },
    {
      "name": "client",
      "kind": "async_function",
      "path": "tests/test_baseline_api.py",
      "line": 37,
      "signature": "async client()",
      "summary": "Create async HTTP client for API tests",
      "layer": "test",
      "docstring": "Create async HTTP client for API tests",
      "category": "test"
    },
    {
      "name": "sample_baseline_json",
      "kind": "function",
      "path": "tests/test_baseline_api.py",
      "line": 44,
      "signature": "sample_baseline_json() -> dict[str, Any]",
      "summary": "Sample baseline JSON for testing",
      "layer": "test",
      "docstring": "Sample baseline JSON for testing",
      "category": "test"
    },
    {
      "name": "modified_baseline_json",
      "kind": "function",
      "path": "tests/test_baseline_api.py",
      "line": 102,
      "signature": "modified_baseline_json(sample_baseline_json: dict[str, Any]) -> dict[str, Any]",
      "summary": "Modified baseline JSON for diff testing",
      "layer": "test",
      "docstring": "Modified baseline JSON for diff testing",
      "category": "test"
    },
    {
      "name": "loaded_baseline",
      "kind": "async_function",
      "path": "tests/test_baseline_api.py",
      "line": 132,
      "signature": "async loaded_baseline(async_session: AsyncSession, sample_baseline_json: dict[str, Any]) -> ValuationRuleset",
      "summary": "Load baseline into database for testing",
      "layer": "test",
      "docstring": "Load baseline into database for testing",
      "category": "test"
    },
    {
      "name": "TestBaselineMetadata",
      "kind": "class",
      "path": "tests/test_baseline_api.py",
      "line": 152,
      "signature": "class TestBaselineMetadata",
      "summary": "Tests for GET /api/v1/baseline/meta endpoint",
      "layer": "test",
      "docstring": "Tests for GET /api/v1/baseline/meta endpoint",
      "category": "test"
    },
    {
      "name": "test_get_metadata_no_baseline",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 155,
      "signature": "async test_get_metadata_no_baseline(self, client: AsyncClient)",
      "summary": "Should return 404 when no baseline exists",
      "layer": "test",
      "parent": "TestBaselineMetadata",
      "docstring": "Should return 404 when no baseline exists",
      "category": "test"
    },
    {
      "name": "test_get_metadata_success",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 161,
      "signature": "async test_get_metadata_success(self, client: AsyncClient, loaded_baseline: ValuationRuleset)",
      "summary": "Should return baseline metadata successfully",
      "layer": "test",
      "parent": "TestBaselineMetadata",
      "docstring": "Should return baseline metadata successfully",
      "category": "test"
    },
    {
      "name": "TestBaselineInstantiate",
      "kind": "class",
      "path": "tests/test_baseline_api.py",
      "line": 187,
      "signature": "class TestBaselineInstantiate",
      "summary": "Tests for POST /api/v1/baseline/instantiate endpoint",
      "layer": "test",
      "docstring": "Tests for POST /api/v1/baseline/instantiate endpoint",
      "category": "test"
    },
    {
      "name": "test_instantiate_invalid_path",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 190,
      "signature": "async test_instantiate_invalid_path(self, client: AsyncClient)",
      "summary": "Should return 400 for non-existent file",
      "layer": "test",
      "parent": "TestBaselineInstantiate",
      "docstring": "Should return 400 for non-existent file",
      "category": "test"
    },
    {
      "name": "test_instantiate_success",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 202,
      "signature": "async test_instantiate_success(self, client: AsyncClient, async_session: AsyncSession, tmp_path: Path)",
      "summary": "Should create new baseline ruleset from file",
      "layer": "test",
      "parent": "TestBaselineInstantiate",
      "docstring": "Should create new baseline ruleset from file",
      "category": "test"
    },
    {
      "name": "test_instantiate_idempotent",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 245,
      "signature": "async test_instantiate_idempotent(self, client: AsyncClient, async_session: AsyncSession, loaded_baseline: ValuationRuleset, tmp_path: Path)",
      "summary": "Should return existing ruleset if hash matches (idempotent)",
      "layer": "test",
      "parent": "TestBaselineInstantiate",
      "docstring": "Should return existing ruleset if hash matches (idempotent)",
      "category": "test"
    },
    {
      "name": "TestBaselineDiff",
      "kind": "class",
      "path": "tests/test_baseline_api.py",
      "line": 288,
      "signature": "class TestBaselineDiff",
      "summary": "Tests for POST /api/v1/baseline/diff endpoint",
      "layer": "test",
      "docstring": "Tests for POST /api/v1/baseline/diff endpoint",
      "category": "test"
    },
    {
      "name": "test_diff_no_current_baseline",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 291,
      "signature": "async test_diff_no_current_baseline(self, client: AsyncClient, sample_baseline_json: dict[str, Any])",
      "summary": "Should work even without current baseline (all fields shown as added)",
      "layer": "test",
      "parent": "TestBaselineDiff",
      "docstring": "Should work even without current baseline (all fields shown as added)",
      "category": "test"
    },
    {
      "name": "test_diff_with_changes",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 309,
      "signature": "async test_diff_with_changes(self, client: AsyncClient, loaded_baseline: ValuationRuleset, modified_baseline_json: dict[str, Any])",
      "summary": "Should detect added, changed, and removed fields",
      "layer": "test",
      "parent": "TestBaselineDiff",
      "docstring": "Should detect added, changed, and removed fields",
      "category": "test"
    },
    {
      "name": "test_diff_no_changes",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 343,
      "signature": "async test_diff_no_changes(self, client: AsyncClient, loaded_baseline: ValuationRuleset, sample_baseline_json: dict[str, Any])",
      "summary": "Should detect no changes when baseline is identical",
      "layer": "test",
      "parent": "TestBaselineDiff",
      "docstring": "Should detect no changes when baseline is identical",
      "category": "test"
    },
    {
      "name": "TestBaselineAdopt",
      "kind": "class",
      "path": "tests/test_baseline_api.py",
      "line": 363,
      "signature": "class TestBaselineAdopt",
      "summary": "Tests for POST /api/v1/baseline/adopt endpoint",
      "layer": "test",
      "docstring": "Tests for POST /api/v1/baseline/adopt endpoint",
      "category": "test"
    },
    {
      "name": "test_adopt_all_changes",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 366,
      "signature": "async test_adopt_all_changes(self, client: AsyncClient, async_session: AsyncSession, loaded_baseline: ValuationRuleset, modified_baseline_json: dict[str, Any])",
      "summary": "Should adopt all changes and create new ruleset version",
      "layer": "test",
      "parent": "TestBaselineAdopt",
      "docstring": "Should adopt all changes and create new ruleset version",
      "category": "test"
    },
    {
      "name": "test_adopt_selected_changes",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 409,
      "signature": "async test_adopt_selected_changes(self, client: AsyncClient, async_session: AsyncSession, loaded_baseline: ValuationRuleset, modified_baseline_json: dict[str, Any])",
      "summary": "Should adopt only selected changes",
      "layer": "test",
      "parent": "TestBaselineAdopt",
      "docstring": "Should adopt only selected changes",
      "category": "test"
    },
    {
      "name": "test_adopt_with_recalculation",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 435,
      "signature": "async test_adopt_with_recalculation(self, client: AsyncClient, loaded_baseline: ValuationRuleset, modified_baseline_json: dict[str, Any])",
      "summary": "Should trigger recalculation when requested",
      "layer": "test",
      "parent": "TestBaselineAdopt",
      "docstring": "Should trigger recalculation when requested",
      "category": "test"
    },
    {
      "name": "TestBaselineWorkflow",
      "kind": "class",
      "path": "tests/test_baseline_api.py",
      "line": 460,
      "signature": "class TestBaselineWorkflow",
      "summary": "End-to-end baseline workflow tests",
      "layer": "test",
      "docstring": "End-to-end baseline workflow tests",
      "category": "test"
    },
    {
      "name": "test_full_baseline_lifecycle",
      "kind": "async_method",
      "path": "tests/test_baseline_api.py",
      "line": 463,
      "signature": "async test_full_baseline_lifecycle(self, client: AsyncClient, async_session: AsyncSession, tmp_path: Path)",
      "summary": "Test complete baseline workflow: instantiate -> diff -> adopt",
      "layer": "test",
      "parent": "TestBaselineWorkflow",
      "docstring": "Test complete baseline workflow: instantiate -> diff -> adopt",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 17,
      "signature": "async db_session()",
      "summary": "Create async database session for tests",
      "layer": "test",
      "docstring": "Create async database session for tests",
      "category": "test"
    },
    {
      "name": "client",
      "kind": "async_function",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 31,
      "signature": "async client()",
      "summary": "Create async HTTP client for API tests",
      "layer": "test",
      "docstring": "Create async HTTP client for API tests",
      "category": "test"
    },
    {
      "name": "TestRuleGroupBasicModeExtensions",
      "kind": "class",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 38,
      "signature": "class TestRuleGroupBasicModeExtensions",
      "summary": "Test rule group extensions for Basic mode support",
      "layer": "test",
      "docstring": "Test rule group extensions for Basic mode support",
      "category": "test"
    },
    {
      "name": "test_create_group_with_basic_managed_metadata",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 41,
      "signature": "async test_create_group_with_basic_managed_metadata(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test creating a rule group with basic_managed and entity_key",
      "layer": "test",
      "parent": "TestRuleGroupBasicModeExtensions",
      "docstring": "Test creating a rule group with basic_managed and entity_key",
      "category": "test"
    },
    {
      "name": "test_create_group_requires_entity_key_when_basic_managed",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 79,
      "signature": "async test_create_group_requires_entity_key_when_basic_managed(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that basic_managed groups require entity_key",
      "layer": "test",
      "parent": "TestRuleGroupBasicModeExtensions",
      "docstring": "Test that basic_managed groups require entity_key",
      "category": "test"
    },
    {
      "name": "test_invalid_entity_key_rejected",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 109,
      "signature": "async test_invalid_entity_key_rejected(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that invalid entity keys are rejected",
      "layer": "test",
      "parent": "TestRuleGroupBasicModeExtensions",
      "docstring": "Test that invalid entity keys are rejected",
      "category": "test"
    },
    {
      "name": "test_update_basic_managed_group_forbidden",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 139,
      "signature": "async test_update_basic_managed_group_forbidden(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that basic-managed groups cannot be manually updated",
      "layer": "test",
      "parent": "TestRuleGroupBasicModeExtensions",
      "docstring": "Test that basic-managed groups cannot be manually updated",
      "category": "test"
    },
    {
      "name": "test_list_groups_includes_basic_metadata",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 178,
      "signature": "async test_list_groups_includes_basic_metadata(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that listing groups includes basic_managed and entity_key",
      "layer": "test",
      "parent": "TestRuleGroupBasicModeExtensions",
      "docstring": "Test that listing groups includes basic_managed and entity_key",
      "category": "test"
    },
    {
      "name": "TestRuleModifiersExtensions",
      "kind": "class",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 234,
      "signature": "class TestRuleModifiersExtensions",
      "summary": "Test rule action modifiers extensions",
      "layer": "test",
      "docstring": "Test rule action modifiers extensions",
      "category": "test"
    },
    {
      "name": "test_create_rule_with_modifiers",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 237,
      "signature": "async test_create_rule_with_modifiers(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test creating a rule with modifiers_json",
      "layer": "test",
      "parent": "TestRuleModifiersExtensions",
      "docstring": "Test creating a rule with modifiers_json",
      "category": "test"
    },
    {
      "name": "test_validate_clamp_requires_min_or_max",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 291,
      "signature": "async test_validate_clamp_requires_min_or_max(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that clamp=true requires min_usd or max_usd",
      "layer": "test",
      "parent": "TestRuleModifiersExtensions",
      "docstring": "Test that clamp=true requires min_usd or max_usd",
      "category": "test"
    },
    {
      "name": "test_validate_min_max_ordering",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 335,
      "signature": "async test_validate_min_max_ordering(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that min_usd cannot be greater than max_usd",
      "layer": "test",
      "parent": "TestRuleModifiersExtensions",
      "docstring": "Test that min_usd cannot be greater than max_usd",
      "category": "test"
    },
    {
      "name": "test_cannot_modify_rules_in_basic_managed_group",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 380,
      "signature": "async test_cannot_modify_rules_in_basic_managed_group(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that rules in basic-managed groups cannot be manually modified",
      "layer": "test",
      "parent": "TestRuleModifiersExtensions",
      "docstring": "Test that rules in basic-managed groups cannot be manually modified",
      "category": "test"
    },
    {
      "name": "TestEntityKeyValidation",
      "kind": "class",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 438,
      "signature": "class TestEntityKeyValidation",
      "summary": "Test entity key validation",
      "layer": "test",
      "docstring": "Test entity key validation",
      "category": "test"
    },
    {
      "name": "test_all_valid_entity_keys",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 441,
      "signature": "async test_all_valid_entity_keys(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that all valid entity keys are accepted",
      "layer": "test",
      "parent": "TestEntityKeyValidation",
      "docstring": "Test that all valid entity keys are accepted",
      "category": "test"
    },
    {
      "name": "TestRulesetWithBasicManagedGroups",
      "kind": "class",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 470,
      "signature": "class TestRulesetWithBasicManagedGroups",
      "summary": "Test ruleset endpoints with basic-managed groups",
      "layer": "test",
      "docstring": "Test ruleset endpoints with basic-managed groups",
      "category": "test"
    },
    {
      "name": "test_get_ruleset_includes_basic_metadata",
      "kind": "async_method",
      "path": "tests/test_rules_basic_mode_extensions.py",
      "line": 473,
      "signature": "async test_get_ruleset_includes_basic_metadata(self, client: AsyncClient, db_session: AsyncSession)",
      "summary": "Test that getting a ruleset includes basic_managed and entity_key for groups",
      "layer": "test",
      "parent": "TestRulesetWithBasicManagedGroups",
      "docstring": "Test that getting a ruleset includes basic_managed and entity_key for groups",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 41,
      "signature": "async db_session()",
      "summary": "Create async database session for tests",
      "layer": "test",
      "docstring": "Create async database session for tests",
      "category": "test"
    },
    {
      "name": "sample_ruleset",
      "kind": "async_function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 60,
      "signature": "async sample_ruleset(db_session: AsyncSession) -> ValuationRuleset",
      "summary": "Create a sample ruleset with placeholder rules",
      "layer": "test",
      "docstring": "Create a sample ruleset with placeholder rules",
      "category": "test"
    },
    {
      "name": "sample_rule_group",
      "kind": "async_function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 76,
      "signature": "async sample_rule_group(db_session: AsyncSession, sample_ruleset: ValuationRuleset) -> ValuationRuleGroup",
      "summary": "Create a sample rule group",
      "layer": "test",
      "docstring": "Create a sample rule group",
      "category": "test"
    },
    {
      "name": "placeholder_rules",
      "kind": "async_function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 94,
      "signature": "async placeholder_rules(db_session: AsyncSession, sample_rule_group: ValuationRuleGroup) -> list[ValuationRuleV2]",
      "summary": "Create sample placeholder rules for testing",
      "layer": "test",
      "docstring": "Create sample placeholder rules for testing",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 160,
      "signature": "db_session()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "sample_ruleset",
      "kind": "function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 164,
      "signature": "sample_ruleset()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "sample_rule_group",
      "kind": "function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 168,
      "signature": "sample_rule_group()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "placeholder_rules",
      "kind": "function",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 172,
      "signature": "placeholder_rules()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "TestHydrateEndpoint",
      "kind": "class",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 179,
      "signature": "class TestHydrateEndpoint",
      "summary": "Tests for baseline hydration endpoint logic (via service layer)",
      "layer": "test",
      "docstring": "Tests for baseline hydration endpoint logic (via service layer)",
      "category": "test"
    },
    {
      "name": "test_hydrate_endpoint_success",
      "kind": "async_method",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 182,
      "signature": "async test_hydrate_endpoint_success(self, db_session: AsyncSession, sample_ruleset: ValuationRuleset, placeholder_rules: list[ValuationRuleV2])",
      "summary": "Test successful hydration of baseline rules",
      "layer": "test",
      "parent": "TestHydrateEndpoint",
      "docstring": "Test successful hydration of baseline rules",
      "category": "test"
    },
    {
      "name": "test_hydrate_invalid_ruleset",
      "kind": "async_method",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 243,
      "signature": "async test_hydrate_invalid_ruleset(self, db_session: AsyncSession)",
      "summary": "Test hydration with non-existent ruleset (endpoint would return 404)",
      "layer": "test",
      "parent": "TestHydrateEndpoint",
      "docstring": "Test hydration with non-existent ruleset (endpoint would return 404)",
      "category": "test"
    },
    {
      "name": "test_hydrate_already_hydrated",
      "kind": "async_method",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 259,
      "signature": "async test_hydrate_already_hydrated(self, db_session: AsyncSession, sample_ruleset: ValuationRuleset, placeholder_rules: list[ValuationRuleV2])",
      "summary": "Test idempotency - calling hydrate twice should not duplicate rules",
      "layer": "test",
      "parent": "TestHydrateEndpoint",
      "docstring": "Test idempotency - calling hydrate twice should not duplicate rules",
      "category": "test"
    },
    {
      "name": "test_hydrate_response_structure",
      "kind": "async_method",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 297,
      "signature": "async test_hydrate_response_structure(self, db_session: AsyncSession, sample_ruleset: ValuationRuleset, placeholder_rules: list[ValuationRuleV2])",
      "summary": "Test that response structure matches schema exactly",
      "layer": "test",
      "parent": "TestHydrateEndpoint",
      "docstring": "Test that response structure matches schema exactly",
      "category": "test"
    },
    {
      "name": "test_hydrate_default_actor",
      "kind": "async_method",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 336,
      "signature": "async test_hydrate_default_actor(self, db_session: AsyncSession, sample_ruleset: ValuationRuleset, placeholder_rules: list[ValuationRuleV2])",
      "summary": "Test that default actor 'system' is used when not provided",
      "layer": "test",
      "parent": "TestHydrateEndpoint",
      "docstring": "Test that default actor 'system' is used when not provided",
      "category": "test"
    },
    {
      "name": "test_hydrate_empty_ruleset",
      "kind": "async_method",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 355,
      "signature": "async test_hydrate_empty_ruleset(self, db_session: AsyncSession)",
      "summary": "Test hydration of ruleset with no placeholder rules",
      "layer": "test",
      "parent": "TestHydrateEndpoint",
      "docstring": "Test hydration of ruleset with no placeholder rules",
      "category": "test"
    },
    {
      "name": "TestHydrationWorkflow",
      "kind": "class",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 386,
      "signature": "class TestHydrationWorkflow",
      "summary": "End-to-end hydration workflow tests",
      "layer": "test",
      "docstring": "End-to-end hydration workflow tests",
      "category": "test"
    },
    {
      "name": "test_full_hydration_workflow",
      "kind": "async_method",
      "path": "tests/test_baseline_hydration_api.py",
      "line": 389,
      "signature": "async test_full_hydration_workflow(self, db_session: AsyncSession, sample_ruleset: ValuationRuleset, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test complete hydration workflow from creation to verification",
      "layer": "test",
      "parent": "TestHydrationWorkflow",
      "docstring": "Test complete hydration workflow from creation to verification",
      "category": "test"
    },
    {
      "name": "TestFieldMultipliers",
      "kind": "class",
      "path": "tests/test_action_multipliers.py",
      "line": 13,
      "signature": "class TestFieldMultipliers",
      "summary": "Test field-based multipliers functionality",
      "layer": "test",
      "docstring": "Test field-based multipliers functionality",
      "category": "test"
    },
    {
      "name": "test_single_field_multiplier_applied",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 16,
      "signature": "test_single_field_multiplier_applied(self)",
      "summary": "Test a single field multiplier is correctly applied",
      "layer": "test",
      "parent": "TestFieldMultipliers",
      "docstring": "Test a single field multiplier is correctly applied",
      "category": "test"
    },
    {
      "name": "test_multiple_field_multipliers_stacking",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 51,
      "signature": "test_multiple_field_multipliers_stacking(self)",
      "summary": "Test multiple field multipliers stack multiplicatively",
      "layer": "test",
      "parent": "TestFieldMultipliers",
      "docstring": "Test multiple field multipliers stack multiplicatively",
      "category": "test"
    },
    {
      "name": "test_field_multiplier_case_insensitive",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 95,
      "signature": "test_field_multiplier_case_insensitive(self)",
      "summary": "Test field multipliers work with different cases",
      "layer": "test",
      "parent": "TestFieldMultipliers",
      "docstring": "Test field multipliers work with different cases",
      "category": "test"
    },
    {
      "name": "test_missing_field_graceful_handling",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 120,
      "signature": "test_missing_field_graceful_handling(self)",
      "summary": "Test graceful handling when field doesn't exist",
      "layer": "test",
      "parent": "TestFieldMultipliers",
      "docstring": "Test graceful handling when field doesn't exist",
      "category": "test"
    },
    {
      "name": "test_no_matching_condition_returns_base_value",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 141,
      "signature": "test_no_matching_condition_returns_base_value(self)",
      "summary": "Test that unmatched conditions don't apply any multiplier",
      "layer": "test",
      "parent": "TestFieldMultipliers",
      "docstring": "Test that unmatched conditions don't apply any multiplier",
      "category": "test"
    },
    {
      "name": "TestConditionMultipliers",
      "kind": "class",
      "path": "tests/test_action_multipliers.py",
      "line": 166,
      "signature": "class TestConditionMultipliers",
      "summary": "Test condition multipliers (bug fix verification)",
      "layer": "test",
      "docstring": "Test condition multipliers (bug fix verification)",
      "category": "test"
    },
    {
      "name": "test_condition_multiplier_fixed",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 169,
      "signature": "test_condition_multiplier_fixed(self)",
      "summary": "Test condition multipliers work without 'condition_' prefix",
      "layer": "test",
      "parent": "TestConditionMultipliers",
      "docstring": "Test condition multipliers work without 'condition_' prefix",
      "category": "test"
    },
    {
      "name": "test_condition_multiplier_case_insensitive",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 198,
      "signature": "test_condition_multiplier_case_insensitive(self)",
      "summary": "Test condition multipliers work with different cases",
      "layer": "test",
      "parent": "TestConditionMultipliers",
      "docstring": "Test condition multipliers work with different cases",
      "category": "test"
    },
    {
      "name": "TestCombinedMultipliers",
      "kind": "class",
      "path": "tests/test_action_multipliers.py",
      "line": 213,
      "signature": "class TestCombinedMultipliers",
      "summary": "Test combinations of different multiplier types",
      "layer": "test",
      "docstring": "Test combinations of different multiplier types",
      "category": "test"
    },
    {
      "name": "test_field_and_condition_multipliers_stack",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 216,
      "signature": "test_field_and_condition_multipliers_stack(self)",
      "summary": "Test field and condition multipliers work together",
      "layer": "test",
      "parent": "TestCombinedMultipliers",
      "docstring": "Test field and condition multipliers work together",
      "category": "test"
    },
    {
      "name": "test_field_condition_age_multipliers_stack",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 256,
      "signature": "test_field_condition_age_multipliers_stack(self)",
      "summary": "Test field, condition, and age multipliers stack in correct order",
      "layer": "test",
      "parent": "TestCombinedMultipliers",
      "docstring": "Test field, condition, and age multipliers stack in correct order",
      "category": "test"
    },
    {
      "name": "test_field_condition_brand_multipliers_stack",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 284,
      "signature": "test_field_condition_brand_multipliers_stack(self)",
      "summary": "Test field, condition, and brand multipliers stack correctly",
      "layer": "test",
      "parent": "TestCombinedMultipliers",
      "docstring": "Test field, condition, and brand multipliers stack correctly",
      "category": "test"
    },
    {
      "name": "TestEdgeCases",
      "kind": "class",
      "path": "tests/test_action_multipliers.py",
      "line": 312,
      "signature": "class TestEdgeCases",
      "summary": "Test edge cases and error handling",
      "layer": "test",
      "docstring": "Test edge cases and error handling",
      "category": "test"
    },
    {
      "name": "test_empty_multipliers_array",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 315,
      "signature": "test_empty_multipliers_array(self)",
      "summary": "Test empty multipliers array doesn't cause errors",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test empty multipliers array doesn't cause errors",
      "category": "test"
    },
    {
      "name": "test_invalid_multiplier_config_skipped",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 327,
      "signature": "test_invalid_multiplier_config_skipped(self)",
      "summary": "Test invalid multiplier configs are gracefully skipped",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test invalid multiplier configs are gracefully skipped",
      "category": "test"
    },
    {
      "name": "test_invalid_conditions_not_list",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 349,
      "signature": "test_invalid_conditions_not_list(self)",
      "summary": "Test invalid conditions (not a list) are handled gracefully",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test invalid conditions (not a list) are handled gracefully",
      "category": "test"
    },
    {
      "name": "test_condition_without_value_skipped",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 369,
      "signature": "test_condition_without_value_skipped(self)",
      "summary": "Test conditions without 'value' key are skipped",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test conditions without 'value' key are skipped",
      "category": "test"
    },
    {
      "name": "test_multiplier_default_to_one",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 392,
      "signature": "test_multiplier_default_to_one(self)",
      "summary": "Test missing 'multiplier' value defaults to 1.0",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test missing 'multiplier' value defaults to 1.0",
      "category": "test"
    },
    {
      "name": "test_nested_field_path_with_none_values",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 412,
      "signature": "test_nested_field_path_with_none_values(self)",
      "summary": "Test deeply nested field paths with None intermediate values",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test deeply nested field paths with None intermediate values",
      "category": "test"
    },
    {
      "name": "test_no_modifiers_returns_base_value",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 433,
      "signature": "test_no_modifiers_returns_base_value(self)",
      "summary": "Test action without any modifiers returns base value",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test action without any modifiers returns base value",
      "category": "test"
    },
    {
      "name": "TestMultiplierOrdering",
      "kind": "class",
      "path": "tests/test_action_multipliers.py",
      "line": 446,
      "signature": "class TestMultiplierOrdering",
      "summary": "Test multipliers are applied in the correct order",
      "layer": "test",
      "docstring": "Test multipliers are applied in the correct order",
      "category": "test"
    },
    {
      "name": "test_multiplier_application_order",
      "kind": "method",
      "path": "tests/test_action_multipliers.py",
      "line": 449,
      "signature": "test_multiplier_application_order(self)",
      "summary": "Test multipliers are applied in order:",
      "layer": "test",
      "parent": "TestMultiplierOrdering",
      "docstring": "Test multipliers are applied in order:\n1. Field multipliers\n2. Condition multipliers\n3. Age depreciation\n4. Brand multipliers",
      "category": "test"
    },
    {
      "name": "test_ram_valuation_with_generation_and_condition",
      "kind": "function",
      "path": "tests/test_action_multipliers_integration.py",
      "line": 9,
      "signature": "test_ram_valuation_with_generation_and_condition()",
      "summary": "Real-world scenario: RAM valuation with:",
      "layer": "test",
      "docstring": "Real-world scenario: RAM valuation with:\n- DDR generation multiplier (DDR3 is worth less)\n- Condition multiplier (used condition reduces value)",
      "category": "test"
    },
    {
      "name": "test_storage_valuation_with_type_and_age",
      "kind": "function",
      "path": "tests/test_action_multipliers_integration.py",
      "line": 67,
      "signature": "test_storage_valuation_with_type_and_age()",
      "summary": "Real-world scenario: Storage valuation with:",
      "layer": "test",
      "docstring": "Real-world scenario: Storage valuation with:\n- Storage type multiplier (HDD worth less than SSD)\n- Age depreciation (older drives worth less)",
      "category": "test"
    },
    {
      "name": "test_complete_pc_valuation",
      "kind": "function",
      "path": "tests/test_action_multipliers_integration.py",
      "line": 105,
      "signature": "test_complete_pc_valuation()",
      "summary": "Real-world scenario: Complete PC with multiple components and multipliers.",
      "layer": "test",
      "docstring": "Real-world scenario: Complete PC with multiple components and multipliers.",
      "category": "test"
    },
    {
      "name": "test_frontend_payload_format",
      "kind": "function",
      "path": "tests/test_action_multipliers_integration.py",
      "line": 141,
      "signature": "test_frontend_payload_format()",
      "summary": "Test with exact payload format that would come from the frontend.",
      "layer": "test",
      "docstring": "Test with exact payload format that would come from the frontend.\nThis ensures compatibility with the UI.",
      "category": "test"
    },
    {
      "name": "TestFallbackChain",
      "kind": "class",
      "path": "tests/test_adapter_fallback.py",
      "line": 17,
      "signature": "class TestFallbackChain",
      "summary": "Test fallback mechanism when primary adapter fails.",
      "layer": "test",
      "docstring": "Test fallback mechanism when primary adapter fails.",
      "category": "test"
    },
    {
      "name": "test_ebay_url_falls_back_to_jsonld_when_no_api_key",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 21,
      "signature": "async test_ebay_url_falls_back_to_jsonld_when_no_api_key(self)",
      "summary": "Test eBay URL uses JSON-LD when API key is missing.",
      "layer": "test",
      "parent": "TestFallbackChain",
      "docstring": "Test eBay URL uses JSON-LD when API key is missing.",
      "category": "test"
    },
    {
      "name": "test_fallback_chain_logs_attempts",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 53,
      "signature": "async test_fallback_chain_logs_attempts(self, caplog)",
      "summary": "Test that fallback attempts are logged.",
      "layer": "test",
      "parent": "TestFallbackChain",
      "docstring": "Test that fallback attempts are logged.",
      "category": "test"
    },
    {
      "name": "test_fast_fail_for_item_not_found",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 88,
      "signature": "async test_fast_fail_for_item_not_found(self)",
      "summary": "Test that ITEM_NOT_FOUND errors don't trigger fallback.",
      "layer": "test",
      "parent": "TestFallbackChain",
      "docstring": "Test that ITEM_NOT_FOUND errors don't trigger fallback.",
      "category": "test"
    },
    {
      "name": "test_fast_fail_for_disabled_adapter",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 118,
      "signature": "async test_fast_fail_for_disabled_adapter(self)",
      "summary": "Test that ADAPTER_DISABLED errors don't trigger fallback.",
      "layer": "test",
      "parent": "TestFallbackChain",
      "docstring": "Test that ADAPTER_DISABLED errors don't trigger fallback.",
      "category": "test"
    },
    {
      "name": "test_all_adapters_failed_error",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 135,
      "signature": "async test_all_adapters_failed_error(self)",
      "summary": "Test that ALL_ADAPTERS_FAILED is raised when all adapters fail.",
      "layer": "test",
      "parent": "TestFallbackChain",
      "docstring": "Test that ALL_ADAPTERS_FAILED is raised when all adapters fail.",
      "category": "test"
    },
    {
      "name": "TestPriorityOrdering",
      "kind": "class",
      "path": "tests/test_adapter_fallback.py",
      "line": 171,
      "signature": "class TestPriorityOrdering",
      "summary": "Test that adapters are tried in correct priority order.",
      "layer": "test",
      "docstring": "Test that adapters are tried in correct priority order.",
      "category": "test"
    },
    {
      "name": "test_higher_priority_adapter_tried_first",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 175,
      "signature": "async test_higher_priority_adapter_tried_first(self)",
      "summary": "Test that EbayAdapter (priority 1) is tried before JsonLdAdapter (priority 5).",
      "layer": "test",
      "parent": "TestPriorityOrdering",
      "docstring": "Test that EbayAdapter (priority 1) is tried before JsonLdAdapter (priority 5).",
      "category": "test"
    },
    {
      "name": "test_fallback_stops_at_first_success",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 212,
      "signature": "async test_fallback_stops_at_first_success(self)",
      "summary": "Test that fallback stops after first successful adapter.",
      "layer": "test",
      "parent": "TestPriorityOrdering",
      "docstring": "Test that fallback stops after first successful adapter.",
      "category": "test"
    },
    {
      "name": "TestErrorPropagation",
      "kind": "class",
      "path": "tests/test_adapter_fallback.py",
      "line": 239,
      "signature": "class TestErrorPropagation",
      "summary": "Test that different error types are handled correctly.",
      "layer": "test",
      "docstring": "Test that different error types are handled correctly.",
      "category": "test"
    },
    {
      "name": "test_timeout_error_triggers_fallback",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 243,
      "signature": "async test_timeout_error_triggers_fallback(self)",
      "summary": "Test that TIMEOUT errors trigger fallback to next adapter.",
      "layer": "test",
      "parent": "TestErrorPropagation",
      "docstring": "Test that TIMEOUT errors trigger fallback to next adapter.",
      "category": "test"
    },
    {
      "name": "test_network_error_triggers_fallback",
      "kind": "async_method",
      "path": "tests/test_adapter_fallback.py",
      "line": 282,
      "signature": "async test_network_error_triggers_fallback(self)",
      "summary": "Test that NETWORK_ERROR errors trigger fallback.",
      "layer": "test",
      "parent": "TestErrorPropagation",
      "docstring": "Test that NETWORK_ERROR errors trigger fallback.",
      "category": "test"
    },
    {
      "name": "TestBackwardCompatibility",
      "kind": "class",
      "path": "tests/test_adapter_fallback.py",
      "line": 321,
      "signature": "class TestBackwardCompatibility",
      "summary": "Test that existing select_adapter() method still works.",
      "layer": "test",
      "docstring": "Test that existing select_adapter() method still works.",
      "category": "test"
    },
    {
      "name": "test_select_adapter_still_works",
      "kind": "method",
      "path": "tests/test_adapter_fallback.py",
      "line": 324,
      "signature": "test_select_adapter_still_works(self)",
      "summary": "Test that select_adapter() method is preserved.",
      "layer": "test",
      "parent": "TestBackwardCompatibility",
      "docstring": "Test that select_adapter() method is preserved.",
      "category": "test"
    },
    {
      "name": "test_select_adapter_respects_priority",
      "kind": "method",
      "path": "tests/test_adapter_fallback.py",
      "line": 339,
      "signature": "test_select_adapter_respects_priority(self)",
      "summary": "Test that select_adapter() returns highest priority adapter.",
      "layer": "test",
      "parent": "TestBackwardCompatibility",
      "docstring": "Test that select_adapter() returns highest priority adapter.",
      "category": "test"
    },
    {
      "name": "TestDomainExtraction",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 16,
      "signature": "class TestDomainExtraction",
      "summary": "Test domain extraction from URLs.",
      "layer": "test",
      "docstring": "Test domain extraction from URLs.",
      "category": "test"
    },
    {
      "name": "test_extract_domain_with_www",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 19,
      "signature": "test_extract_domain_with_www(self)",
      "summary": "Test extracting domain from URL with www prefix.",
      "layer": "test",
      "parent": "TestDomainExtraction",
      "docstring": "Test extracting domain from URL with www prefix.",
      "category": "test"
    },
    {
      "name": "test_extract_domain_without_www",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 24,
      "signature": "test_extract_domain_without_www(self)",
      "summary": "Test extracting domain from URL without www.",
      "layer": "test",
      "parent": "TestDomainExtraction",
      "docstring": "Test extracting domain from URL without www.",
      "category": "test"
    },
    {
      "name": "test_extract_domain_with_m",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 29,
      "signature": "test_extract_domain_with_m(self)",
      "summary": "Test extracting domain from mobile URL.",
      "layer": "test",
      "parent": "TestDomainExtraction",
      "docstring": "Test extracting domain from mobile URL.",
      "category": "test"
    },
    {
      "name": "test_extract_domain_different_tld",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 34,
      "signature": "test_extract_domain_different_tld(self)",
      "summary": "Test extracting domain with different TLD.",
      "layer": "test",
      "parent": "TestDomainExtraction",
      "docstring": "Test extracting domain with different TLD.",
      "category": "test"
    },
    {
      "name": "test_extract_domain_with_path",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 40,
      "signature": "test_extract_domain_with_path(self)",
      "summary": "Test extracting domain from URL with complex path.",
      "layer": "test",
      "parent": "TestDomainExtraction",
      "docstring": "Test extracting domain from URL with complex path.",
      "category": "test"
    },
    {
      "name": "test_extract_domain_invalid_url",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 48,
      "signature": "test_extract_domain_invalid_url(self)",
      "summary": "Test error handling for invalid URL.",
      "layer": "test",
      "parent": "TestDomainExtraction",
      "docstring": "Test error handling for invalid URL.",
      "category": "test"
    },
    {
      "name": "TestDomainMatching",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 55,
      "signature": "class TestDomainMatching",
      "summary": "Test domain matching logic.",
      "layer": "test",
      "docstring": "Test domain matching logic.",
      "category": "test"
    },
    {
      "name": "test_wildcard_domain_matching",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 58,
      "signature": "test_wildcard_domain_matching(self)",
      "summary": "Test wildcard matches any domain.",
      "layer": "test",
      "parent": "TestDomainMatching",
      "docstring": "Test wildcard matches any domain.",
      "category": "test"
    },
    {
      "name": "test_exact_domain_matching",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 66,
      "signature": "test_exact_domain_matching(self)",
      "summary": "Test exact domain matching.",
      "layer": "test",
      "parent": "TestDomainMatching",
      "docstring": "Test exact domain matching.",
      "category": "test"
    },
    {
      "name": "test_domain_matching_with_www_in_adapter_list",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 79,
      "signature": "test_domain_matching_with_www_in_adapter_list(self)",
      "summary": "Test domain matching when adapter list includes www.",
      "layer": "test",
      "parent": "TestDomainMatching",
      "docstring": "Test domain matching when adapter list includes www.",
      "category": "test"
    },
    {
      "name": "test_domain_matching_multiple_adapter_domains",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 89,
      "signature": "test_domain_matching_multiple_adapter_domains(self)",
      "summary": "Test matching against multiple adapter domains.",
      "layer": "test",
      "parent": "TestDomainMatching",
      "docstring": "Test matching against multiple adapter domains.",
      "category": "test"
    },
    {
      "name": "TestAdapterSelection",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 103,
      "signature": "class TestAdapterSelection",
      "summary": "Test adapter selection by domain.",
      "layer": "test",
      "docstring": "Test adapter selection by domain.",
      "category": "test"
    },
    {
      "name": "test_select_ebay_adapter_for_ebay_url",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 107,
      "signature": "test_select_ebay_adapter_for_ebay_url(self)",
      "summary": "Test eBay adapter is selected for eBay URLs.",
      "layer": "test",
      "parent": "TestAdapterSelection",
      "docstring": "Test eBay adapter is selected for eBay URLs.",
      "category": "test"
    },
    {
      "name": "test_select_ebay_adapter_for_ebay_url_without_www",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 116,
      "signature": "test_select_ebay_adapter_for_ebay_url_without_www(self)",
      "summary": "Test eBay adapter is selected for eBay URLs without www.",
      "layer": "test",
      "parent": "TestAdapterSelection",
      "docstring": "Test eBay adapter is selected for eBay URLs without www.",
      "category": "test"
    },
    {
      "name": "test_select_jsonld_adapter_for_generic_url",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 124,
      "signature": "test_select_jsonld_adapter_for_generic_url(self)",
      "summary": "Test JSON-LD adapter is selected for generic URLs.",
      "layer": "test",
      "parent": "TestAdapterSelection",
      "docstring": "Test JSON-LD adapter is selected for generic URLs.",
      "category": "test"
    },
    {
      "name": "test_select_jsonld_adapter_for_amazon_url",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 132,
      "signature": "test_select_jsonld_adapter_for_amazon_url(self)",
      "summary": "Test JSON-LD adapter is selected for Amazon URLs (no Amazon adapter yet).",
      "layer": "test",
      "parent": "TestAdapterSelection",
      "docstring": "Test JSON-LD adapter is selected for Amazon URLs (no Amazon adapter yet).",
      "category": "test"
    },
    {
      "name": "TestPrioritySelection",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 141,
      "signature": "class TestPrioritySelection",
      "summary": "Test priority-based adapter selection.",
      "layer": "test",
      "docstring": "Test priority-based adapter selection.",
      "category": "test"
    },
    {
      "name": "test_priority_ebay_over_jsonld",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 145,
      "signature": "test_priority_ebay_over_jsonld(self)",
      "summary": "Test eBay adapter (priority 1) beats JSON-LD (priority 5) for eBay URLs.",
      "layer": "test",
      "parent": "TestPrioritySelection",
      "docstring": "Test eBay adapter (priority 1) beats JSON-LD (priority 5) for eBay URLs.",
      "category": "test"
    },
    {
      "name": "test_jsonld_selected_when_no_higher_priority",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 156,
      "signature": "test_jsonld_selected_when_no_higher_priority(self)",
      "summary": "Test JSON-LD adapter is selected when no higher priority adapter matches.",
      "layer": "test",
      "parent": "TestPrioritySelection",
      "docstring": "Test JSON-LD adapter is selected when no higher priority adapter matches.",
      "category": "test"
    },
    {
      "name": "TestSettingsIntegration",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 166,
      "signature": "class TestSettingsIntegration",
      "summary": "Test settings integration for adapter enabled status.",
      "layer": "test",
      "docstring": "Test settings integration for adapter enabled status.",
      "category": "test"
    },
    {
      "name": "test_disabled_ebay_adapter_raises_error",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 169,
      "signature": "test_disabled_ebay_adapter_raises_error(self)",
      "summary": "Test that disabled eBay adapter raises AdapterDisabledError.",
      "layer": "test",
      "parent": "TestSettingsIntegration",
      "docstring": "Test that disabled eBay adapter raises AdapterDisabledError.",
      "category": "test"
    },
    {
      "name": "test_disabled_ebay_falls_back_to_jsonld",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 184,
      "signature": "test_disabled_ebay_falls_back_to_jsonld(self)",
      "summary": "Test that disabling eBay adapter falls back to JSON-LD for eBay URLs.",
      "layer": "test",
      "parent": "TestSettingsIntegration",
      "docstring": "Test that disabling eBay adapter falls back to JSON-LD for eBay URLs.",
      "category": "test"
    },
    {
      "name": "test_all_adapters_enabled_by_default",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 201,
      "signature": "test_all_adapters_enabled_by_default(self)",
      "summary": "Test that adapters are enabled by default.",
      "layer": "test",
      "parent": "TestSettingsIntegration",
      "docstring": "Test that adapters are enabled by default.",
      "category": "test"
    },
    {
      "name": "test_is_adapter_enabled_checks_settings",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 210,
      "signature": "test_is_adapter_enabled_checks_settings(self)",
      "summary": "Test _is_adapter_enabled checks correct settings attribute.",
      "layer": "test",
      "parent": "TestSettingsIntegration",
      "docstring": "Test _is_adapter_enabled checks correct settings attribute.",
      "category": "test"
    },
    {
      "name": "TestErrorHandling",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 224,
      "signature": "class TestErrorHandling",
      "summary": "Test error handling for edge cases.",
      "layer": "test",
      "docstring": "Test error handling for edge cases.",
      "category": "test"
    },
    {
      "name": "test_no_adapter_found_empty_registry",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 227,
      "signature": "test_no_adapter_found_empty_registry(self)",
      "summary": "Test error when no adapter matches (empty registry).",
      "layer": "test",
      "parent": "TestErrorHandling",
      "docstring": "Test error when no adapter matches (empty registry).",
      "category": "test"
    },
    {
      "name": "test_invalid_url_format",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 238,
      "signature": "test_invalid_url_format(self)",
      "summary": "Test handling of malformed URLs.",
      "layer": "test",
      "parent": "TestErrorHandling",
      "docstring": "Test handling of malformed URLs.",
      "category": "test"
    },
    {
      "name": "test_url_without_scheme",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 248,
      "signature": "test_url_without_scheme(self)",
      "summary": "Test handling of URL without scheme.",
      "layer": "test",
      "parent": "TestErrorHandling",
      "docstring": "Test handling of URL without scheme.",
      "category": "test"
    },
    {
      "name": "test_empty_url",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 257,
      "signature": "test_empty_url(self)",
      "summary": "Test handling of empty URL.",
      "layer": "test",
      "parent": "TestErrorHandling",
      "docstring": "Test handling of empty URL.",
      "category": "test"
    },
    {
      "name": "TestConvenienceExtractMethod",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 267,
      "signature": "class TestConvenienceExtractMethod",
      "summary": "Test router.extract() convenience method.",
      "layer": "test",
      "docstring": "Test router.extract() convenience method.",
      "category": "test"
    },
    {
      "name": "test_router_extract_convenience_ebay",
      "kind": "async_method",
      "path": "tests/test_adapter_router.py",
      "line": 272,
      "signature": "async test_router_extract_convenience_ebay(self)",
      "summary": "Test router.extract() selects eBay adapter and calls extract.",
      "layer": "test",
      "parent": "TestConvenienceExtractMethod",
      "docstring": "Test router.extract() selects eBay adapter and calls extract.",
      "category": "test"
    },
    {
      "name": "test_router_extract_convenience_jsonld",
      "kind": "async_method",
      "path": "tests/test_adapter_router.py",
      "line": 296,
      "signature": "async test_router_extract_convenience_jsonld(self)",
      "summary": "Test router.extract() selects JSON-LD adapter and calls extract.",
      "layer": "test",
      "parent": "TestConvenienceExtractMethod",
      "docstring": "Test router.extract() selects JSON-LD adapter and calls extract.",
      "category": "test"
    },
    {
      "name": "test_router_extract_propagates_adapter_errors",
      "kind": "async_method",
      "path": "tests/test_adapter_router.py",
      "line": 320,
      "signature": "async test_router_extract_propagates_adapter_errors(self)",
      "summary": "Test router.extract() propagates adapter extraction errors.",
      "layer": "test",
      "parent": "TestConvenienceExtractMethod",
      "docstring": "Test router.extract() propagates adapter extraction errors.",
      "category": "test"
    },
    {
      "name": "TestFindMatchingAdapters",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 337,
      "signature": "class TestFindMatchingAdapters",
      "summary": "Test _find_matching_adapters method.",
      "layer": "test",
      "docstring": "Test _find_matching_adapters method.",
      "category": "test"
    },
    {
      "name": "test_find_matching_adapters_ebay",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 340,
      "signature": "test_find_matching_adapters_ebay(self)",
      "summary": "Test finding matching adapters for eBay URL.",
      "layer": "test",
      "parent": "TestFindMatchingAdapters",
      "docstring": "Test finding matching adapters for eBay URL.",
      "category": "test"
    },
    {
      "name": "test_find_matching_adapters_generic",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 351,
      "signature": "test_find_matching_adapters_generic(self)",
      "summary": "Test finding matching adapters for generic URL.",
      "layer": "test",
      "parent": "TestFindMatchingAdapters",
      "docstring": "Test finding matching adapters for generic URL.",
      "category": "test"
    },
    {
      "name": "test_matching_adapters_sorted_by_priority",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 364,
      "signature": "test_matching_adapters_sorted_by_priority(self)",
      "summary": "Test that matching adapters can be sorted by priority.",
      "layer": "test",
      "parent": "TestFindMatchingAdapters",
      "docstring": "Test that matching adapters can be sorted by priority.",
      "category": "test"
    },
    {
      "name": "TestRouterInitialization",
      "kind": "class",
      "path": "tests/test_adapter_router.py",
      "line": 382,
      "signature": "class TestRouterInitialization",
      "summary": "Test router initialization.",
      "layer": "test",
      "docstring": "Test router initialization.",
      "category": "test"
    },
    {
      "name": "test_router_initializes_with_adapters",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 385,
      "signature": "test_router_initializes_with_adapters(self)",
      "summary": "Test router initializes with available adapters.",
      "layer": "test",
      "parent": "TestRouterInitialization",
      "docstring": "Test router initializes with available adapters.",
      "category": "test"
    },
    {
      "name": "test_router_adapters_list_not_empty",
      "kind": "method",
      "path": "tests/test_adapter_router.py",
      "line": 394,
      "signature": "test_router_adapters_list_not_empty(self)",
      "summary": "Test router has non-empty adapters list.",
      "layer": "test",
      "parent": "TestRouterInitialization",
      "docstring": "Test router has non-empty adapters list.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_deduplication_service.py",
      "line": 27,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "TestHashGeneration",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 46,
      "signature": "class TestHashGeneration",
      "summary": "Tests for hash generation and normalization.",
      "layer": "test",
      "docstring": "Tests for hash generation and normalization.",
      "category": "test"
    },
    {
      "name": "test_generate_hash_consistency",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 49,
      "signature": "test_generate_hash_consistency(self, db_session: AsyncSession)",
      "summary": "Test that same input always produces same hash.",
      "layer": "test",
      "parent": "TestHashGeneration",
      "docstring": "Test that same input always produces same hash.",
      "category": "test"
    },
    {
      "name": "test_generate_hash_case_insensitive",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 75,
      "signature": "test_generate_hash_case_insensitive(self, db_session: AsyncSession)",
      "summary": "Test that case doesn't affect hash.",
      "layer": "test",
      "parent": "TestHashGeneration",
      "docstring": "Test that case doesn't affect hash.",
      "category": "test"
    },
    {
      "name": "test_generate_hash_whitespace_normalized",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 100,
      "signature": "test_generate_hash_whitespace_normalized(self, db_session: AsyncSession)",
      "summary": "Test that extra whitespace doesn't affect hash.",
      "layer": "test",
      "parent": "TestHashGeneration",
      "docstring": "Test that extra whitespace doesn't affect hash.",
      "category": "test"
    },
    {
      "name": "test_generate_hash_punctuation_normalized",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 125,
      "signature": "test_generate_hash_punctuation_normalized(self, db_session: AsyncSession)",
      "summary": "Test that punctuation is removed consistently.",
      "layer": "test",
      "parent": "TestHashGeneration",
      "docstring": "Test that punctuation is removed consistently.",
      "category": "test"
    },
    {
      "name": "test_generate_hash_different_data",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 165,
      "signature": "test_generate_hash_different_data(self, db_session: AsyncSession)",
      "summary": "Test that different data produces different hashes.",
      "layer": "test",
      "parent": "TestHashGeneration",
      "docstring": "Test that different data produces different hashes.",
      "category": "test"
    },
    {
      "name": "test_generate_hash_null_seller",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 190,
      "signature": "test_generate_hash_null_seller(self, db_session: AsyncSession)",
      "summary": "Test hash generation with null seller.",
      "layer": "test",
      "parent": "TestHashGeneration",
      "docstring": "Test hash generation with null seller.",
      "category": "test"
    },
    {
      "name": "TestTextNormalization",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 217,
      "signature": "class TestTextNormalization",
      "summary": "Tests for text normalization.",
      "layer": "test",
      "docstring": "Tests for text normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_text_lowercase",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 220,
      "signature": "test_normalize_text_lowercase(self, db_session: AsyncSession)",
      "summary": "Test lowercase conversion.",
      "layer": "test",
      "parent": "TestTextNormalization",
      "docstring": "Test lowercase conversion.",
      "category": "test"
    },
    {
      "name": "test_normalize_text_whitespace",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 228,
      "signature": "test_normalize_text_whitespace(self, db_session: AsyncSession)",
      "summary": "Test whitespace normalization.",
      "layer": "test",
      "parent": "TestTextNormalization",
      "docstring": "Test whitespace normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_text_punctuation",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 236,
      "signature": "test_normalize_text_punctuation(self, db_session: AsyncSession)",
      "summary": "Test punctuation removal.",
      "layer": "test",
      "parent": "TestTextNormalization",
      "docstring": "Test punctuation removal.",
      "category": "test"
    },
    {
      "name": "test_normalize_text_empty",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 245,
      "signature": "test_normalize_text_empty(self, db_session: AsyncSession)",
      "summary": "Test empty string normalization.",
      "layer": "test",
      "parent": "TestTextNormalization",
      "docstring": "Test empty string normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_text_unicode",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 252,
      "signature": "test_normalize_text_unicode(self, db_session: AsyncSession)",
      "summary": "Test unicode character handling.",
      "layer": "test",
      "parent": "TestTextNormalization",
      "docstring": "Test unicode character handling.",
      "category": "test"
    },
    {
      "name": "TestPriceNormalization",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 261,
      "signature": "class TestPriceNormalization",
      "summary": "Tests for price normalization.",
      "layer": "test",
      "docstring": "Tests for price normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_price_two_decimals",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 264,
      "signature": "test_normalize_price_two_decimals(self, db_session: AsyncSession)",
      "summary": "Test price with 2 decimals.",
      "layer": "test",
      "parent": "TestPriceNormalization",
      "docstring": "Test price with 2 decimals.",
      "category": "test"
    },
    {
      "name": "test_normalize_price_one_decimal",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 271,
      "signature": "test_normalize_price_one_decimal(self, db_session: AsyncSession)",
      "summary": "Test price with 1 decimal (should pad to 2).",
      "layer": "test",
      "parent": "TestPriceNormalization",
      "docstring": "Test price with 1 decimal (should pad to 2).",
      "category": "test"
    },
    {
      "name": "test_normalize_price_no_decimals",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 278,
      "signature": "test_normalize_price_no_decimals(self, db_session: AsyncSession)",
      "summary": "Test price with no decimals (should add .00).",
      "layer": "test",
      "parent": "TestPriceNormalization",
      "docstring": "Test price with no decimals (should add .00).",
      "category": "test"
    },
    {
      "name": "test_normalize_price_many_decimals",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 285,
      "signature": "test_normalize_price_many_decimals(self, db_session: AsyncSession)",
      "summary": "Test price with many decimals (should round to 2).",
      "layer": "test",
      "parent": "TestPriceNormalization",
      "docstring": "Test price with many decimals (should round to 2).",
      "category": "test"
    },
    {
      "name": "TestVendorIDDeduplication",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 294,
      "signature": "class TestVendorIDDeduplication",
      "summary": "Tests for vendor ID-based deduplication.",
      "layer": "test",
      "docstring": "Tests for vendor ID-based deduplication.",
      "category": "test"
    },
    {
      "name": "test_find_existing_by_vendor_id",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 297,
      "signature": "async test_find_existing_by_vendor_id(self, db_session: AsyncSession)",
      "summary": "Test finding existing listing by vendor_item_id + marketplace.",
      "layer": "test",
      "parent": "TestVendorIDDeduplication",
      "docstring": "Test finding existing listing by vendor_item_id + marketplace.",
      "category": "test"
    },
    {
      "name": "test_vendor_id_no_match_different_id",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 329,
      "signature": "async test_vendor_id_no_match_different_id(self, db_session: AsyncSession)",
      "summary": "Test vendor ID mismatch (different item ID).",
      "layer": "test",
      "parent": "TestVendorIDDeduplication",
      "docstring": "Test vendor ID mismatch (different item ID).",
      "category": "test"
    },
    {
      "name": "test_vendor_id_no_match_different_marketplace",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 357,
      "signature": "async test_vendor_id_no_match_different_marketplace(self, db_session: AsyncSession)",
      "summary": "Test vendor ID mismatch (different marketplace).",
      "layer": "test",
      "parent": "TestVendorIDDeduplication",
      "docstring": "Test vendor ID mismatch (different marketplace).",
      "category": "test"
    },
    {
      "name": "test_vendor_id_null_no_check",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 385,
      "signature": "async test_vendor_id_null_no_check(self, db_session: AsyncSession)",
      "summary": "Test that null vendor_item_id skips vendor ID check.",
      "layer": "test",
      "parent": "TestVendorIDDeduplication",
      "docstring": "Test that null vendor_item_id skips vendor ID check.",
      "category": "test"
    },
    {
      "name": "TestHashBasedDeduplication",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 417,
      "signature": "class TestHashBasedDeduplication",
      "summary": "Tests for hash-based deduplication.",
      "layer": "test",
      "docstring": "Tests for hash-based deduplication.",
      "category": "test"
    },
    {
      "name": "test_find_existing_by_hash",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 420,
      "signature": "async test_find_existing_by_hash(self, db_session: AsyncSession)",
      "summary": "Test finding existing listing by hash (no vendor_item_id).",
      "layer": "test",
      "parent": "TestHashBasedDeduplication",
      "docstring": "Test finding existing listing by hash (no vendor_item_id).",
      "category": "test"
    },
    {
      "name": "test_hash_match_with_variation",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 456,
      "signature": "async test_hash_match_with_variation(self, db_session: AsyncSession)",
      "summary": "Test hash match with case/whitespace variations.",
      "layer": "test",
      "parent": "TestHashBasedDeduplication",
      "docstring": "Test hash match with case/whitespace variations.",
      "category": "test"
    },
    {
      "name": "test_hash_no_match_different_title",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 511,
      "signature": "async test_hash_no_match_different_title(self, db_session: AsyncSession)",
      "summary": "Test hash mismatch with different title.",
      "layer": "test",
      "parent": "TestHashBasedDeduplication",
      "docstring": "Test hash mismatch with different title.",
      "category": "test"
    },
    {
      "name": "test_hash_no_match_different_price",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 549,
      "signature": "async test_hash_no_match_different_price(self, db_session: AsyncSession)",
      "summary": "Test hash mismatch with different price.",
      "layer": "test",
      "parent": "TestHashBasedDeduplication",
      "docstring": "Test hash mismatch with different price.",
      "category": "test"
    },
    {
      "name": "TestDeduplicationPriority",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 589,
      "signature": "class TestDeduplicationPriority",
      "summary": "Tests for deduplication priority (vendor ID over hash).",
      "layer": "test",
      "docstring": "Tests for deduplication priority (vendor ID over hash).",
      "category": "test"
    },
    {
      "name": "test_vendor_id_takes_priority_over_hash",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 592,
      "signature": "async test_vendor_id_takes_priority_over_hash(self, db_session: AsyncSession)",
      "summary": "Test that vendor_item_id match is preferred over hash match.",
      "layer": "test",
      "parent": "TestDeduplicationPriority",
      "docstring": "Test that vendor_item_id match is preferred over hash match.",
      "category": "test"
    },
    {
      "name": "TestNoDuplicateFound",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 645,
      "signature": "class TestNoDuplicateFound",
      "summary": "Tests for cases where no duplicate exists.",
      "layer": "test",
      "docstring": "Tests for cases where no duplicate exists.",
      "category": "test"
    },
    {
      "name": "test_no_duplicate_found",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 648,
      "signature": "async test_no_duplicate_found(self, db_session: AsyncSession)",
      "summary": "Test when no duplicate exists.",
      "layer": "test",
      "parent": "TestNoDuplicateFound",
      "docstring": "Test when no duplicate exists.",
      "category": "test"
    },
    {
      "name": "test_empty_database",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 666,
      "signature": "async test_empty_database(self, db_session: AsyncSession)",
      "summary": "Test deduplication with empty database.",
      "layer": "test",
      "parent": "TestNoDuplicateFound",
      "docstring": "Test deduplication with empty database.",
      "category": "test"
    },
    {
      "name": "TestEdgeCases",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 684,
      "signature": "class TestEdgeCases",
      "summary": "Tests for edge cases and boundary conditions.",
      "layer": "test",
      "docstring": "Tests for edge cases and boundary conditions.",
      "category": "test"
    },
    {
      "name": "test_very_long_title",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 687,
      "signature": "async test_very_long_title(self, db_session: AsyncSession)",
      "summary": "Test hash generation with very long title.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test hash generation with very long title.",
      "category": "test"
    },
    {
      "name": "test_special_characters_in_title",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 704,
      "signature": "async test_special_characters_in_title(self, db_session: AsyncSession)",
      "summary": "Test hash generation with special characters.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test hash generation with special characters.",
      "category": "test"
    },
    {
      "name": "test_price_normalization_consistency",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 721,
      "signature": "async test_price_normalization_consistency(self, db_session: AsyncSession)",
      "summary": "Test hash generation with price normalization.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test hash generation with price normalization.",
      "category": "test"
    },
    {
      "name": "test_marketplace_case_sensitivity",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 755,
      "signature": "async test_marketplace_case_sensitivity(self, db_session: AsyncSession)",
      "summary": "Test that marketplace comparison is case-sensitive in DB.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test that marketplace comparison is case-sensitive in DB.",
      "category": "test"
    },
    {
      "name": "TestDeduplicationResultDataclass",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 785,
      "signature": "class TestDeduplicationResultDataclass",
      "summary": "Tests for DeduplicationResult dataclass.",
      "layer": "test",
      "docstring": "Tests for DeduplicationResult dataclass.",
      "category": "test"
    },
    {
      "name": "test_deduplication_result_creation",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 788,
      "signature": "test_deduplication_result_creation(self)",
      "summary": "Test creating DeduplicationResult instances.",
      "layer": "test",
      "parent": "TestDeduplicationResultDataclass",
      "docstring": "Test creating DeduplicationResult instances.",
      "category": "test"
    },
    {
      "name": "test_deduplication_result_with_listing",
      "kind": "method",
      "path": "tests/test_deduplication_service.py",
      "line": 815,
      "signature": "test_deduplication_result_with_listing(self, db_session: AsyncSession)",
      "summary": "Test DeduplicationResult with actual Listing object.",
      "layer": "test",
      "parent": "TestDeduplicationResultDataclass",
      "docstring": "Test DeduplicationResult with actual Listing object.",
      "category": "test"
    },
    {
      "name": "TestHashCollisionResistance",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 837,
      "signature": "class TestHashCollisionResistance",
      "summary": "Tests for hash collision resistance and stability.",
      "layer": "test",
      "docstring": "Tests for hash collision resistance and stability.",
      "category": "test"
    },
    {
      "name": "test_hash_different_for_similar_titles",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 840,
      "signature": "async test_hash_different_for_similar_titles(self, db_session: AsyncSession)",
      "summary": "Test that similar but different titles produce different hashes.",
      "layer": "test",
      "parent": "TestHashCollisionResistance",
      "docstring": "Test that similar but different titles produce different hashes.",
      "category": "test"
    },
    {
      "name": "test_hash_stability_across_service_instances",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 866,
      "signature": "async test_hash_stability_across_service_instances(self, db_session: AsyncSession)",
      "summary": "Test that hash is consistent across different service instances.",
      "layer": "test",
      "parent": "TestHashCollisionResistance",
      "docstring": "Test that hash is consistent across different service instances.",
      "category": "test"
    },
    {
      "name": "test_hash_with_unicode_characters",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 884,
      "signature": "async test_hash_with_unicode_characters(self, db_session: AsyncSession)",
      "summary": "Test hash generation with Unicode characters in title.",
      "layer": "test",
      "parent": "TestHashCollisionResistance",
      "docstring": "Test hash generation with Unicode characters in title.",
      "category": "test"
    },
    {
      "name": "test_hash_with_emoji_in_title",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 900,
      "signature": "async test_hash_with_emoji_in_title(self, db_session: AsyncSession)",
      "summary": "Test hash generation with emoji in title.",
      "layer": "test",
      "parent": "TestHashCollisionResistance",
      "docstring": "Test hash generation with emoji in title.",
      "category": "test"
    },
    {
      "name": "test_hash_different_sellers_same_product",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 915,
      "signature": "async test_hash_different_sellers_same_product(self, db_session: AsyncSession)",
      "summary": "Test that same product from different sellers produces different hash.",
      "layer": "test",
      "parent": "TestHashCollisionResistance",
      "docstring": "Test that same product from different sellers produces different hash.",
      "category": "test"
    },
    {
      "name": "test_hash_different_marketplaces",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 940,
      "signature": "async test_hash_different_marketplaces(self, db_session: AsyncSession)",
      "summary": "Test hash generation with different marketplaces.",
      "layer": "test",
      "parent": "TestHashCollisionResistance",
      "docstring": "Test hash generation with different marketplaces.",
      "category": "test"
    },
    {
      "name": "TestDedupAdvancedEdgeCases",
      "kind": "class",
      "path": "tests/test_deduplication_service.py",
      "line": 969,
      "signature": "class TestDedupAdvancedEdgeCases",
      "summary": "Advanced edge cases for deduplication.",
      "layer": "test",
      "docstring": "Advanced edge cases for deduplication.",
      "category": "test"
    },
    {
      "name": "test_multiple_listings_with_same_hash",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 972,
      "signature": "async test_multiple_listings_with_same_hash(self, db_session: AsyncSession)",
      "summary": "Test finding listing when hash matches (may find first or raise error).",
      "layer": "test",
      "parent": "TestDedupAdvancedEdgeCases",
      "docstring": "Test finding listing when hash matches (may find first or raise error).",
      "category": "test"
    },
    {
      "name": "test_vendor_id_and_hash_match_different_listings",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 1005,
      "signature": "async test_vendor_id_and_hash_match_different_listings(self, db_session: AsyncSession)",
      "summary": "Test when vendor_id matches one listing but hash matches another.",
      "layer": "test",
      "parent": "TestDedupAdvancedEdgeCases",
      "docstring": "Test when vendor_id matches one listing but hash matches another.",
      "category": "test"
    },
    {
      "name": "test_price_normalization_in_hash",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 1057,
      "signature": "async test_price_normalization_in_hash(self, db_session: AsyncSession)",
      "summary": "Test hash normalization with price decimal normalization.",
      "layer": "test",
      "parent": "TestDedupAdvancedEdgeCases",
      "docstring": "Test hash normalization with price decimal normalization.",
      "category": "test"
    },
    {
      "name": "test_condition_normalization_in_hash",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 1082,
      "signature": "async test_condition_normalization_in_hash(self, db_session: AsyncSession)",
      "summary": "Test hash generation with different conditions.",
      "layer": "test",
      "parent": "TestDedupAdvancedEdgeCases",
      "docstring": "Test hash generation with different conditions.",
      "category": "test"
    },
    {
      "name": "test_empty_seller_normalization",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 1109,
      "signature": "async test_empty_seller_normalization(self, db_session: AsyncSession)",
      "summary": "Test hash generation with empty vs None seller.",
      "layer": "test",
      "parent": "TestDedupAdvancedEdgeCases",
      "docstring": "Test hash generation with empty vs None seller.",
      "category": "test"
    },
    {
      "name": "test_find_existing_with_complex_title",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 1135,
      "signature": "async test_find_existing_with_complex_title(self, db_session: AsyncSession)",
      "summary": "Test deduplication with complex title containing numbers and symbols.",
      "layer": "test",
      "parent": "TestDedupAdvancedEdgeCases",
      "docstring": "Test deduplication with complex title containing numbers and symbols.",
      "category": "test"
    },
    {
      "name": "test_trailing_whitespace_normalization",
      "kind": "async_method",
      "path": "tests/test_deduplication_service.py",
      "line": 1163,
      "signature": "async test_trailing_whitespace_normalization(self, db_session: AsyncSession)",
      "summary": "Test that trailing/leading whitespace in all fields is normalized.",
      "layer": "test",
      "parent": "TestDedupAdvancedEdgeCases",
      "docstring": "Test that trailing/leading whitespace in all fields is normalized.",
      "category": "test"
    },
    {
      "name": "ebay_responses",
      "kind": "function",
      "path": "tests/test_ebay_adapter.py",
      "line": 22,
      "signature": "ebay_responses()",
      "summary": "Load eBay API response fixtures.",
      "layer": "test",
      "docstring": "Load eBay API response fixtures.",
      "category": "test"
    },
    {
      "name": "mock_settings",
      "kind": "function",
      "path": "tests/test_ebay_adapter.py",
      "line": 29,
      "signature": "mock_settings()",
      "summary": "Mock settings with eBay API configuration.",
      "layer": "test",
      "docstring": "Mock settings with eBay API configuration.",
      "category": "test"
    },
    {
      "name": "adapter",
      "kind": "function",
      "path": "tests/test_ebay_adapter.py",
      "line": 41,
      "signature": "adapter(mock_settings)",
      "summary": "Create EbayAdapter instance with mocked settings.",
      "layer": "test",
      "docstring": "Create EbayAdapter instance with mocked settings.",
      "category": "test"
    },
    {
      "name": "TestEbayAdapterInit",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 46,
      "signature": "class TestEbayAdapterInit",
      "summary": "Test EbayAdapter initialization.",
      "layer": "test",
      "docstring": "Test EbayAdapter initialization.",
      "category": "test"
    },
    {
      "name": "test_init_success",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 49,
      "signature": "test_init_success(self, adapter)",
      "summary": "Test successful adapter initialization.",
      "layer": "test",
      "parent": "TestEbayAdapterInit",
      "docstring": "Test successful adapter initialization.",
      "category": "test"
    },
    {
      "name": "test_init_missing_api_key",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 59,
      "signature": "test_init_missing_api_key(self, mock_settings)",
      "summary": "Test initialization succeeds without API key (validation deferred to extract).",
      "layer": "test",
      "parent": "TestEbayAdapterInit",
      "docstring": "Test initialization succeeds without API key (validation deferred to extract).",
      "category": "test"
    },
    {
      "name": "test_supports_url",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 69,
      "signature": "test_supports_url(self, adapter)",
      "summary": "Test URL domain matching.",
      "layer": "test",
      "parent": "TestEbayAdapterInit",
      "docstring": "Test URL domain matching.",
      "category": "test"
    },
    {
      "name": "TestUrlParsing",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 76,
      "signature": "class TestUrlParsing",
      "summary": "Test URL parsing and item ID extraction.",
      "layer": "test",
      "docstring": "Test URL parsing and item ID extraction.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_standard_format",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 79,
      "signature": "test_parse_item_id_standard_format(self, adapter)",
      "summary": "Test parsing standard eBay URL format.",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing standard eBay URL format.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_with_product_name",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 85,
      "signature": "test_parse_item_id_with_product_name(self, adapter)",
      "summary": "Test parsing URL with product name slug.",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing URL with product name slug.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_with_query_params",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 91,
      "signature": "test_parse_item_id_with_query_params(self, adapter)",
      "summary": "Test parsing URL with query parameters.",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing URL with query parameters.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_with_hash",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 97,
      "signature": "test_parse_item_id_with_hash(self, adapter)",
      "summary": "Test parsing URL with hash fragment.",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing URL with hash fragment.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_short_domain",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 103,
      "signature": "test_parse_item_id_short_domain(self, adapter)",
      "summary": "Test parsing URL with ebay.com (no www).",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing URL with ebay.com (no www).",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_13_digits",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 109,
      "signature": "test_parse_item_id_13_digits(self, adapter)",
      "summary": "Test parsing 13-digit item ID.",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing 13-digit item ID.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_invalid_url",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 115,
      "signature": "test_parse_item_id_invalid_url(self, adapter)",
      "summary": "Test parsing fails on invalid URL format.",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing fails on invalid URL format.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_non_ebay_url",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 124,
      "signature": "test_parse_item_id_non_ebay_url(self, adapter)",
      "summary": "Test parsing fails on non-eBay URL.",
      "layer": "test",
      "parent": "TestUrlParsing",
      "docstring": "Test parsing fails on non-eBay URL.",
      "category": "test"
    },
    {
      "name": "TestConditionNormalization",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 133,
      "signature": "class TestConditionNormalization",
      "summary": "Test eBay condition normalization.",
      "layer": "test",
      "docstring": "Test eBay condition normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_new",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 136,
      "signature": "test_normalize_condition_new(self, adapter)",
      "summary": "Test 'New' condition normalization.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test 'New' condition normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_refurb",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 142,
      "signature": "test_normalize_condition_refurb(self, adapter)",
      "summary": "Test refurbished condition normalization.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test refurbished condition normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_used",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 148,
      "signature": "test_normalize_condition_used(self, adapter)",
      "summary": "Test 'Used' condition normalization.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test 'Used' condition normalization.",
      "category": "test"
    },
    {
      "name": "TestSpecExtraction",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 155,
      "signature": "class TestSpecExtraction",
      "summary": "Test extraction of CPU, RAM, and storage from item aspects.",
      "layer": "test",
      "docstring": "Test extraction of CPU, RAM, and storage from item aspects.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_from_aspects",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 158,
      "signature": "test_extract_cpu_from_aspects(self, adapter)",
      "summary": "Test CPU extraction from localizedAspects.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test CPU extraction from localizedAspects.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_processor_type",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 167,
      "signature": "test_extract_cpu_processor_type(self, adapter)",
      "summary": "Test CPU extraction with 'Processor Type' field name.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test CPU extraction with 'Processor Type' field name.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_not_found",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 173,
      "signature": "test_extract_cpu_not_found(self, adapter)",
      "summary": "Test CPU extraction returns None when not found.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test CPU extraction returns None when not found.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_from_aspects",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 179,
      "signature": "test_extract_ram_from_aspects(self, adapter)",
      "summary": "Test RAM extraction from localizedAspects.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test RAM extraction from localizedAspects.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_with_memory_field",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 185,
      "signature": "test_extract_ram_with_memory_field(self, adapter)",
      "summary": "Test RAM extraction with 'Memory' field name.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test RAM extraction with 'Memory' field name.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_no_space",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 191,
      "signature": "test_extract_ram_no_space(self, adapter)",
      "summary": "Test RAM extraction with no space (e.g., '16GB').",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test RAM extraction with no space (e.g., '16GB').",
      "category": "test"
    },
    {
      "name": "test_extract_ram_not_found",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 197,
      "signature": "test_extract_ram_not_found(self, adapter)",
      "summary": "Test RAM extraction returns None when not found.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test RAM extraction returns None when not found.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_gb",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 203,
      "signature": "test_extract_storage_gb(self, adapter)",
      "summary": "Test storage extraction in GB.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test storage extraction in GB.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_tb",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 209,
      "signature": "test_extract_storage_tb(self, adapter)",
      "summary": "Test storage extraction in TB (converted to GB).",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test storage extraction in TB (converted to GB).",
      "category": "test"
    },
    {
      "name": "test_extract_storage_hard_drive",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 215,
      "signature": "test_extract_storage_hard_drive(self, adapter)",
      "summary": "Test storage extraction with 'Hard Drive Capacity'.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test storage extraction with 'Hard Drive Capacity'.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_not_found",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 221,
      "signature": "test_extract_storage_not_found(self, adapter)",
      "summary": "Test storage extraction returns None when not found.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test storage extraction returns None when not found.",
      "category": "test"
    },
    {
      "name": "TestSchemaMapping",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 228,
      "signature": "class TestSchemaMapping",
      "summary": "Test mapping eBay API response to NormalizedListingSchema.",
      "layer": "test",
      "docstring": "Test mapping eBay API response to NormalizedListingSchema.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_full_specs",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 231,
      "signature": "test_map_to_schema_full_specs(self, adapter, ebay_responses)",
      "summary": "Test mapping with full specifications.",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping with full specifications.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_minimal",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 250,
      "signature": "test_map_to_schema_minimal(self, adapter, ebay_responses)",
      "summary": "Test mapping with minimal required fields.",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping with minimal required fields.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_refurbished",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 267,
      "signature": "test_map_to_schema_refurbished(self, adapter, ebay_responses)",
      "summary": "Test mapping with refurbished condition.",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping with refurbished condition.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_tb_storage",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 277,
      "signature": "test_map_to_schema_tb_storage(self, adapter, ebay_responses)",
      "summary": "Test mapping with TB storage (converted to GB).",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping with TB storage (converted to GB).",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_no_specs",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 286,
      "signature": "test_map_to_schema_no_specs(self, adapter, ebay_responses)",
      "summary": "Test mapping with no specs extracted.",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping with no specs extracted.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_itemspecifics_format",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 296,
      "signature": "test_map_to_schema_itemspecifics_format(self, adapter, ebay_responses)",
      "summary": "Test mapping with itemSpecifics instead of localizedAspects.",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping with itemSpecifics instead of localizedAspects.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_missing_title",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 307,
      "signature": "test_map_to_schema_missing_title(self, adapter, ebay_responses)",
      "summary": "Test mapping fails when title is missing.",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping fails when title is missing.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_missing_price",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 317,
      "signature": "test_map_to_schema_missing_price(self, adapter, ebay_responses)",
      "summary": "Test mapping fails when price is missing.",
      "layer": "test",
      "parent": "TestSchemaMapping",
      "docstring": "Test mapping fails when price is missing.",
      "category": "test"
    },
    {
      "name": "TestApiFetching",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 328,
      "signature": "class TestApiFetching",
      "summary": "Test eBay API fetching with various scenarios.",
      "layer": "test",
      "docstring": "Test eBay API fetching with various scenarios.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_success",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 332,
      "signature": "async test_fetch_item_success(self, adapter, ebay_responses)",
      "summary": "Test successful item fetch from eBay API.",
      "layer": "test",
      "parent": "TestApiFetching",
      "docstring": "Test successful item fetch from eBay API.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_not_found",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 352,
      "signature": "async test_fetch_item_not_found(self, adapter)",
      "summary": "Test handling of 404 item not found.",
      "layer": "test",
      "parent": "TestApiFetching",
      "docstring": "Test handling of 404 item not found.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_unauthorized",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 370,
      "signature": "async test_fetch_item_unauthorized(self, adapter)",
      "summary": "Test handling of 401 unauthorized.",
      "layer": "test",
      "parent": "TestApiFetching",
      "docstring": "Test handling of 401 unauthorized.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_rate_limited",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 388,
      "signature": "async test_fetch_item_rate_limited(self, adapter)",
      "summary": "Test handling of 429 rate limit.",
      "layer": "test",
      "parent": "TestApiFetching",
      "docstring": "Test handling of 429 rate limit.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_server_error",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 406,
      "signature": "async test_fetch_item_server_error(self, adapter)",
      "summary": "Test handling of 500 server error.",
      "layer": "test",
      "parent": "TestApiFetching",
      "docstring": "Test handling of 500 server error.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_timeout",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 424,
      "signature": "async test_fetch_item_timeout(self, adapter)",
      "summary": "Test handling of request timeout.",
      "layer": "test",
      "parent": "TestApiFetching",
      "docstring": "Test handling of request timeout.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_network_error",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 439,
      "signature": "async test_fetch_item_network_error(self, adapter)",
      "summary": "Test handling of network error.",
      "layer": "test",
      "parent": "TestApiFetching",
      "docstring": "Test handling of network error.",
      "category": "test"
    },
    {
      "name": "TestExtractEndToEnd",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 454,
      "signature": "class TestExtractEndToEnd",
      "summary": "Test end-to-end extraction workflow.",
      "layer": "test",
      "docstring": "Test end-to-end extraction workflow.",
      "category": "test"
    },
    {
      "name": "test_extract_success",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 458,
      "signature": "async test_extract_success(self, adapter, ebay_responses)",
      "summary": "Test successful end-to-end extraction.",
      "layer": "test",
      "parent": "TestExtractEndToEnd",
      "docstring": "Test successful end-to-end extraction.",
      "category": "test"
    },
    {
      "name": "test_extract_with_retry",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 481,
      "signature": "async test_extract_with_retry(self, adapter, ebay_responses)",
      "summary": "Test extraction with retry on timeout.",
      "layer": "test",
      "parent": "TestExtractEndToEnd",
      "docstring": "Test extraction with retry on timeout.",
      "category": "test"
    },
    {
      "name": "test_extract_invalid_url",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 508,
      "signature": "async test_extract_invalid_url(self, adapter)",
      "summary": "Test extraction fails on invalid URL.",
      "layer": "test",
      "parent": "TestExtractEndToEnd",
      "docstring": "Test extraction fails on invalid URL.",
      "category": "test"
    },
    {
      "name": "test_extract_item_not_found",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 518,
      "signature": "async test_extract_item_not_found(self, adapter)",
      "summary": "Test extraction fails on 404 (non-retryable).",
      "layer": "test",
      "parent": "TestExtractEndToEnd",
      "docstring": "Test extraction fails on 404 (non-retryable).",
      "category": "test"
    },
    {
      "name": "test_extract_missing_api_key",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 536,
      "signature": "async test_extract_missing_api_key(self, mock_settings)",
      "summary": "Test extraction fails when API key is not configured.",
      "layer": "test",
      "parent": "TestExtractEndToEnd",
      "docstring": "Test extraction fails when API key is not configured.",
      "category": "test"
    },
    {
      "name": "TestEdgeCases",
      "kind": "class",
      "path": "tests/test_ebay_adapter.py",
      "line": 553,
      "signature": "class TestEdgeCases",
      "summary": "Test edge cases and unusual scenarios.",
      "layer": "test",
      "docstring": "Test edge cases and unusual scenarios.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_trailing_slash",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 556,
      "signature": "test_parse_item_id_trailing_slash(self, adapter)",
      "summary": "Test parsing URL with trailing slash - adapter may not support this.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test parsing URL with trailing slash - adapter may not support this.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_mixed_case_domain",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 568,
      "signature": "test_parse_item_id_mixed_case_domain(self, adapter)",
      "summary": "Test parsing URL with mixed case domain.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test parsing URL with mixed case domain.",
      "category": "test"
    },
    {
      "name": "test_parse_item_id_multiple_slashes",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 574,
      "signature": "test_parse_item_id_multiple_slashes(self, adapter)",
      "summary": "Test parsing URL with multiple path segments.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test parsing URL with multiple path segments.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_unusual_formats",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 582,
      "signature": "test_extract_ram_unusual_formats(self, adapter)",
      "summary": "Test RAM extraction with unusual formats.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test RAM extraction with unusual formats.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_multiple_devices",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 596,
      "signature": "test_extract_storage_multiple_devices(self, adapter)",
      "summary": "Test storage extraction when multiple storage devices mentioned.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test storage extraction when multiple storage devices mentioned.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_decimal_tb",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 607,
      "signature": "test_extract_storage_decimal_tb(self, adapter)",
      "summary": "Test storage extraction with decimal TB values.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test storage extraction with decimal TB values.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_without_core_suffix",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 615,
      "signature": "test_extract_cpu_without_core_suffix(self, adapter)",
      "summary": "Test CPU extraction without 'Core' prefix.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test CPU extraction without 'Core' prefix.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_edge_cases",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 621,
      "signature": "test_normalize_condition_edge_cases(self, adapter)",
      "summary": "Test condition normalization with edge cases.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test condition normalization with edge cases.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_missing_currency",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 633,
      "signature": "test_map_to_schema_missing_currency(self, adapter, ebay_responses)",
      "summary": "Test mapping when currency is missing (should default to USD).",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test mapping when currency is missing (should default to USD).",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_empty_images_list",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 644,
      "signature": "test_map_to_schema_empty_images_list(self, adapter, ebay_responses)",
      "summary": "Test mapping with empty images list.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test mapping with empty images list.",
      "category": "test"
    },
    {
      "name": "test_map_to_schema_special_characters_in_title",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 652,
      "signature": "test_map_to_schema_special_characters_in_title(self, adapter, ebay_responses)",
      "summary": "Test mapping with special characters in title.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test mapping with special characters in title.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_invalid_json_response",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 661,
      "signature": "async test_fetch_item_invalid_json_response(self, adapter)",
      "summary": "Test handling of invalid JSON response.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test handling of invalid JSON response.",
      "category": "test"
    },
    {
      "name": "test_fetch_item_503_service_unavailable",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 677,
      "signature": "async test_fetch_item_503_service_unavailable(self, adapter)",
      "summary": "Test handling of 503 service unavailable.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test handling of 503 service unavailable.",
      "category": "test"
    },
    {
      "name": "test_extract_malformed_url",
      "kind": "async_method",
      "path": "tests/test_ebay_adapter.py",
      "line": 694,
      "signature": "async test_extract_malformed_url(self, adapter)",
      "summary": "Test extraction with malformed URL.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test extraction with malformed URL.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_mb_format",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 703,
      "signature": "test_extract_ram_mb_format(self, adapter)",
      "summary": "Test RAM extraction with MB format (should convert to GB).",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test RAM extraction with MB format (should convert to GB).",
      "category": "test"
    },
    {
      "name": "test_vendor_item_id_prefix_stripping",
      "kind": "method",
      "path": "tests/test_ebay_adapter.py",
      "line": 711,
      "signature": "test_vendor_item_id_prefix_stripping(self, adapter, ebay_responses)",
      "summary": "Test that v1| prefix is correctly stripped from vendor_item_id.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test that v1| prefix is correctly stripped from vendor_item_id.",
      "category": "test"
    },
    {
      "name": "TestEventDataStructures",
      "kind": "class",
      "path": "tests/test_event_service.py",
      "line": 24,
      "signature": "class TestEventDataStructures",
      "summary": "Test event dataclass creation.",
      "layer": "test",
      "docstring": "Test event dataclass creation.",
      "category": "test"
    },
    {
      "name": "test_create_listing_created_event",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 27,
      "signature": "test_create_listing_created_event(self)",
      "summary": "Test ListingCreatedEvent dataclass.",
      "layer": "test",
      "parent": "TestEventDataStructures",
      "docstring": "Test ListingCreatedEvent dataclass.",
      "category": "test"
    },
    {
      "name": "test_create_price_changed_event",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 50,
      "signature": "test_create_price_changed_event(self)",
      "summary": "Test PriceChangedEvent dataclass.",
      "layer": "test",
      "parent": "TestEventDataStructures",
      "docstring": "Test PriceChangedEvent dataclass.",
      "category": "test"
    },
    {
      "name": "test_listing_created_event_with_none_vendor_id",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 75,
      "signature": "test_listing_created_event_with_none_vendor_id(self)",
      "summary": "Test ListingCreatedEvent with None vendor_item_id.",
      "layer": "test",
      "parent": "TestEventDataStructures",
      "docstring": "Test ListingCreatedEvent with None vendor_item_id.",
      "category": "test"
    },
    {
      "name": "test_price_changed_event_with_none_vendor_id",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 92,
      "signature": "test_price_changed_event_with_none_vendor_id(self)",
      "summary": "Test PriceChangedEvent with None vendor_item_id.",
      "layer": "test",
      "parent": "TestEventDataStructures",
      "docstring": "Test PriceChangedEvent with None vendor_item_id.",
      "category": "test"
    },
    {
      "name": "TestPriceChangeDetection",
      "kind": "class",
      "path": "tests/test_event_service.py",
      "line": 111,
      "signature": "class TestPriceChangeDetection",
      "summary": "Test should_emit_price_change() logic.",
      "layer": "test",
      "docstring": "Test should_emit_price_change() logic.",
      "category": "test"
    },
    {
      "name": "test_should_emit_price_change_absolute_threshold",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 114,
      "signature": "test_should_emit_price_change_absolute_threshold(self)",
      "summary": "Test emission when absolute change meets threshold.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test emission when absolute change meets threshold.",
      "category": "test"
    },
    {
      "name": "test_should_emit_price_change_percent_threshold",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 126,
      "signature": "test_should_emit_price_change_percent_threshold(self)",
      "summary": "Test emission when percent change meets threshold.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test emission when percent change meets threshold.",
      "category": "test"
    },
    {
      "name": "test_should_not_emit_price_change_below_thresholds",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 138,
      "signature": "test_should_not_emit_price_change_below_thresholds(self)",
      "summary": "Test no emission when both thresholds not met.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test no emission when both thresholds not met.",
      "category": "test"
    },
    {
      "name": "test_should_emit_price_increase",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 150,
      "signature": "test_should_emit_price_increase(self)",
      "summary": "Test that price increases also trigger events.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test that price increases also trigger events.",
      "category": "test"
    },
    {
      "name": "test_should_emit_exact_threshold_match",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 161,
      "signature": "test_should_emit_exact_threshold_match(self)",
      "summary": "Test emission when change exactly matches threshold.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test emission when change exactly matches threshold.",
      "category": "test"
    },
    {
      "name": "test_should_emit_zero_old_price",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 173,
      "signature": "test_should_emit_zero_old_price(self)",
      "summary": "Test price change detection when old price is zero.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test price change detection when old price is zero.",
      "category": "test"
    },
    {
      "name": "test_should_not_emit_zero_old_price_below_threshold",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 184,
      "signature": "test_should_not_emit_zero_old_price_below_threshold(self)",
      "summary": "Test no emission when old price is zero and absolute threshold not met.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test no emission when old price is zero and absolute threshold not met.",
      "category": "test"
    },
    {
      "name": "test_should_emit_small_price_drop",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 194,
      "signature": "test_should_emit_small_price_drop(self)",
      "summary": "Test small price drop that meets percent threshold.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test small price drop that meets percent threshold.",
      "category": "test"
    },
    {
      "name": "test_should_emit_large_absolute_small_percent",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 205,
      "signature": "test_should_emit_large_absolute_small_percent(self)",
      "summary": "Test large absolute change with small percentage.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test large absolute change with small percentage.",
      "category": "test"
    },
    {
      "name": "test_decimal_precision_calculation",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 216,
      "signature": "test_decimal_precision_calculation(self)",
      "summary": "Test precise decimal calculations for percentage.",
      "layer": "test",
      "parent": "TestPriceChangeDetection",
      "docstring": "Test precise decimal calculations for percentage.",
      "category": "test"
    },
    {
      "name": "TestIngestionEventService",
      "kind": "class",
      "path": "tests/test_event_service.py",
      "line": 228,
      "signature": "class TestIngestionEventService",
      "summary": "Test IngestionEventService methods.",
      "layer": "test",
      "docstring": "Test IngestionEventService methods.",
      "category": "test"
    },
    {
      "name": "test_emit_listing_created",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 231,
      "signature": "test_emit_listing_created(self)",
      "summary": "Test emitting listing.created event.",
      "layer": "test",
      "parent": "TestIngestionEventService",
      "docstring": "Test emitting listing.created event.",
      "category": "test"
    },
    {
      "name": "test_emit_price_changed",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 259,
      "signature": "test_emit_price_changed(self)",
      "summary": "Test emitting price.changed event.",
      "layer": "test",
      "parent": "TestIngestionEventService",
      "docstring": "Test emitting price.changed event.",
      "category": "test"
    },
    {
      "name": "test_emit_price_changed_calculates_percentage",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 286,
      "signature": "test_emit_price_changed_calculates_percentage(self)",
      "summary": "Test price.changed event calculates percentage correctly.",
      "layer": "test",
      "parent": "TestIngestionEventService",
      "docstring": "Test price.changed event calculates percentage correctly.",
      "category": "test"
    },
    {
      "name": "test_emit_price_changed_with_zero_old_price",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 304,
      "signature": "test_emit_price_changed_with_zero_old_price(self)",
      "summary": "Test price.changed event with zero old price.",
      "layer": "test",
      "parent": "TestIngestionEventService",
      "docstring": "Test price.changed event with zero old price.",
      "category": "test"
    },
    {
      "name": "test_emit_multiple_events",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 323,
      "signature": "test_emit_multiple_events(self)",
      "summary": "Test emitting multiple events of different types.",
      "layer": "test",
      "parent": "TestIngestionEventService",
      "docstring": "Test emitting multiple events of different types.",
      "category": "test"
    },
    {
      "name": "test_get_events_returns_copy",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 356,
      "signature": "test_get_events_returns_copy(self)",
      "summary": "Test that get_events() returns a copy, not the original list.",
      "layer": "test",
      "parent": "TestIngestionEventService",
      "docstring": "Test that get_events() returns a copy, not the original list.",
      "category": "test"
    },
    {
      "name": "test_clear_events",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 377,
      "signature": "test_clear_events(self)",
      "summary": "Test clearing all events.",
      "layer": "test",
      "parent": "TestIngestionEventService",
      "docstring": "Test clearing all events.",
      "category": "test"
    },
    {
      "name": "TestCheckAndEmitPriceChange",
      "kind": "class",
      "path": "tests/test_event_service.py",
      "line": 396,
      "signature": "class TestCheckAndEmitPriceChange",
      "summary": "Test check_and_emit_price_change() with settings integration.",
      "layer": "test",
      "docstring": "Test check_and_emit_price_change() with settings integration.",
      "category": "test"
    },
    {
      "name": "test_check_and_emit_with_settings",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 399,
      "signature": "test_check_and_emit_with_settings(self, monkeypatch)",
      "summary": "Test check_and_emit_price_change uses settings thresholds.",
      "layer": "test",
      "parent": "TestCheckAndEmitPriceChange",
      "docstring": "Test check_and_emit_price_change uses settings thresholds.",
      "category": "test"
    },
    {
      "name": "test_check_and_emit_does_not_emit_below_threshold",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 425,
      "signature": "test_check_and_emit_does_not_emit_below_threshold(self, monkeypatch)",
      "summary": "Test check_and_emit_price_change does not emit below threshold.",
      "layer": "test",
      "parent": "TestCheckAndEmitPriceChange",
      "docstring": "Test check_and_emit_price_change does not emit below threshold.",
      "category": "test"
    },
    {
      "name": "test_check_and_emit_meets_percent_threshold_only",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 450,
      "signature": "test_check_and_emit_meets_percent_threshold_only(self, monkeypatch)",
      "summary": "Test emission when only percent threshold is met.",
      "layer": "test",
      "parent": "TestCheckAndEmitPriceChange",
      "docstring": "Test emission when only percent threshold is met.",
      "category": "test"
    },
    {
      "name": "test_check_and_emit_meets_absolute_threshold_only",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 474,
      "signature": "test_check_and_emit_meets_absolute_threshold_only(self, monkeypatch)",
      "summary": "Test emission when only absolute threshold is met.",
      "layer": "test",
      "parent": "TestCheckAndEmitPriceChange",
      "docstring": "Test emission when only absolute threshold is met.",
      "category": "test"
    },
    {
      "name": "TestEdgeCases",
      "kind": "class",
      "path": "tests/test_event_service.py",
      "line": 501,
      "signature": "class TestEdgeCases",
      "summary": "Test edge cases and error conditions.",
      "layer": "test",
      "docstring": "Test edge cases and error conditions.",
      "category": "test"
    },
    {
      "name": "test_price_change_with_very_small_decimals",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 504,
      "signature": "test_price_change_with_very_small_decimals(self)",
      "summary": "Test price change with very small decimal amounts.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test price change with very small decimal amounts.",
      "category": "test"
    },
    {
      "name": "test_price_change_calculation_with_decimals",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 515,
      "signature": "test_price_change_calculation_with_decimals(self)",
      "summary": "Test precise decimal calculations for price changes.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test precise decimal calculations for price changes.",
      "category": "test"
    },
    {
      "name": "test_large_price_change",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 532,
      "signature": "test_large_price_change(self)",
      "summary": "Test large price change detection.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test large price change detection.",
      "category": "test"
    },
    {
      "name": "test_price_increase_event",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 542,
      "signature": "test_price_increase_event(self)",
      "summary": "Test price increase emits positive change.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test price increase emits positive change.",
      "category": "test"
    },
    {
      "name": "test_same_price_no_emit",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 558,
      "signature": "test_same_price_no_emit(self)",
      "summary": "Test that same price does not emit event.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test that same price does not emit event.",
      "category": "test"
    },
    {
      "name": "test_event_timestamp_accuracy",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 568,
      "signature": "test_event_timestamp_accuracy(self)",
      "summary": "Test that PriceChangedEvent timestamp is recent.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test that PriceChangedEvent timestamp is recent.",
      "category": "test"
    },
    {
      "name": "TestPriceThresholdEdgeCases",
      "kind": "class",
      "path": "tests/test_event_service.py",
      "line": 586,
      "signature": "class TestPriceThresholdEdgeCases",
      "summary": "Test price threshold edge cases as specified in ID-026.",
      "layer": "test",
      "docstring": "Test price threshold edge cases as specified in ID-026.",
      "category": "test"
    },
    {
      "name": "test_exactly_one_dollar_change_should_emit",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 589,
      "signature": "test_exactly_one_dollar_change_should_emit(self)",
      "summary": "Test exactly $1 change should emit.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test exactly $1 change should emit.",
      "category": "test"
    },
    {
      "name": "test_ninety_nine_cents_change_should_not_emit",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 600,
      "signature": "test_ninety_nine_cents_change_should_not_emit(self)",
      "summary": "Test $0.99 change should not emit.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test $0.99 change should not emit.",
      "category": "test"
    },
    {
      "name": "test_exactly_two_percent_change_should_emit",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 611,
      "signature": "test_exactly_two_percent_change_should_emit(self)",
      "summary": "Test exactly 2% change should emit.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test exactly 2% change should emit.",
      "category": "test"
    },
    {
      "name": "test_one_point_nine_percent_change_should_not_emit",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 622,
      "signature": "test_one_point_nine_percent_change_should_not_emit(self)",
      "summary": "Test 1.9% change should not emit.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test 1.9% change should not emit.",
      "category": "test"
    },
    {
      "name": "test_small_absolute_large_percentage",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 633,
      "signature": "test_small_absolute_large_percentage(self)",
      "summary": "Test small absolute change with large percentage.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test small absolute change with large percentage.",
      "category": "test"
    },
    {
      "name": "test_large_absolute_small_percentage",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 645,
      "signature": "test_large_absolute_small_percentage(self)",
      "summary": "Test large absolute change with small percentage.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test large absolute change with small percentage.",
      "category": "test"
    },
    {
      "name": "test_exactly_threshold_both_conditions",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 657,
      "signature": "test_exactly_threshold_both_conditions(self)",
      "summary": "Test when both thresholds are exactly met.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test when both thresholds are exactly met.",
      "category": "test"
    },
    {
      "name": "test_price_increase_meets_absolute_threshold",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 669,
      "signature": "test_price_increase_meets_absolute_threshold(self)",
      "summary": "Test price increase meeting absolute threshold.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test price increase meeting absolute threshold.",
      "category": "test"
    },
    {
      "name": "test_price_increase_meets_percent_threshold",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 680,
      "signature": "test_price_increase_meets_percent_threshold(self)",
      "summary": "Test price increase meeting percent threshold.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test price increase meeting percent threshold.",
      "category": "test"
    },
    {
      "name": "test_both_thresholds_not_met",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 691,
      "signature": "test_both_thresholds_not_met(self)",
      "summary": "Test when neither threshold is met.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test when neither threshold is met.",
      "category": "test"
    },
    {
      "name": "test_fractional_dollar_threshold",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 703,
      "signature": "test_fractional_dollar_threshold(self)",
      "summary": "Test with fractional dollar threshold.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test with fractional dollar threshold.",
      "category": "test"
    },
    {
      "name": "test_very_small_price_change",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 714,
      "signature": "test_very_small_price_change(self)",
      "summary": "Test with very small price change (pennies).",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test with very small price change (pennies).",
      "category": "test"
    },
    {
      "name": "test_price_change_rounding_edge_case",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 725,
      "signature": "test_price_change_rounding_edge_case(self)",
      "summary": "Test price change with rounding edge cases.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test price change with rounding edge cases.",
      "category": "test"
    },
    {
      "name": "test_zero_price_thresholds",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 736,
      "signature": "test_zero_price_thresholds(self)",
      "summary": "Test with zero thresholds (always emit).",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test with zero thresholds (always emit).",
      "category": "test"
    },
    {
      "name": "test_negative_price_change_abs_value",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 747,
      "signature": "test_negative_price_change_abs_value(self)",
      "summary": "Test that absolute value is used for comparison.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test that absolute value is used for comparison.",
      "category": "test"
    },
    {
      "name": "test_high_precision_percentage_calculation",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 759,
      "signature": "test_high_precision_percentage_calculation(self)",
      "summary": "Test high precision percentage calculation.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test high precision percentage calculation.",
      "category": "test"
    },
    {
      "name": "test_event_service_integration_exact_thresholds",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 770,
      "signature": "test_event_service_integration_exact_thresholds(self, monkeypatch)",
      "summary": "Test IngestionEventService with exact threshold values.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test IngestionEventService with exact threshold values.",
      "category": "test"
    },
    {
      "name": "test_event_service_integration_percent_boundary",
      "kind": "method",
      "path": "tests/test_event_service.py",
      "line": 802,
      "signature": "test_event_service_integration_percent_boundary(self, monkeypatch)",
      "summary": "Test IngestionEventService with percent boundary cases.",
      "layer": "test",
      "parent": "TestPriceThresholdEdgeCases",
      "docstring": "Test IngestionEventService with percent boundary cases.",
      "category": "test"
    },
    {
      "name": "anyio_backend",
      "kind": "function",
      "path": "tests/test_field_values_api.py",
      "line": 21,
      "signature": "anyio_backend()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_get_listing_condition_values",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 26,
      "signature": "async test_get_listing_condition_values()",
      "summary": "Test getting distinct values for listing.condition field.",
      "layer": "test",
      "docstring": "Test getting distinct values for listing.condition field.",
      "category": "test"
    },
    {
      "name": "test_get_listing_manufacturer_values",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 61,
      "signature": "async test_get_listing_manufacturer_values()",
      "summary": "Test getting distinct values for listing.manufacturer field.",
      "layer": "test",
      "docstring": "Test getting distinct values for listing.manufacturer field.",
      "category": "test"
    },
    {
      "name": "test_get_cpu_manufacturer_values",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 96,
      "signature": "async test_get_cpu_manufacturer_values()",
      "summary": "Test getting distinct values for cpu.manufacturer field.",
      "layer": "test",
      "docstring": "Test getting distinct values for cpu.manufacturer field.",
      "category": "test"
    },
    {
      "name": "test_get_gpu_manufacturer_values",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 130,
      "signature": "async test_get_gpu_manufacturer_values()",
      "summary": "Test getting distinct values for gpu.manufacturer field.",
      "layer": "test",
      "docstring": "Test getting distinct values for gpu.manufacturer field.",
      "category": "test"
    },
    {
      "name": "test_limit_parameter",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 164,
      "signature": "async test_limit_parameter()",
      "summary": "Test that limit parameter works correctly.",
      "layer": "test",
      "docstring": "Test that limit parameter works correctly.",
      "category": "test"
    },
    {
      "name": "test_search_filter",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 194,
      "signature": "async test_search_filter()",
      "summary": "Test that search filter works correctly.",
      "layer": "test",
      "docstring": "Test that search filter works correctly.",
      "category": "test"
    },
    {
      "name": "test_invalid_field_format",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 229,
      "signature": "async test_invalid_field_format()",
      "summary": "Test that invalid field name format raises ValueError.",
      "layer": "test",
      "docstring": "Test that invalid field name format raises ValueError.",
      "category": "test"
    },
    {
      "name": "test_unknown_entity",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 249,
      "signature": "async test_unknown_entity()",
      "summary": "Test that unknown entity raises ValueError.",
      "layer": "test",
      "docstring": "Test that unknown entity raises ValueError.",
      "category": "test"
    },
    {
      "name": "test_unknown_field",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 269,
      "signature": "async test_unknown_field()",
      "summary": "Test that unknown field raises ValueError.",
      "layer": "test",
      "docstring": "Test that unknown field raises ValueError.",
      "category": "test"
    },
    {
      "name": "test_null_values_filtered",
      "kind": "async_function",
      "path": "tests/test_field_values_api.py",
      "line": 289,
      "signature": "async test_null_values_filtered()",
      "summary": "Test that null values are filtered out.",
      "layer": "test",
      "docstring": "Test that null values are filtered out.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 34,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "app",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 54,
      "signature": "app(db_session)",
      "summary": "Create FastAPI test app with ingestion router.",
      "layer": "test",
      "docstring": "Create FastAPI test app with ingestion router.",
      "category": "test"
    },
    {
      "name": "client",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 72,
      "signature": "client(app)",
      "summary": "Create test client for FastAPI app.",
      "layer": "test",
      "docstring": "Create test client for FastAPI app.",
      "category": "test"
    },
    {
      "name": "test_create_single_url_import_success",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 82,
      "signature": "test_create_single_url_import_success(client, db_session)",
      "summary": "Test successful single URL import creation.",
      "layer": "test",
      "docstring": "Test successful single URL import creation.",
      "category": "test"
    },
    {
      "name": "test_create_single_url_import_invalid_url",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 115,
      "signature": "test_create_single_url_import_invalid_url(client)",
      "summary": "Test single URL import with invalid URL format.",
      "layer": "test",
      "docstring": "Test single URL import with invalid URL format.",
      "category": "test"
    },
    {
      "name": "test_create_single_url_import_missing_url",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 126,
      "signature": "test_create_single_url_import_missing_url(client)",
      "summary": "Test single URL import without URL field.",
      "layer": "test",
      "docstring": "Test single URL import without URL field.",
      "category": "test"
    },
    {
      "name": "test_create_single_url_import_invalid_priority",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 137,
      "signature": "test_create_single_url_import_invalid_priority(client)",
      "summary": "Test single URL import with invalid priority.",
      "layer": "test",
      "docstring": "Test single URL import with invalid priority.",
      "category": "test"
    },
    {
      "name": "test_create_single_url_import_default_priority",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 150,
      "signature": "test_create_single_url_import_default_priority(client, db_session)",
      "summary": "Test single URL import with default priority.",
      "layer": "test",
      "docstring": "Test single URL import with default priority.",
      "category": "test"
    },
    {
      "name": "test_create_single_url_import_creates_import_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 170,
      "signature": "async test_create_single_url_import_creates_import_session(client, db_session)",
      "summary": "Test that ImportSession record is created in database.",
      "layer": "test",
      "docstring": "Test that ImportSession record is created in database.",
      "category": "test"
    },
    {
      "name": "test_get_ingestion_status_queued",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 202,
      "signature": "async test_get_ingestion_status_queued(client, db_session)",
      "summary": "Test getting status of queued job.",
      "layer": "test",
      "docstring": "Test getting status of queued job.",
      "category": "test"
    },
    {
      "name": "test_get_ingestion_status_complete",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 236,
      "signature": "async test_get_ingestion_status_complete(client, db_session)",
      "summary": "Test getting status of completed job with listing created.",
      "layer": "test",
      "docstring": "Test getting status of completed job with listing created.",
      "category": "test"
    },
    {
      "name": "test_get_ingestion_status_partial",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 278,
      "signature": "async test_get_ingestion_status_partial(client, db_session)",
      "summary": "Test getting status of partially successful job.",
      "layer": "test",
      "docstring": "Test getting status of partially successful job.",
      "category": "test"
    },
    {
      "name": "test_get_ingestion_status_failed",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 317,
      "signature": "async test_get_ingestion_status_failed(client, db_session)",
      "summary": "Test getting status of failed job with error details.",
      "layer": "test",
      "docstring": "Test getting status of failed job with error details.",
      "category": "test"
    },
    {
      "name": "test_get_ingestion_status_not_found",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 352,
      "signature": "test_get_ingestion_status_not_found(client)",
      "summary": "Test getting status of non-existent job.",
      "layer": "test",
      "docstring": "Test getting status of non-existent job.",
      "category": "test"
    },
    {
      "name": "test_get_ingestion_status_invalid_uuid",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 362,
      "signature": "test_get_ingestion_status_invalid_uuid(client)",
      "summary": "Test getting status with invalid UUID format.",
      "layer": "test",
      "docstring": "Test getting status with invalid UUID format.",
      "category": "test"
    },
    {
      "name": "test_get_ingestion_status_running",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 371,
      "signature": "async test_get_ingestion_status_running(client, db_session)",
      "summary": "Test getting status of job currently running.",
      "layer": "test",
      "docstring": "Test getting status of job currently running.",
      "category": "test"
    },
    {
      "name": "test_create_and_retrieve_workflow",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 407,
      "signature": "async test_create_and_retrieve_workflow(client, db_session)",
      "summary": "Test complete workflow: create job -> retrieve status.",
      "layer": "test",
      "docstring": "Test complete workflow: create job -> retrieve status.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_csv_success",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 459,
      "signature": "test_create_bulk_import_csv_success(client, db_session)",
      "summary": "Test successful bulk import with CSV file.",
      "layer": "test",
      "docstring": "Test successful bulk import with CSV file.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_json_success",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 485,
      "signature": "test_create_bulk_import_json_success(client, db_session)",
      "summary": "Test successful bulk import with JSON file.",
      "layer": "test",
      "docstring": "Test successful bulk import with JSON file.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_empty_file",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 509,
      "signature": "test_create_bulk_import_empty_file(client)",
      "summary": "Test bulk import with empty file returns 400.",
      "layer": "test",
      "docstring": "Test bulk import with empty file returns 400.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_too_many_urls",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 522,
      "signature": "test_create_bulk_import_too_many_urls(client)",
      "summary": "Test bulk import with more than 1000 URLs returns 413.",
      "layer": "test",
      "docstring": "Test bulk import with more than 1000 URLs returns 413.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_invalid_csv",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 537,
      "signature": "test_create_bulk_import_invalid_csv(client)",
      "summary": "Test bulk import with invalid CSV format returns 400.",
      "layer": "test",
      "docstring": "Test bulk import with invalid CSV format returns 400.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_invalid_json",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 550,
      "signature": "test_create_bulk_import_invalid_json(client)",
      "summary": "Test bulk import with invalid JSON format returns 400.",
      "layer": "test",
      "docstring": "Test bulk import with invalid JSON format returns 400.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_invalid_urls",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 563,
      "signature": "test_create_bulk_import_invalid_urls(client)",
      "summary": "Test bulk import with invalid URLs returns 422.",
      "layer": "test",
      "docstring": "Test bulk import with invalid URLs returns 422.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_deduplicates_urls",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 576,
      "signature": "test_create_bulk_import_deduplicates_urls(client, db_session)",
      "summary": "Test bulk import deduplicates URLs.",
      "layer": "test",
      "docstring": "Test bulk import deduplicates URLs.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_creates_parent_child_sessions",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 597,
      "signature": "async test_create_bulk_import_creates_parent_child_sessions(client, db_session)",
      "summary": "Test bulk import creates parent and child ImportSession records.",
      "layer": "test",
      "docstring": "Test bulk import creates parent and child ImportSession records.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_queues_celery_tasks",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 637,
      "signature": "async test_create_bulk_import_queues_celery_tasks(client, db_session)",
      "summary": "Test bulk import queues Celery tasks for each URL.",
      "layer": "test",
      "docstring": "Test bulk import queues Celery tasks for each URL.",
      "category": "test"
    },
    {
      "name": "test_create_bulk_import_no_valid_urls",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 662,
      "signature": "test_create_bulk_import_no_valid_urls(client)",
      "summary": "Test bulk import with only empty rows returns 400.",
      "layer": "test",
      "docstring": "Test bulk import with only empty rows returns 400.",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_all_queued",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 681,
      "signature": "async test_get_bulk_status_all_queued(client, db_session)",
      "summary": "Test bulk status when all children are queued.",
      "layer": "test",
      "docstring": "Test bulk status when all children are queued.",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_running",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 746,
      "signature": "async test_get_bulk_status_running(client, db_session)",
      "summary": "Test bulk status when some jobs are running/queued.",
      "layer": "test",
      "docstring": "Test bulk status when some jobs are running/queued.",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_complete",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 811,
      "signature": "async test_get_bulk_status_complete(client, db_session)",
      "summary": "Test bulk status when all jobs are complete (100% done).",
      "layer": "test",
      "docstring": "Test bulk status when all jobs are complete (100% done).",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_partial",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 876,
      "signature": "async test_get_bulk_status_partial(client, db_session)",
      "summary": "Test bulk status with mixed success and failure.",
      "layer": "test",
      "docstring": "Test bulk status with mixed success and failure.",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_failed",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 952,
      "signature": "async test_get_bulk_status_failed(client, db_session)",
      "summary": "Test bulk status when all children failed.",
      "layer": "test",
      "docstring": "Test bulk status when all children failed.",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_not_found",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 1011,
      "signature": "test_get_bulk_status_not_found(client)",
      "summary": "Test bulk status retrieval for non-existent bulk job.",
      "layer": "test",
      "docstring": "Test bulk status retrieval for non-existent bulk job.",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_invalid_uuid",
      "kind": "function",
      "path": "tests/test_ingestion_api.py",
      "line": 1021,
      "signature": "test_get_bulk_status_invalid_uuid(client)",
      "summary": "Test bulk status retrieval with invalid UUID format.",
      "layer": "test",
      "docstring": "Test bulk status retrieval with invalid UUID format.",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_pagination",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 1030,
      "signature": "async test_get_bulk_status_pagination(client, db_session)",
      "summary": "Test bulk status with pagination (offset/limit).",
      "layer": "test",
      "docstring": "Test bulk status with pagination (offset/limit).",
      "category": "test"
    },
    {
      "name": "test_get_bulk_status_has_more_flag",
      "kind": "async_function",
      "path": "tests/test_ingestion_api.py",
      "line": 1097,
      "signature": "async test_get_bulk_status_has_more_flag(client, db_session)",
      "summary": "Test has_more flag calculation.",
      "layer": "test",
      "docstring": "Test has_more flag calculation.",
      "category": "test"
    },
    {
      "name": "create_realistic_ebay_response",
      "kind": "function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 59,
      "signature": "create_realistic_ebay_response(item_id: str, variation: int) -> dict[str, Any]",
      "summary": "Create a realistic eBay Browse API response.",
      "layer": "test",
      "docstring": "Create a realistic eBay Browse API response.\n\nArgs:\n    item_id: eBay item ID (12 digits)\n    variation: Variation number for different listings (0-49)\n\nReturns:\n    Dictionary matching eBay Browse API v1 response schema",
      "category": "test"
    },
    {
      "name": "MockHttpxClient",
      "kind": "class",
      "path": "tests/test_ingestion_e2e.py",
      "line": 146,
      "signature": "class MockHttpxClient",
      "summary": "Mock httpx.AsyncClient that returns realistic eBay API responses.",
      "layer": "test",
      "docstring": "Mock httpx.AsyncClient that returns realistic eBay API responses.",
      "category": "test"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "tests/test_ingestion_e2e.py",
      "line": 149,
      "signature": "__init__(self)",
      "summary": "",
      "layer": "test",
      "parent": "MockHttpxClient",
      "category": "test"
    },
    {
      "name": "get",
      "kind": "async_method",
      "path": "tests/test_ingestion_e2e.py",
      "line": 153,
      "signature": "async get(self, url: str) -> Response",
      "summary": "Mock GET request to eBay Browse API.",
      "layer": "test",
      "parent": "MockHttpxClient",
      "docstring": "Mock GET request to eBay Browse API.",
      "category": "test"
    },
    {
      "name": "__aenter__",
      "kind": "async_method",
      "path": "tests/test_ingestion_e2e.py",
      "line": 181,
      "signature": "async __aenter__(self)",
      "summary": "",
      "layer": "test",
      "parent": "MockHttpxClient",
      "category": "test"
    },
    {
      "name": "__aexit__",
      "kind": "async_method",
      "path": "tests/test_ingestion_e2e.py",
      "line": 184,
      "signature": "async __aexit__(self, exc_type, exc_val, exc_tb)",
      "summary": "",
      "layer": "test",
      "parent": "MockHttpxClient",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 189,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "app",
      "kind": "function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 209,
      "signature": "app(db_session)",
      "summary": "Create FastAPI test app with ingestion router.",
      "layer": "test",
      "docstring": "Create FastAPI test app with ingestion router.",
      "category": "test"
    },
    {
      "name": "mock_httpx_client",
      "kind": "function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 227,
      "signature": "mock_httpx_client()",
      "summary": "Provide mock httpx client with realistic eBay responses.",
      "layer": "test",
      "docstring": "Provide mock httpx client with realistic eBay responses.",
      "category": "test"
    },
    {
      "name": "bulk_urls_csv",
      "kind": "function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 233,
      "signature": "bulk_urls_csv() -> bytes",
      "summary": "Generate CSV file with 50 test eBay URLs.",
      "layer": "test",
      "docstring": "Generate CSV file with 50 test eBay URLs.",
      "category": "test"
    },
    {
      "name": "test_single_url_import_e2e_latency",
      "kind": "async_function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 254,
      "signature": "async test_single_url_import_e2e_latency(app, db_session, mock_httpx_client, monkeypatch)",
      "summary": "Test single eBay URL import with realistic data and <10s p50 latency.",
      "layer": "test",
      "docstring": "Test single eBay URL import with realistic data and <10s p50 latency.\n\nWorkflow:\n1. POST /api/v1/ingest/single with eBay URL\n2. Celery task processes URL (mocked with direct service call)\n3. Measure end-to-end latency\n4. Verify listing created with all expected fields\n5. Verify provenance = ebay_api\n6. Verify latency < 10s\n\nSuccess Criteria:\n- Latency p50 < 10s\n- All fields present (title, price, condition, image, seller, CPU, RAM, storage)\n- Provenance = \"ebay\"\n- Quality = \"full\"\n- Listing persisted in database",
      "category": "test"
    },
    {
      "name": "test_bulk_import_50_urls_e2e",
      "kind": "async_function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 352,
      "signature": "async test_bulk_import_50_urls_e2e(app, db_session, mock_httpx_client, bulk_urls_csv)",
      "summary": "Test bulk import of 50 eBay URLs with realistic data and <3 min completion.",
      "layer": "test",
      "docstring": "Test bulk import of 50 eBay URLs with realistic data and <3 min completion.\n\nWorkflow:\n1. POST /api/v1/ingest/bulk with CSV file (50 URLs)\n2. Verify parent ImportSession created\n3. Verify 50 child ImportSessions created\n4. Process all URLs (simulate Celery tasks with direct service calls)\n5. Measure total completion time\n6. Verify 100% success rate\n7. Verify no duplicates in DB\n8. Verify all listings have correct fields\n\nSuccess Criteria:\n- Completion time < 3 minutes\n- 100% success rate (50/50 URLs)\n- No duplicate listings\n- All listings have full data quality\n- All listings have provenance = \"ebay\"",
      "category": "test"
    },
    {
      "name": "test_single_url_deduplication_e2e",
      "kind": "async_function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 482,
      "signature": "async test_single_url_deduplication_e2e(app, db_session, mock_httpx_client)",
      "summary": "Test re-importing same URL returns existing listing (no duplicate).",
      "layer": "test",
      "docstring": "Test re-importing same URL returns existing listing (no duplicate).\n\nWorkflow:\n1. Import URL #1 \u2192 listing created\n2. Import URL #1 again \u2192 listing updated (same ID)\n3. Verify only 1 listing exists in DB\n4. Verify status = \"updated\" on second import\n\nSuccess Criteria:\n- First import creates listing\n- Second import updates same listing (same listing_id)\n- No duplicate listings in database\n- Deduplication works via vendor_item_id",
      "category": "test"
    },
    {
      "name": "test_single_url_data_quality_e2e",
      "kind": "async_function",
      "path": "tests/test_ingestion_e2e.py",
      "line": 547,
      "signature": "async test_single_url_data_quality_e2e(app, db_session, mock_httpx_client)",
      "summary": "Test that imported listing has all expected fields with correct values.",
      "layer": "test",
      "docstring": "Test that imported listing has all expected fields with correct values.\n\nVerifies:\n- Title is extracted correctly\n- Price is positive decimal\n- Condition is normalized (new|refurb|used)\n- Marketplace is \"ebay\"\n- Vendor item ID matches eBay item number\n- Seller is extracted\n- Image URL is present (from raw payload)",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 43,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "app",
      "kind": "function",
      "path": "tests/test_ingestion_integration.py",
      "line": 63,
      "signature": "app(db_session)",
      "summary": "Create FastAPI test app with ingestion router.",
      "layer": "test",
      "docstring": "Create FastAPI test app with ingestion router.",
      "category": "test"
    },
    {
      "name": "client",
      "kind": "function",
      "path": "tests/test_ingestion_integration.py",
      "line": 81,
      "signature": "client(app)",
      "summary": "Create test client for FastAPI app.",
      "layer": "test",
      "docstring": "Create test client for FastAPI app.",
      "category": "test"
    },
    {
      "name": "test_single_url_complete_flow",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 92,
      "signature": "async test_single_url_complete_flow(client, db_session, monkeypatch)",
      "summary": "Test complete single URL ingestion workflow from API to ImportSession update.",
      "layer": "test",
      "docstring": "Test complete single URL ingestion workflow from API to ImportSession update.\n\nWorkflow:\n1. POST /api/v1/ingest/single \u2192 creates ImportSession with status=queued\n2. Celery task executes \u2192 calls IngestionService.ingest_single_url (mocked)\n3. ImportSession updated \u2192 status=complete with result data\n4. Verify ImportSession reflects successful ingestion",
      "category": "test"
    },
    {
      "name": "test_bulk_import_complete_flow",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 176,
      "signature": "async test_bulk_import_complete_flow(client, db_session, monkeypatch)",
      "summary": "Test complete bulk import workflow.",
      "layer": "test",
      "docstring": "Test complete bulk import workflow.\n\nWorkflow:\n1. POST /api/v1/ingest/bulk with CSV \u2192 creates parent + child ImportSessions\n2. Each child job executes (mocked)\n3. GET /api/v1/ingest/bulk/{id} \u2192 poll status until all complete",
      "category": "test"
    },
    {
      "name": "test_reimport_same_url_no_duplicate",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 238,
      "signature": "async test_reimport_same_url_no_duplicate(client, db_session, monkeypatch)",
      "summary": "Test re-importing same URL returns same listing_id (no duplicate).",
      "layer": "test",
      "docstring": "Test re-importing same URL returns same listing_id (no duplicate).\n\nWorkflow:\n1. Import URL \u2192 listing_id=999, price=$100\n2. Re-import same URL \u2192 listing_id=999 (same), price=$105",
      "category": "test"
    },
    {
      "name": "test_price_change_workflow_tracking",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 326,
      "signature": "async test_price_change_workflow_tracking(client, db_session, monkeypatch)",
      "summary": "Test price change workflow tracking in ImportSession.",
      "layer": "test",
      "docstring": "Test price change workflow tracking in ImportSession.\n\nNote: Actual event emission is tested in test_event_service.py.\nThis test verifies the ImportSession tracks price changes correctly.",
      "category": "test"
    },
    {
      "name": "test_adapter_disabled_error_handling",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 410,
      "signature": "async test_adapter_disabled_error_handling(client, db_session, monkeypatch)",
      "summary": "Test error handling when adapter fails or is disabled.",
      "layer": "test",
      "docstring": "Test error handling when adapter fails or is disabled.\n\nWorkflow:\n1. Import job created\n2. IngestionService returns failure result\n3. ImportSession status = failed with error message",
      "category": "test"
    },
    {
      "name": "test_bulk_import_pagination_works",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 480,
      "signature": "async test_bulk_import_pagination_works(client, db_session)",
      "summary": "Test that pagination works for bulk status endpoint.",
      "layer": "test",
      "docstring": "Test that pagination works for bulk status endpoint.",
      "category": "test"
    },
    {
      "name": "test_single_url_partial_quality",
      "kind": "async_function",
      "path": "tests/test_ingestion_integration.py",
      "line": 543,
      "signature": "async test_single_url_partial_quality(client, db_session, monkeypatch)",
      "summary": "Test single URL import with partial quality data.",
      "layer": "test",
      "docstring": "Test single URL import with partial quality data.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 39,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "mock_normalized_data",
      "kind": "function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 59,
      "signature": "mock_normalized_data()",
      "summary": "Fixture providing sample normalized listing data.",
      "layer": "test",
      "docstring": "Fixture providing sample normalized listing data.",
      "category": "test"
    },
    {
      "name": "mock_adapter",
      "kind": "function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 78,
      "signature": "mock_adapter()",
      "summary": "Fixture providing a mock adapter.",
      "layer": "test",
      "docstring": "Fixture providing a mock adapter.",
      "category": "test"
    },
    {
      "name": "test_ingest_new_listing_success",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 91,
      "signature": "async test_ingest_new_listing_success(db_session, mock_normalized_data)",
      "summary": "Test complete workflow for creating new listing.",
      "layer": "test",
      "docstring": "Test complete workflow for creating new listing.",
      "category": "test"
    },
    {
      "name": "test_ingest_duplicate_listing_updates",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 127,
      "signature": "async test_ingest_duplicate_listing_updates(db_session, mock_normalized_data)",
      "summary": "Test workflow updates existing listing.",
      "layer": "test",
      "docstring": "Test workflow updates existing listing.",
      "category": "test"
    },
    {
      "name": "test_ingest_normalizes_data",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 166,
      "signature": "async test_ingest_normalizes_data(db_session)",
      "summary": "Test that data normalization is applied during ingestion.",
      "layer": "test",
      "docstring": "Test that data normalization is applied during ingestion.",
      "category": "test"
    },
    {
      "name": "test_ingest_creates_dedup_hash",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 199,
      "signature": "async test_ingest_creates_dedup_hash(db_session, mock_normalized_data)",
      "summary": "Test that dedup hash is generated and stored.",
      "layer": "test",
      "docstring": "Test that dedup hash is generated and stored.",
      "category": "test"
    },
    {
      "name": "test_emits_listing_created_event",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 225,
      "signature": "async test_emits_listing_created_event(db_session, mock_normalized_data)",
      "summary": "Test that listing.created event is emitted.",
      "layer": "test",
      "docstring": "Test that listing.created event is emitted.",
      "category": "test"
    },
    {
      "name": "test_emits_price_changed_event_on_update",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 249,
      "signature": "async test_emits_price_changed_event_on_update(db_session, monkeypatch)",
      "summary": "Test that price.changed event is emitted when price changes significantly.",
      "layer": "test",
      "docstring": "Test that price.changed event is emitted when price changes significantly.\n\nNOTE: This integration is complex due to settings mocking across async boundaries.\nThe individual components (check_and_emit_price_change,\nshould_emit_price_change) are thoroughly tested in test_event_service.py\nwith >99% coverage.",
      "category": "test"
    },
    {
      "name": "test_no_price_event_for_small_change",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 308,
      "signature": "async test_no_price_event_for_small_change(db_session, mock_normalized_data)",
      "summary": "Test that price.changed event is NOT emitted for insignificant price changes.",
      "layer": "test",
      "docstring": "Test that price.changed event is NOT emitted for insignificant price changes.",
      "category": "test"
    },
    {
      "name": "test_stores_raw_payload",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 348,
      "signature": "async test_stores_raw_payload(db_session, mock_normalized_data)",
      "summary": "Test that raw payload is stored.",
      "layer": "test",
      "docstring": "Test that raw payload is stored.",
      "category": "test"
    },
    {
      "name": "test_truncates_large_payload",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 379,
      "signature": "async test_truncates_large_payload(db_session)",
      "summary": "Test that large payloads are truncated to stay within size limit.",
      "layer": "test",
      "docstring": "Test that large payloads are truncated to stay within size limit.",
      "category": "test"
    },
    {
      "name": "test_handles_adapter_error_gracefully",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 420,
      "signature": "async test_handles_adapter_error_gracefully(db_session)",
      "summary": "Test error handling when adapter fails.",
      "layer": "test",
      "docstring": "Test error handling when adapter fails.",
      "category": "test"
    },
    {
      "name": "test_handles_extraction_error_gracefully",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 440,
      "signature": "async test_handles_extraction_error_gracefully(db_session)",
      "summary": "Test error handling when extraction fails.",
      "layer": "test",
      "docstring": "Test error handling when extraction fails.",
      "category": "test"
    },
    {
      "name": "test_handles_normalization_error_gracefully",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 456,
      "signature": "async test_handles_normalization_error_gracefully(db_session, mock_normalized_data)",
      "summary": "Test error handling when normalization fails.",
      "layer": "test",
      "docstring": "Test error handling when normalization fails.",
      "category": "test"
    },
    {
      "name": "test_handles_database_error_gracefully",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 475,
      "signature": "async test_handles_database_error_gracefully(db_session, mock_normalized_data)",
      "summary": "Test error handling when database operation fails.",
      "layer": "test",
      "docstring": "Test error handling when database operation fails.",
      "category": "test"
    },
    {
      "name": "test_deduplication_result_included_in_response",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 499,
      "signature": "async test_deduplication_result_included_in_response(db_session, mock_normalized_data)",
      "summary": "Test that deduplication result is included in ingestion result.",
      "layer": "test",
      "docstring": "Test that deduplication result is included in ingestion result.",
      "category": "test"
    },
    {
      "name": "test_deduplication_finds_existing_by_vendor_id",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 517,
      "signature": "async test_deduplication_finds_existing_by_vendor_id(db_session, mock_normalized_data)",
      "summary": "Test that deduplication finds existing listing by vendor_item_id.",
      "layer": "test",
      "docstring": "Test that deduplication finds existing listing by vendor_item_id.",
      "category": "test"
    },
    {
      "name": "test_maps_condition_to_enum",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 554,
      "signature": "async test_maps_condition_to_enum(db_session)",
      "summary": "Test that condition strings are mapped to Condition enum values.",
      "layer": "test",
      "docstring": "Test that condition strings are mapped to Condition enum values.",
      "category": "test"
    },
    {
      "name": "test_quality_assessment_full",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 594,
      "signature": "async test_quality_assessment_full(db_session)",
      "summary": "Test quality assessment returns 'full' for complete data.",
      "layer": "test",
      "docstring": "Test quality assessment returns 'full' for complete data.",
      "category": "test"
    },
    {
      "name": "test_quality_assessment_partial",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 621,
      "signature": "async test_quality_assessment_partial(db_session)",
      "summary": "Test quality assessment returns 'partial' for incomplete data.",
      "layer": "test",
      "docstring": "Test quality assessment returns 'partial' for incomplete data.",
      "category": "test"
    },
    {
      "name": "test_uses_jsonld_adapter_for_generic_urls",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 648,
      "signature": "async test_uses_jsonld_adapter_for_generic_urls(db_session)",
      "summary": "Test that JSON-LD adapter is used for generic URLs.",
      "layer": "test",
      "docstring": "Test that JSON-LD adapter is used for generic URLs.",
      "category": "test"
    },
    {
      "name": "test_uses_ebay_adapter_for_ebay_urls",
      "kind": "async_function",
      "path": "tests/test_ingestion_orchestrator.py",
      "line": 670,
      "signature": "async test_uses_ebay_adapter_for_ebay_urls(db_session)",
      "summary": "Test that eBay adapter is used for eBay URLs.",
      "layer": "test",
      "docstring": "Test that eBay adapter is used for eBay URLs.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 24,
      "signature": "async db_session()",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "sample_cpu",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 43,
      "signature": "async sample_cpu(db_session: AsyncSession)",
      "summary": "Create a sample CPU for testing.",
      "layer": "test",
      "docstring": "Create a sample CPU for testing.",
      "category": "test"
    },
    {
      "name": "sample_listing",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 58,
      "signature": "async sample_listing(db_session: AsyncSession)",
      "summary": "Create a sample listing for testing.",
      "layer": "test",
      "docstring": "Create a sample listing for testing.",
      "category": "test"
    },
    {
      "name": "test_create_listing_persists_all_fields",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 74,
      "signature": "async test_create_listing_persists_all_fields(db_session: AsyncSession, sample_cpu: Cpu)",
      "summary": "Test that _create_listing persists all extracted fields.",
      "layer": "test",
      "docstring": "Test that _create_listing persists all extracted fields.",
      "category": "test"
    },
    {
      "name": "test_create_listing_handles_missing_fields_gracefully",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 118,
      "signature": "async test_create_listing_handles_missing_fields_gracefully(db_session: AsyncSession)",
      "summary": "Test that _create_listing handles missing optional fields.",
      "layer": "test",
      "docstring": "Test that _create_listing handles missing optional fields.",
      "category": "test"
    },
    {
      "name": "test_create_listing_cpu_lookup_success",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 148,
      "signature": "async test_create_listing_cpu_lookup_success(db_session: AsyncSession, sample_cpu: Cpu)",
      "summary": "Test that CPU lookup works correctly.",
      "layer": "test",
      "docstring": "Test that CPU lookup works correctly.",
      "category": "test"
    },
    {
      "name": "test_create_listing_cpu_lookup_not_found",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 169,
      "signature": "async test_create_listing_cpu_lookup_not_found(db_session: AsyncSession)",
      "summary": "Test that CPU lookup handles non-existent CPUs gracefully.",
      "layer": "test",
      "docstring": "Test that CPU lookup handles non-existent CPUs gracefully.",
      "category": "test"
    },
    {
      "name": "test_update_listing_preserves_and_updates_fields",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 190,
      "signature": "async test_update_listing_preserves_and_updates_fields(db_session: AsyncSession, sample_listing: Listing, sample_cpu: Cpu)",
      "summary": "Test that _update_listing updates all fields without data loss.",
      "layer": "test",
      "docstring": "Test that _update_listing updates all fields without data loss.",
      "category": "test"
    },
    {
      "name": "test_update_listing_partial_updates",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 230,
      "signature": "async test_update_listing_partial_updates(db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test that _update_listing handles partial updates (not all fields provided).",
      "layer": "test",
      "docstring": "Test that _update_listing handles partial updates (not all fields provided).",
      "category": "test"
    },
    {
      "name": "test_parse_brand_and_model_from_title",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 261,
      "signature": "async test_parse_brand_and_model_from_title(db_session: AsyncSession)",
      "summary": "Test brand/model parsing from various title formats.",
      "layer": "test",
      "docstring": "Test brand/model parsing from various title formats.",
      "category": "test"
    },
    {
      "name": "test_parse_brand_and_model_edge_cases",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 284,
      "signature": "async test_parse_brand_and_model_edge_cases(db_session: AsyncSession)",
      "summary": "Test brand/model parsing edge cases.",
      "layer": "test",
      "docstring": "Test brand/model parsing edge cases.",
      "category": "test"
    },
    {
      "name": "test_normalizer_integrates_brand_model_parsing",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 306,
      "signature": "async test_normalizer_integrates_brand_model_parsing(db_session: AsyncSession)",
      "summary": "Test that normalize() integrates brand/model parsing.",
      "layer": "test",
      "docstring": "Test that normalize() integrates brand/model parsing.",
      "category": "test"
    },
    {
      "name": "test_normalizer_preserves_existing_brand_model",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 328,
      "signature": "async test_normalizer_preserves_existing_brand_model(db_session: AsyncSession)",
      "summary": "Test that normalize() preserves existing manufacturer/model if provided.",
      "layer": "test",
      "docstring": "Test that normalize() preserves existing manufacturer/model if provided.",
      "category": "test"
    },
    {
      "name": "test_find_cpu_by_model_exact_match",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 351,
      "signature": "async test_find_cpu_by_model_exact_match(db_session: AsyncSession, sample_cpu: Cpu)",
      "summary": "Test CPU lookup with exact match.",
      "layer": "test",
      "docstring": "Test CPU lookup with exact match.",
      "category": "test"
    },
    {
      "name": "test_find_cpu_by_model_partial_match",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 360,
      "signature": "async test_find_cpu_by_model_partial_match(db_session: AsyncSession, sample_cpu: Cpu)",
      "summary": "Test CPU lookup with partial match.",
      "layer": "test",
      "docstring": "Test CPU lookup with partial match.",
      "category": "test"
    },
    {
      "name": "test_find_cpu_by_model_case_insensitive",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 372,
      "signature": "async test_find_cpu_by_model_case_insensitive(db_session: AsyncSession, sample_cpu: Cpu)",
      "summary": "Test CPU lookup is case-insensitive.",
      "layer": "test",
      "docstring": "Test CPU lookup is case-insensitive.",
      "category": "test"
    },
    {
      "name": "test_find_cpu_by_model_not_found",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 381,
      "signature": "async test_find_cpu_by_model_not_found(db_session: AsyncSession)",
      "summary": "Test CPU lookup returns None when not found.",
      "layer": "test",
      "docstring": "Test CPU lookup returns None when not found.",
      "category": "test"
    },
    {
      "name": "test_find_cpu_by_model_empty_string",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 390,
      "signature": "async test_find_cpu_by_model_empty_string(db_session: AsyncSession)",
      "summary": "Test CPU lookup handles empty string.",
      "layer": "test",
      "docstring": "Test CPU lookup handles empty string.",
      "category": "test"
    },
    {
      "name": "test_find_cpu_by_model_none",
      "kind": "async_function",
      "path": "tests/test_ingestion_service.py",
      "line": 399,
      "signature": "async test_find_cpu_by_model_none(db_session: AsyncSession)",
      "summary": "Test CPU lookup handles None.",
      "layer": "test",
      "docstring": "Test CPU lookup handles None.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 32,
      "signature": "async db_session()",
      "summary": "Provide an isolated in-memory database session for task tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for task tests.",
      "category": "test"
    },
    {
      "name": "test_successful_ingestion_complete_quality",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 51,
      "signature": "async test_successful_ingestion_complete_quality(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task should update ImportSession to 'complete' for full quality ingestion.",
      "layer": "test",
      "docstring": "Task should update ImportSession to 'complete' for full quality ingestion.",
      "category": "test"
    },
    {
      "name": "test_successful_ingestion_partial_quality",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 127,
      "signature": "async test_successful_ingestion_partial_quality(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task should update ImportSession to 'partial' for partial quality ingestion.",
      "layer": "test",
      "docstring": "Task should update ImportSession to 'partial' for partial quality ingestion.",
      "category": "test"
    },
    {
      "name": "test_failed_ingestion",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 197,
      "signature": "async test_failed_ingestion(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task should update ImportSession to 'failed' when ingestion fails.",
      "layer": "test",
      "docstring": "Task should update ImportSession to 'failed' when ingestion fails.",
      "category": "test"
    },
    {
      "name": "test_import_session_not_found",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 264,
      "signature": "async test_import_session_not_found(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task should return failure when ImportSession not found.",
      "layer": "test",
      "docstring": "Task should return failure when ImportSession not found.",
      "category": "test"
    },
    {
      "name": "test_transient_error_propagates",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 297,
      "signature": "async test_transient_error_propagates(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task async function should propagate transient errors for retry handling.",
      "layer": "test",
      "docstring": "Task async function should propagate transient errors for retry handling.",
      "category": "test"
    },
    {
      "name": "test_permanent_error_propagates",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 345,
      "signature": "async test_permanent_error_propagates(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task async function should propagate permanent errors (ValueError).",
      "layer": "test",
      "docstring": "Task async function should propagate permanent errors (ValueError).",
      "category": "test"
    },
    {
      "name": "test_status_transition_queued_to_running",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 393,
      "signature": "async test_status_transition_queued_to_running(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task should transition ImportSession status from queued to running.",
      "layer": "test",
      "docstring": "Task should transition ImportSession status from queued to running.",
      "category": "test"
    },
    {
      "name": "test_result_storage_in_conflicts_json",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 457,
      "signature": "async test_result_storage_in_conflicts_json(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Task should store result details in ImportSession.conflicts_json.",
      "layer": "test",
      "docstring": "Task should store result details in ImportSession.conflicts_json.",
      "category": "test"
    },
    {
      "name": "sample_listing",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 534,
      "signature": "async sample_listing(db_session: AsyncSession)",
      "summary": "Create a sample listing for RawPayload tests.",
      "layer": "test",
      "docstring": "Create a sample listing for RawPayload tests.",
      "category": "test"
    },
    {
      "name": "test_cleanup_expired_payloads_deletes_old_records",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 550,
      "signature": "async test_cleanup_expired_payloads_deletes_old_records(db_session: AsyncSession, sample_listing: Listing, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test cleanup deletes records older than TTL.",
      "layer": "test",
      "docstring": "Test cleanup deletes records older than TTL.",
      "category": "test"
    },
    {
      "name": "test_cleanup_expired_payloads_preserves_recent_records",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 618,
      "signature": "async test_cleanup_expired_payloads_preserves_recent_records(db_session: AsyncSession, sample_listing: Listing, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test cleanup preserves records newer than TTL.",
      "layer": "test",
      "docstring": "Test cleanup preserves records newer than TTL.",
      "category": "test"
    },
    {
      "name": "test_cleanup_expired_payloads_empty_table",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 672,
      "signature": "async test_cleanup_expired_payloads_empty_table(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test cleanup handles empty table gracefully.",
      "layer": "test",
      "docstring": "Test cleanup handles empty table gracefully.",
      "category": "test"
    },
    {
      "name": "test_cleanup_expired_payloads_returns_statistics",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 703,
      "signature": "async test_cleanup_expired_payloads_returns_statistics(db_session: AsyncSession, sample_listing: Listing, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test cleanup returns accurate statistics.",
      "layer": "test",
      "docstring": "Test cleanup returns accurate statistics.",
      "category": "test"
    },
    {
      "name": "test_cleanup_task_error_handling",
      "kind": "function",
      "path": "tests/test_ingestion_task.py",
      "line": 753,
      "signature": "test_cleanup_task_error_handling(monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test cleanup task handles errors gracefully without crashing beat schedule.",
      "layer": "test",
      "docstring": "Test cleanup task handles errors gracefully without crashing beat schedule.",
      "category": "test"
    },
    {
      "name": "test_cleanup_respects_ttl_boundary",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 777,
      "signature": "async test_cleanup_respects_ttl_boundary(db_session: AsyncSession, sample_listing: Listing, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test cleanup respects exact TTL boundary (30 days).",
      "layer": "test",
      "docstring": "Test cleanup respects exact TTL boundary (30 days).",
      "category": "test"
    },
    {
      "name": "test_ingestion_task_updates_progress",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 847,
      "signature": "async test_ingestion_task_updates_progress(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test that the Celery task updates progress_pct at milestones.",
      "layer": "test",
      "docstring": "Test that the Celery task updates progress_pct at milestones.",
      "category": "test"
    },
    {
      "name": "test_ingestion_task_sets_progress_on_failure",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 914,
      "signature": "async test_ingestion_task_sets_progress_on_failure(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test that progress_pct is set appropriately when task fails.",
      "layer": "test",
      "docstring": "Test that progress_pct is set appropriately when task fails.",
      "category": "test"
    },
    {
      "name": "test_ingestion_task_sets_progress_on_exception",
      "kind": "async_function",
      "path": "tests/test_ingestion_task.py",
      "line": 977,
      "signature": "async test_ingestion_task_sets_progress_on_exception(db_session: AsyncSession, monkeypatch: pytest.MonkeyPatch)",
      "summary": "Test that progress_pct is preserved when exception occurs.",
      "layer": "test",
      "docstring": "Test that progress_pct is preserved when exception occurs.",
      "category": "test"
    },
    {
      "name": "TestJsonLdAdapter",
      "kind": "class",
      "path": "tests/test_jsonld_adapter.py",
      "line": 13,
      "signature": "class TestJsonLdAdapter",
      "summary": "Test suite for JsonLdAdapter.",
      "layer": "test",
      "docstring": "Test suite for JsonLdAdapter.",
      "category": "test"
    },
    {
      "name": "adapter",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 17,
      "signature": "adapter(self)",
      "summary": "Create JsonLdAdapter instance.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Create JsonLdAdapter instance.",
      "category": "test"
    },
    {
      "name": "test_initialization",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 21,
      "signature": "test_initialization(self, adapter)",
      "summary": "Test adapter initialization.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test adapter initialization.",
      "category": "test"
    },
    {
      "name": "test_supports_url",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 29,
      "signature": "test_supports_url(self, adapter)",
      "summary": "Test that adapter supports all URLs (wildcard).",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test that adapter supports all URLs (wildcard).",
      "category": "test"
    },
    {
      "name": "test_extract_from_jsonld",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 36,
      "signature": "async test_extract_from_jsonld(self, adapter)",
      "summary": "Test extraction from JSON-LD Product schema.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test extraction from JSON-LD Product schema.",
      "category": "test"
    },
    {
      "name": "test_extract_from_microdata",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 80,
      "signature": "async test_extract_from_microdata(self, adapter)",
      "summary": "Test fallback to Microdata when JSON-LD absent.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test fallback to Microdata when JSON-LD absent.",
      "category": "test"
    },
    {
      "name": "test_nested_offers_takes_lowest",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 107,
      "signature": "async test_nested_offers_takes_lowest(self, adapter)",
      "summary": "Test handling of multiple offers - take lowest price.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test handling of multiple offers - take lowest price.",
      "category": "test"
    },
    {
      "name": "test_no_structured_data",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 145,
      "signature": "async test_no_structured_data(self, adapter)",
      "summary": "Test error when no Product schema found.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test error when no Product schema found.",
      "category": "test"
    },
    {
      "name": "test_missing_required_title",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 163,
      "signature": "async test_missing_required_title(self, adapter)",
      "summary": "Test error when Product schema missing title/name.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test error when Product schema missing title/name.",
      "category": "test"
    },
    {
      "name": "test_missing_required_offers",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 185,
      "signature": "async test_missing_required_offers(self, adapter)",
      "summary": "Test error when Product schema missing offers.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test error when Product schema missing offers.",
      "category": "test"
    },
    {
      "name": "test_missing_price_in_offers",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 204,
      "signature": "async test_missing_price_in_offers(self, adapter)",
      "summary": "Test error when offers missing price.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test error when offers missing price.",
      "category": "test"
    },
    {
      "name": "test_parse_price_string_decimal",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 225,
      "signature": "test_parse_price_string_decimal(self, adapter)",
      "summary": "Test price parsing from decimal string.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test price parsing from decimal string.",
      "category": "test"
    },
    {
      "name": "test_parse_price_string_with_dollar_sign",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 231,
      "signature": "test_parse_price_string_with_dollar_sign(self, adapter)",
      "summary": "Test price parsing with dollar sign.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test price parsing with dollar sign.",
      "category": "test"
    },
    {
      "name": "test_parse_price_string_with_currency_code",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 237,
      "signature": "test_parse_price_string_with_currency_code(self, adapter)",
      "summary": "Test price parsing with currency code prefix.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test price parsing with currency code prefix.",
      "category": "test"
    },
    {
      "name": "test_parse_price_number",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 243,
      "signature": "test_parse_price_number(self, adapter)",
      "summary": "Test price parsing from numeric types.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test price parsing from numeric types.",
      "category": "test"
    },
    {
      "name": "test_parse_price_with_thousands_separator",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 249,
      "signature": "test_parse_price_with_thousands_separator(self, adapter)",
      "summary": "Test price parsing with comma separators.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test price parsing with comma separators.",
      "category": "test"
    },
    {
      "name": "test_parse_price_invalid",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 255,
      "signature": "test_parse_price_invalid(self, adapter)",
      "summary": "Test price parsing with invalid inputs.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test price parsing with invalid inputs.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_intel",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 262,
      "signature": "test_extract_cpu_intel(self, adapter)",
      "summary": "Test CPU extraction for Intel processors.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test CPU extraction for Intel processors.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_amd",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 270,
      "signature": "test_extract_cpu_amd(self, adapter)",
      "summary": "Test CPU extraction for AMD processors.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test CPU extraction for AMD processors.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_without_brand",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 277,
      "signature": "test_extract_cpu_without_brand(self, adapter)",
      "summary": "Test CPU extraction without brand prefix.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test CPU extraction without brand prefix.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_standard",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 284,
      "signature": "test_extract_ram_standard(self, adapter)",
      "summary": "Test RAM extraction from standard formats.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test RAM extraction from standard formats.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_no_space",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 295,
      "signature": "test_extract_ram_no_space(self, adapter)",
      "summary": "Test RAM extraction without space.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test RAM extraction without space.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_gb",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 300,
      "signature": "test_extract_storage_gb(self, adapter)",
      "summary": "Test storage extraction in GB.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test storage extraction in GB.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_tb",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 311,
      "signature": "test_extract_storage_tb(self, adapter)",
      "summary": "Test storage extraction in TB (converted to GB).",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test storage extraction in TB (converted to GB).",
      "category": "test"
    },
    {
      "name": "test_extract_specs_combined",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 322,
      "signature": "test_extract_specs_combined(self, adapter)",
      "summary": "Test extracting all specs from combined text.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test extracting all specs from combined text.",
      "category": "test"
    },
    {
      "name": "test_extract_specs_no_match",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 332,
      "signature": "test_extract_specs_no_match(self, adapter)",
      "summary": "Test spec extraction with no matches.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test spec extraction with no matches.",
      "category": "test"
    },
    {
      "name": "test_extract_specs_empty_text",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 341,
      "signature": "test_extract_specs_empty_text(self, adapter)",
      "summary": "Test spec extraction with empty text.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test spec extraction with empty text.",
      "category": "test"
    },
    {
      "name": "test_full_extraction_with_brand",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 350,
      "signature": "async test_full_extraction_with_brand(self, adapter)",
      "summary": "Test complete extraction with brand as seller.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test complete extraction with brand as seller.",
      "category": "test"
    },
    {
      "name": "test_extract_with_multiple_images",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 380,
      "signature": "async test_extract_with_multiple_images(self, adapter)",
      "summary": "Test image extraction when multiple images present.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test image extraction when multiple images present.",
      "category": "test"
    },
    {
      "name": "test_condition_refurbished",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 407,
      "signature": "async test_condition_refurbished(self, adapter)",
      "summary": "Test condition extraction for refurbished items.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test condition extraction for refurbished items.",
      "category": "test"
    },
    {
      "name": "test_condition_used_from_item_condition",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 428,
      "signature": "async test_condition_used_from_item_condition(self, adapter)",
      "summary": "Test condition extraction from itemCondition field.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test condition extraction from itemCondition field.",
      "category": "test"
    },
    {
      "name": "test_network_timeout",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 449,
      "signature": "async test_network_timeout(self, adapter)",
      "summary": "Test handling of network timeout.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test handling of network timeout.",
      "category": "test"
    },
    {
      "name": "test_404_not_found",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 462,
      "signature": "async test_404_not_found(self, adapter)",
      "summary": "Test handling of 404 errors.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test handling of 404 errors.",
      "category": "test"
    },
    {
      "name": "test_is_product_schema_jsonld",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 474,
      "signature": "test_is_product_schema_jsonld(self, adapter)",
      "summary": "Test product schema detection for JSON-LD.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test product schema detection for JSON-LD.",
      "category": "test"
    },
    {
      "name": "test_is_product_schema_microdata",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 482,
      "signature": "test_is_product_schema_microdata(self, adapter)",
      "summary": "Test product schema detection for Microdata.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test product schema detection for Microdata.",
      "category": "test"
    },
    {
      "name": "test_normalize_offers_single",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 489,
      "signature": "test_normalize_offers_single(self, adapter)",
      "summary": "Test normalizing single offer to list.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test normalizing single offer to list.",
      "category": "test"
    },
    {
      "name": "test_normalize_offers_list",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 497,
      "signature": "test_normalize_offers_list(self, adapter)",
      "summary": "Test normalizing offer list.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test normalizing offer list.",
      "category": "test"
    },
    {
      "name": "test_extract_images_single_string",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 505,
      "signature": "test_extract_images_single_string(self, adapter)",
      "summary": "Test image extraction from single string.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test image extraction from single string.",
      "category": "test"
    },
    {
      "name": "test_extract_images_list",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 511,
      "signature": "test_extract_images_list(self, adapter)",
      "summary": "Test image extraction from list (takes first).",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test image extraction from list (takes first).",
      "category": "test"
    },
    {
      "name": "test_extract_images_object_with_url",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 518,
      "signature": "test_extract_images_object_with_url(self, adapter)",
      "summary": "Test image extraction from object with url field.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test image extraction from object with url field.",
      "category": "test"
    },
    {
      "name": "test_extract_images_none",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 524,
      "signature": "test_extract_images_none(self, adapter)",
      "summary": "Test image extraction when no images present.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test image extraction when no images present.",
      "category": "test"
    },
    {
      "name": "test_extract_with_minimal_schema",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 531,
      "signature": "async test_extract_with_minimal_schema(self, adapter)",
      "summary": "Test extraction with minimal valid schema.",
      "layer": "test",
      "parent": "TestJsonLdAdapter",
      "docstring": "Test extraction with minimal valid schema.",
      "category": "test"
    },
    {
      "name": "TestJsonLdAdapterIntegration",
      "kind": "class",
      "path": "tests/test_jsonld_adapter.py",
      "line": 557,
      "signature": "class TestJsonLdAdapterIntegration",
      "summary": "Integration tests for JsonLdAdapter with real HTML patterns.",
      "layer": "test",
      "docstring": "Integration tests for JsonLdAdapter with real HTML patterns.",
      "category": "test"
    },
    {
      "name": "adapter",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 561,
      "signature": "adapter(self)",
      "summary": "Create JsonLdAdapter instance.",
      "layer": "test",
      "parent": "TestJsonLdAdapterIntegration",
      "docstring": "Create JsonLdAdapter instance.",
      "category": "test"
    },
    {
      "name": "test_real_world_product_page",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 566,
      "signature": "async test_real_world_product_page(self, adapter)",
      "summary": "Test with realistic product page structure.",
      "layer": "test",
      "parent": "TestJsonLdAdapterIntegration",
      "docstring": "Test with realistic product page structure.",
      "category": "test"
    },
    {
      "name": "test_marketplace_listing_multiple_sellers",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 628,
      "signature": "async test_marketplace_listing_multiple_sellers(self, adapter)",
      "summary": "Test marketplace page with multiple seller offers.",
      "layer": "test",
      "parent": "TestJsonLdAdapterIntegration",
      "docstring": "Test marketplace page with multiple seller offers.",
      "category": "test"
    },
    {
      "name": "TestJsonLdAdapterEdgeCases",
      "kind": "class",
      "path": "tests/test_jsonld_adapter.py",
      "line": 672,
      "signature": "class TestJsonLdAdapterEdgeCases",
      "summary": "Edge case tests to improve coverage.",
      "layer": "test",
      "docstring": "Edge case tests to improve coverage.",
      "category": "test"
    },
    {
      "name": "adapter",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 676,
      "signature": "adapter(self)",
      "summary": "Create JsonLdAdapter instance.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Create JsonLdAdapter instance.",
      "category": "test"
    },
    {
      "name": "test_malformed_json_handled_gracefully",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 681,
      "signature": "async test_malformed_json_handled_gracefully(self, adapter)",
      "summary": "Test handling of empty JSON-LD (no Product schema).",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test handling of empty JSON-LD (no Product schema).",
      "category": "test"
    },
    {
      "name": "test_multiple_jsonld_scripts_first_not_product",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 707,
      "signature": "async test_multiple_jsonld_scripts_first_not_product(self, adapter)",
      "summary": "Test handling multiple JSON-LD scripts where first is not Product.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test handling multiple JSON-LD scripts where first is not Product.",
      "category": "test"
    },
    {
      "name": "test_price_as_float_not_string",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 734,
      "signature": "async test_price_as_float_not_string(self, adapter)",
      "summary": "Test price handling when provided as float instead of string.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test price handling when provided as float instead of string.",
      "category": "test"
    },
    {
      "name": "test_missing_pricecurrency_defaults_to_usd",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 754,
      "signature": "async test_missing_pricecurrency_defaults_to_usd(self, adapter)",
      "summary": "Test that missing priceCurrency defaults to USD.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test that missing priceCurrency defaults to USD.",
      "category": "test"
    },
    {
      "name": "test_offers_as_aggregate_offer",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 774,
      "signature": "async test_offers_as_aggregate_offer(self, adapter)",
      "summary": "Test handling of AggregateOffer with lowPrice.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test handling of AggregateOffer with lowPrice.",
      "category": "test"
    },
    {
      "name": "test_empty_offers_array",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 799,
      "signature": "async test_empty_offers_array(self, adapter)",
      "summary": "Test error when offers array is empty.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test error when offers array is empty.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_with_unusual_formats",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 817,
      "signature": "test_extract_cpu_with_unusual_formats(self, adapter)",
      "summary": "Test CPU extraction with unusual formats.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test CPU extraction with unusual formats.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_from_title_when_missing_in_description",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 830,
      "signature": "test_extract_ram_from_title_when_missing_in_description(self, adapter)",
      "summary": "Test RAM extraction from combined title+description.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test RAM extraction from combined title+description.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_with_multiple_values",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 837,
      "signature": "test_extract_storage_with_multiple_values(self, adapter)",
      "summary": "Test storage extraction when multiple storage values present.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test storage extraction when multiple storage values present.",
      "category": "test"
    },
    {
      "name": "test_extract_specs_with_mixed_units",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 845,
      "signature": "test_extract_specs_with_mixed_units(self, adapter)",
      "summary": "Test spec extraction with mixed storage units.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test spec extraction with mixed storage units.",
      "category": "test"
    },
    {
      "name": "test_seller_from_nested_organization",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 856,
      "signature": "async test_seller_from_nested_organization(self, adapter)",
      "summary": "Test extracting seller from nested organization structure.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test extracting seller from nested organization structure.",
      "category": "test"
    },
    {
      "name": "test_image_as_object_with_url",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 881,
      "signature": "async test_image_as_object_with_url(self, adapter)",
      "summary": "Test image extraction when image is object with url field.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test image extraction when image is object with url field.",
      "category": "test"
    },
    {
      "name": "test_description_with_html_tags",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 907,
      "signature": "async test_description_with_html_tags(self, adapter)",
      "summary": "Test description extraction when containing HTML tags.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test description extraction when containing HTML tags.",
      "category": "test"
    },
    {
      "name": "test_condition_from_text_in_offers",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 930,
      "signature": "async test_condition_from_text_in_offers(self, adapter)",
      "summary": "Test condition detection from offer text fields.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test condition detection from offer text fields.",
      "category": "test"
    },
    {
      "name": "test_microdata_extraction",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 952,
      "signature": "async test_microdata_extraction(self, adapter)",
      "summary": "Test microdata extraction with offer structure.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test microdata extraction with offer structure.",
      "category": "test"
    },
    {
      "name": "test_parse_price_with_euro_symbol",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 970,
      "signature": "test_parse_price_with_euro_symbol(self, adapter)",
      "summary": "Test price parsing with Euro symbol.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test price parsing with Euro symbol.",
      "category": "test"
    },
    {
      "name": "test_parse_price_with_pound_symbol",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 975,
      "signature": "test_parse_price_with_pound_symbol(self, adapter)",
      "summary": "Test price parsing with British pound symbol.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test price parsing with British pound symbol.",
      "category": "test"
    },
    {
      "name": "test_parse_price_zero",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 980,
      "signature": "test_parse_price_zero(self, adapter)",
      "summary": "Test price parsing with zero value.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test price parsing with zero value.",
      "category": "test"
    },
    {
      "name": "test_parse_price_very_large_number",
      "kind": "method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 985,
      "signature": "test_parse_price_very_large_number(self, adapter)",
      "summary": "Test price parsing with very large numbers.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test price parsing with very large numbers.",
      "category": "test"
    },
    {
      "name": "test_extract_with_whitespace_in_fields",
      "kind": "async_method",
      "path": "tests/test_jsonld_adapter.py",
      "line": 991,
      "signature": "async test_extract_with_whitespace_in_fields(self, adapter)",
      "summary": "Test extraction with excessive whitespace in fields.",
      "layer": "test",
      "parent": "TestJsonLdAdapterEdgeCases",
      "docstring": "Test extraction with excessive whitespace in fields.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 27,
      "signature": "async db_session()",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "sample_normalized",
      "kind": "function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 46,
      "signature": "sample_normalized() -> NormalizedListingSchema",
      "summary": "Create sample normalized listing data.",
      "layer": "test",
      "docstring": "Create sample normalized listing data.",
      "category": "test"
    },
    {
      "name": "sample_normalized_updated_price",
      "kind": "function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 61,
      "signature": "sample_normalized_updated_price() -> NormalizedListingSchema",
      "summary": "Create sample normalized listing with updated price.",
      "layer": "test",
      "docstring": "Create sample normalized listing with updated price.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_creates_new_listing",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 76,
      "signature": "async test_upsert_from_url_creates_new_listing(db_session: AsyncSession, sample_normalized: NormalizedListingSchema)",
      "summary": "Test that upsert_from_url creates new listing when no duplicate exists.",
      "layer": "test",
      "docstring": "Test that upsert_from_url creates new listing when no duplicate exists.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_updates_existing_listing",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 117,
      "signature": "async test_upsert_from_url_updates_existing_listing(db_session: AsyncSession, sample_normalized: NormalizedListingSchema, sample_normalized_updated_price: NormalizedListingSchema)",
      "summary": "Test that upsert_from_url updates existing listing when duplicate found.",
      "layer": "test",
      "docstring": "Test that upsert_from_url updates existing listing when duplicate found.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_emits_price_changed_event",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 165,
      "signature": "async test_upsert_from_url_emits_price_changed_event(db_session: AsyncSession, sample_normalized: NormalizedListingSchema, sample_normalized_updated_price: NormalizedListingSchema)",
      "summary": "Test that price.changed event emitted when price changes significantly.",
      "layer": "test",
      "docstring": "Test that price.changed event emitted when price changes significantly.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_no_event_if_price_unchanged",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 207,
      "signature": "async test_upsert_from_url_no_event_if_price_unchanged(db_session: AsyncSession, sample_normalized: NormalizedListingSchema)",
      "summary": "Test that no price.changed event emitted if price unchanged.",
      "layer": "test",
      "docstring": "Test that no price.changed event emitted if price unchanged.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_preserves_metadata",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 244,
      "signature": "async test_upsert_from_url_preserves_metadata(db_session: AsyncSession, sample_normalized: NormalizedListingSchema)",
      "summary": "Test that provenance, vendor_item_id, marketplace preserved correctly.",
      "layer": "test",
      "docstring": "Test that provenance, vendor_item_id, marketplace preserved correctly.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_handles_refurb_condition",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 269,
      "signature": "async test_upsert_from_url_handles_refurb_condition(db_session: AsyncSession)",
      "summary": "Test that refurb condition mapped correctly.",
      "layer": "test",
      "docstring": "Test that refurb condition mapped correctly.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_handles_used_condition",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 299,
      "signature": "async test_upsert_from_url_handles_used_condition(db_session: AsyncSession)",
      "summary": "Test that used condition mapped correctly.",
      "layer": "test",
      "docstring": "Test that used condition mapped correctly.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_invalid_input_raises_error",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 330,
      "signature": "async test_upsert_from_url_invalid_input_raises_error(db_session: AsyncSession)",
      "summary": "Test that ValueError raised for invalid input.",
      "layer": "test",
      "docstring": "Test that ValueError raised for invalid input.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_no_images_handled_correctly",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 351,
      "signature": "async test_upsert_from_url_no_images_handled_correctly(db_session: AsyncSession)",
      "summary": "Test that listings without images handled correctly.",
      "layer": "test",
      "docstring": "Test that listings without images handled correctly.",
      "category": "test"
    },
    {
      "name": "test_upsert_from_url_updates_condition_on_existing",
      "kind": "async_function",
      "path": "tests/test_listings_service_url_ingest.py",
      "line": 381,
      "signature": "async test_upsert_from_url_updates_condition_on_existing(db_session: AsyncSession)",
      "summary": "Test that condition updated when existing listing re-imported.",
      "layer": "test",
      "docstring": "Test that condition updated when existing listing re-imported.",
      "category": "test"
    },
    {
      "name": "test_many_multipliers_performance",
      "kind": "function",
      "path": "tests/test_multipliers_performance.py",
      "line": 12,
      "signature": "test_many_multipliers_performance()",
      "summary": "Test performance with 10 multipliers - should complete in < 500ms",
      "layer": "test",
      "docstring": "Test performance with 10 multipliers - should complete in < 500ms",
      "category": "test"
    },
    {
      "name": "test_nested_field_path_performance",
      "kind": "function",
      "path": "tests/test_multipliers_performance.py",
      "line": 67,
      "signature": "test_nested_field_path_performance()",
      "summary": "Test performance with deeply nested field paths",
      "layer": "test",
      "docstring": "Test performance with deeply nested field paths",
      "category": "test"
    },
    {
      "name": "test_simple_multiplier_performance",
      "kind": "function",
      "path": "tests/test_multipliers_performance.py",
      "line": 117,
      "signature": "test_simple_multiplier_performance()",
      "summary": "Baseline performance test with single multiplier",
      "layer": "test",
      "docstring": "Baseline performance test with single multiplier",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_normalizer_service.py",
      "line": 26,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "TestCurrencyConversion",
      "kind": "class",
      "path": "tests/test_normalizer_service.py",
      "line": 45,
      "signature": "class TestCurrencyConversion",
      "summary": "Tests for currency conversion.",
      "layer": "test",
      "docstring": "Tests for currency conversion.",
      "category": "test"
    },
    {
      "name": "test_convert_usd_to_usd",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 48,
      "signature": "test_convert_usd_to_usd(self, db_session: AsyncSession)",
      "summary": "Test USD to USD conversion (no change).",
      "layer": "test",
      "parent": "TestCurrencyConversion",
      "docstring": "Test USD to USD conversion (no change).",
      "category": "test"
    },
    {
      "name": "test_convert_eur_to_usd",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 55,
      "signature": "test_convert_eur_to_usd(self, db_session: AsyncSession)",
      "summary": "Test EUR to USD conversion.",
      "layer": "test",
      "parent": "TestCurrencyConversion",
      "docstring": "Test EUR to USD conversion.",
      "category": "test"
    },
    {
      "name": "test_convert_gbp_to_usd",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 63,
      "signature": "test_convert_gbp_to_usd(self, db_session: AsyncSession)",
      "summary": "Test GBP to USD conversion.",
      "layer": "test",
      "parent": "TestCurrencyConversion",
      "docstring": "Test GBP to USD conversion.",
      "category": "test"
    },
    {
      "name": "test_convert_cad_to_usd",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 71,
      "signature": "test_convert_cad_to_usd(self, db_session: AsyncSession)",
      "summary": "Test CAD to USD conversion.",
      "layer": "test",
      "parent": "TestCurrencyConversion",
      "docstring": "Test CAD to USD conversion.",
      "category": "test"
    },
    {
      "name": "test_convert_unknown_currency_defaults_to_usd",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 79,
      "signature": "test_convert_unknown_currency_defaults_to_usd(self, db_session: AsyncSession)",
      "summary": "Test that unknown currency defaults to USD (no conversion).",
      "layer": "test",
      "parent": "TestCurrencyConversion",
      "docstring": "Test that unknown currency defaults to USD (no conversion).",
      "category": "test"
    },
    {
      "name": "test_convert_none_currency_defaults_to_usd",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 87,
      "signature": "test_convert_none_currency_defaults_to_usd(self, db_session: AsyncSession)",
      "summary": "Test that None currency defaults to USD (no conversion).",
      "layer": "test",
      "parent": "TestCurrencyConversion",
      "docstring": "Test that None currency defaults to USD (no conversion).",
      "category": "test"
    },
    {
      "name": "test_convert_preserves_decimal_precision",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 95,
      "signature": "test_convert_preserves_decimal_precision(self, db_session: AsyncSession)",
      "summary": "Test that conversion preserves 2 decimal places.",
      "layer": "test",
      "parent": "TestCurrencyConversion",
      "docstring": "Test that conversion preserves 2 decimal places.",
      "category": "test"
    },
    {
      "name": "TestConditionNormalization",
      "kind": "class",
      "path": "tests/test_normalizer_service.py",
      "line": 105,
      "signature": "class TestConditionNormalization",
      "summary": "Tests for condition string normalization.",
      "layer": "test",
      "docstring": "Tests for condition string normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_new",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 108,
      "signature": "test_normalize_condition_new(self, db_session: AsyncSession)",
      "summary": "Test 'new' condition normalization.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test 'new' condition normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_brand_new",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 116,
      "signature": "test_normalize_condition_brand_new(self, db_session: AsyncSession)",
      "summary": "Test 'brand new' condition normalization.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test 'brand new' condition normalization.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_refurbished",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 124,
      "signature": "test_normalize_condition_refurbished(self, db_session: AsyncSession)",
      "summary": "Test refurbished condition variants.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test refurbished condition variants.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_used",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 133,
      "signature": "test_normalize_condition_used(self, db_session: AsyncSession)",
      "summary": "Test used condition variants.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test used condition variants.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_unknown_defaults_to_used",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 144,
      "signature": "test_normalize_condition_unknown_defaults_to_used(self, db_session: AsyncSession)",
      "summary": "Test that unknown conditions default to 'used'.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test that unknown conditions default to 'used'.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_none_defaults_to_used",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 152,
      "signature": "test_normalize_condition_none_defaults_to_used(self, db_session: AsyncSession)",
      "summary": "Test that None condition defaults to 'used'.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test that None condition defaults to 'used'.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_handles_whitespace",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 158,
      "signature": "test_normalize_condition_handles_whitespace(self, db_session: AsyncSession)",
      "summary": "Test that whitespace is trimmed before normalization.",
      "layer": "test",
      "parent": "TestConditionNormalization",
      "docstring": "Test that whitespace is trimmed before normalization.",
      "category": "test"
    },
    {
      "name": "TestSpecExtraction",
      "kind": "class",
      "path": "tests/test_normalizer_service.py",
      "line": 166,
      "signature": "class TestSpecExtraction",
      "summary": "Tests for spec extraction from descriptions.",
      "layer": "test",
      "docstring": "Tests for spec extraction from descriptions.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_from_description",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 169,
      "signature": "test_extract_cpu_from_description(self, db_session: AsyncSession)",
      "summary": "Test CPU extraction from description.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test CPU extraction from description.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_i5_variant",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 186,
      "signature": "test_extract_cpu_i5_variant(self, db_session: AsyncSession)",
      "summary": "Test CPU extraction for i5 variants.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test CPU extraction for i5 variants.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_ryzen",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 203,
      "signature": "test_extract_cpu_ryzen(self, db_session: AsyncSession)",
      "summary": "Test CPU extraction for AMD Ryzen.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test CPU extraction for AMD Ryzen.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_from_description",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 222,
      "signature": "test_extract_ram_from_description(self, db_session: AsyncSession)",
      "summary": "Test RAM extraction from description.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test RAM extraction from description.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_various_formats",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 239,
      "signature": "test_extract_ram_various_formats(self, db_session: AsyncSession)",
      "summary": "Test RAM extraction with various formats.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test RAM extraction with various formats.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_from_description",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 262,
      "signature": "test_extract_storage_from_description(self, db_session: AsyncSession)",
      "summary": "Test storage extraction from description.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test storage extraction from description.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_with_tb",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 279,
      "signature": "test_extract_storage_with_tb(self, db_session: AsyncSession)",
      "summary": "Test storage extraction with TB units.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test storage extraction with TB units.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_various_formats",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 296,
      "signature": "test_extract_storage_various_formats(self, db_session: AsyncSession)",
      "summary": "Test storage extraction with various formats.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test storage extraction with various formats.",
      "category": "test"
    },
    {
      "name": "test_extract_all_specs_combined",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 319,
      "signature": "test_extract_all_specs_combined(self, db_session: AsyncSession)",
      "summary": "Test extracting all specs from a complete description.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test extracting all specs from a complete description.",
      "category": "test"
    },
    {
      "name": "test_extract_no_specs_from_empty_description",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 338,
      "signature": "test_extract_no_specs_from_empty_description(self, db_session: AsyncSession)",
      "summary": "Test that empty description returns empty specs dict.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test that empty description returns empty specs dict.",
      "category": "test"
    },
    {
      "name": "test_extract_only_missing_specs",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 354,
      "signature": "test_extract_only_missing_specs(self, db_session: AsyncSession)",
      "summary": "Test that extraction only fills in missing fields.",
      "layer": "test",
      "parent": "TestSpecExtraction",
      "docstring": "Test that extraction only fills in missing fields.",
      "category": "test"
    },
    {
      "name": "TestCPUCanonicalization",
      "kind": "class",
      "path": "tests/test_normalizer_service.py",
      "line": 377,
      "signature": "class TestCPUCanonicalization",
      "summary": "Tests for CPU canonicalization against catalog.",
      "layer": "test",
      "docstring": "Tests for CPU canonicalization against catalog.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_exact_match",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 381,
      "signature": "async test_canonicalize_cpu_exact_match(self, db_session: AsyncSession)",
      "summary": "Test exact CPU name matching.",
      "layer": "test",
      "parent": "TestCPUCanonicalization",
      "docstring": "Test exact CPU name matching.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_partial_match",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 404,
      "signature": "async test_canonicalize_cpu_partial_match(self, db_session: AsyncSession)",
      "summary": "Test partial CPU name matching.",
      "layer": "test",
      "parent": "TestCPUCanonicalization",
      "docstring": "Test partial CPU name matching.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_case_insensitive",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 427,
      "signature": "async test_canonicalize_cpu_case_insensitive(self, db_session: AsyncSession)",
      "summary": "Test case-insensitive CPU matching.",
      "layer": "test",
      "parent": "TestCPUCanonicalization",
      "docstring": "Test case-insensitive CPU matching.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_no_match",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 448,
      "signature": "async test_canonicalize_cpu_no_match(self, db_session: AsyncSession)",
      "summary": "Test when CPU not found in catalog.",
      "layer": "test",
      "parent": "TestCPUCanonicalization",
      "docstring": "Test when CPU not found in catalog.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_none_input",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 456,
      "signature": "async test_canonicalize_cpu_none_input(self, db_session: AsyncSession)",
      "summary": "Test CPU canonicalization with None input.",
      "layer": "test",
      "parent": "TestCPUCanonicalization",
      "docstring": "Test CPU canonicalization with None input.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_with_null_benchmarks",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 464,
      "signature": "async test_canonicalize_cpu_with_null_benchmarks(self, db_session: AsyncSession)",
      "summary": "Test CPU matching when benchmark data is null.",
      "layer": "test",
      "parent": "TestCPUCanonicalization",
      "docstring": "Test CPU matching when benchmark data is null.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_multiple_matches_returns_first",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 486,
      "signature": "async test_canonicalize_cpu_multiple_matches_returns_first(self, db_session: AsyncSession)",
      "summary": "Test that multiple CPU matches returns first result without error.",
      "layer": "test",
      "parent": "TestCPUCanonicalization",
      "docstring": "Test that multiple CPU matches returns first result without error.\n\nThis tests the fix for the bug where searching for \"i7-12700\" would match\nmultiple CPUs (e.g., \"i7-12700\", \"i7-12700K\", \"i7-12700F\") and the original\nimplementation using .scalar_one_or_none() would throw an error.\n\nThe fix uses .scalars().first() to return the first match gracefully.",
      "category": "test"
    },
    {
      "name": "TestQualityAssessment",
      "kind": "class",
      "path": "tests/test_normalizer_service.py",
      "line": 538,
      "signature": "class TestQualityAssessment",
      "summary": "Tests for data quality assessment.",
      "layer": "test",
      "docstring": "Tests for data quality assessment.",
      "category": "test"
    },
    {
      "name": "test_assess_quality_full",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 541,
      "signature": "test_assess_quality_full(self, db_session: AsyncSession)",
      "summary": "Test quality=full when all optional fields present.",
      "layer": "test",
      "parent": "TestQualityAssessment",
      "docstring": "Test quality=full when all optional fields present.",
      "category": "test"
    },
    {
      "name": "test_assess_quality_partial",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 560,
      "signature": "test_assess_quality_partial(self, db_session: AsyncSession)",
      "summary": "Test quality=partial when some optional fields missing.",
      "layer": "test",
      "parent": "TestQualityAssessment",
      "docstring": "Test quality=partial when some optional fields missing.",
      "category": "test"
    },
    {
      "name": "test_assess_quality_minimal",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 577,
      "signature": "test_assess_quality_minimal(self, db_session: AsyncSession)",
      "summary": "Test quality=partial with minimal fields.",
      "layer": "test",
      "parent": "TestQualityAssessment",
      "docstring": "Test quality=partial with minimal fields.",
      "category": "test"
    },
    {
      "name": "test_assess_quality_threshold_boundary",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 593,
      "signature": "test_assess_quality_threshold_boundary(self, db_session: AsyncSession)",
      "summary": "Test quality assessment at threshold boundary (4 optional fields).",
      "layer": "test",
      "parent": "TestQualityAssessment",
      "docstring": "Test quality assessment at threshold boundary (4 optional fields).",
      "category": "test"
    },
    {
      "name": "test_assess_quality_missing_required_field_raises_error",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 627,
      "signature": "test_assess_quality_missing_required_field_raises_error(self, db_session: AsyncSession)",
      "summary": "Test that missing required fields raise ValueError.",
      "layer": "test",
      "parent": "TestQualityAssessment",
      "docstring": "Test that missing required fields raise ValueError.",
      "category": "test"
    },
    {
      "name": "TestNormalizeEndToEnd",
      "kind": "class",
      "path": "tests/test_normalizer_service.py",
      "line": 649,
      "signature": "class TestNormalizeEndToEnd",
      "summary": "End-to-end tests for the complete normalization flow.",
      "layer": "test",
      "docstring": "End-to-end tests for the complete normalization flow.",
      "category": "test"
    },
    {
      "name": "test_normalize_full_flow",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 653,
      "signature": "async test_normalize_full_flow(self, db_session: AsyncSession)",
      "summary": "Test complete normalization flow with all transformations.",
      "layer": "test",
      "parent": "TestNormalizeEndToEnd",
      "docstring": "Test complete normalization flow with all transformations.",
      "category": "test"
    },
    {
      "name": "test_normalize_partial_data",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 707,
      "signature": "async test_normalize_partial_data(self, db_session: AsyncSession)",
      "summary": "Test normalization with minimal data.",
      "layer": "test",
      "parent": "TestNormalizeEndToEnd",
      "docstring": "Test normalization with minimal data.",
      "category": "test"
    },
    {
      "name": "test_normalize_with_existing_specs",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 734,
      "signature": "async test_normalize_with_existing_specs(self, db_session: AsyncSession)",
      "summary": "Test normalization when specs are already provided.",
      "layer": "test",
      "parent": "TestNormalizeEndToEnd",
      "docstring": "Test normalization when specs are already provided.",
      "category": "test"
    },
    {
      "name": "test_normalize_multiple_currencies",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 773,
      "signature": "async test_normalize_multiple_currencies(self, db_session: AsyncSession)",
      "summary": "Test normalization with various currencies.",
      "layer": "test",
      "parent": "TestNormalizeEndToEnd",
      "docstring": "Test normalization with various currencies.",
      "category": "test"
    },
    {
      "name": "test_normalize_preserves_metadata",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 798,
      "signature": "async test_normalize_preserves_metadata(self, db_session: AsyncSession)",
      "summary": "Test that normalization preserves important metadata.",
      "layer": "test",
      "parent": "TestNormalizeEndToEnd",
      "docstring": "Test that normalization preserves important metadata.",
      "category": "test"
    },
    {
      "name": "TestEdgeCasesAndUnusualFormats",
      "kind": "class",
      "path": "tests/test_normalizer_service.py",
      "line": 824,
      "signature": "class TestEdgeCasesAndUnusualFormats",
      "summary": "Test edge cases and unusual data formats.",
      "layer": "test",
      "docstring": "Test edge cases and unusual data formats.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_amd_ryzen_various_formats",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 827,
      "signature": "test_extract_cpu_amd_ryzen_various_formats(self, db_session: AsyncSession)",
      "summary": "Test CPU extraction for various AMD Ryzen formats.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test CPU extraction for various AMD Ryzen formats.",
      "category": "test"
    },
    {
      "name": "test_extract_ram_various_edge_cases",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 855,
      "signature": "test_extract_ram_various_edge_cases(self, db_session: AsyncSession)",
      "summary": "Test RAM extraction with edge cases.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test RAM extraction with edge cases.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_edge_cases",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 878,
      "signature": "test_extract_storage_edge_cases(self, db_session: AsyncSession)",
      "summary": "Test storage extraction with various edge cases.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test storage extraction with various edge cases.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_lowercase_input",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 905,
      "signature": "test_normalize_condition_lowercase_input(self, db_session: AsyncSession)",
      "summary": "Test condition normalization with lowercase input.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test condition normalization with lowercase input.",
      "category": "test"
    },
    {
      "name": "test_normalize_condition_mixed_case",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 913,
      "signature": "test_normalize_condition_mixed_case(self, db_session: AsyncSession)",
      "summary": "Test condition normalization with mixed case.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test condition normalization with mixed case.",
      "category": "test"
    },
    {
      "name": "test_convert_usd_edge_cases",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 921,
      "signature": "test_convert_usd_edge_cases(self, db_session: AsyncSession)",
      "summary": "Test currency conversion edge cases.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test currency conversion edge cases.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_basic",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 938,
      "signature": "async test_canonicalize_cpu_basic(self, db_session: AsyncSession)",
      "summary": "Test CPU canonicalization basic functionality.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test CPU canonicalization basic functionality.",
      "category": "test"
    },
    {
      "name": "test_canonicalize_cpu_unique_match",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 958,
      "signature": "async test_canonicalize_cpu_unique_match(self, db_session: AsyncSession)",
      "summary": "Test CPU canonicalization with unique substring match.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test CPU canonicalization with unique substring match.",
      "category": "test"
    },
    {
      "name": "test_normalize_with_invalid_currency",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 979,
      "signature": "async test_normalize_with_invalid_currency(self, db_session: AsyncSession)",
      "summary": "Test normalization with invalid/unknown currency code.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test normalization with invalid/unknown currency code.",
      "category": "test"
    },
    {
      "name": "test_extract_specs_with_no_description",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 997,
      "signature": "async test_extract_specs_with_no_description(self, db_session: AsyncSession)",
      "summary": "Test spec extraction when description is None.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test spec extraction when description is None.",
      "category": "test"
    },
    {
      "name": "test_extract_specs_from_description",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 1013,
      "signature": "async test_extract_specs_from_description(self, db_session: AsyncSession)",
      "summary": "Test spec extraction from description.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test spec extraction from description.",
      "category": "test"
    },
    {
      "name": "test_assess_quality_with_all_none_optionals",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 1030,
      "signature": "test_assess_quality_with_all_none_optionals(self, db_session: AsyncSession)",
      "summary": "Test quality assessment when all optional fields are None.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test quality assessment when all optional fields are None.",
      "category": "test"
    },
    {
      "name": "test_assess_quality_exact_threshold",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 1051,
      "signature": "test_assess_quality_exact_threshold(self, db_session: AsyncSession)",
      "summary": "Test quality assessment at exact threshold.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test quality assessment at exact threshold.",
      "category": "test"
    },
    {
      "name": "test_normalize_with_all_specs_already_present",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 1070,
      "signature": "async test_normalize_with_all_specs_already_present(self, db_session: AsyncSession)",
      "summary": "Test normalization when all specs are already provided.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test normalization when all specs are already provided.",
      "category": "test"
    },
    {
      "name": "test_normalize_preserves_vendor_item_id",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 1093,
      "signature": "async test_normalize_preserves_vendor_item_id(self, db_session: AsyncSession)",
      "summary": "Test that vendor_item_id is preserved through normalization.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test that vendor_item_id is preserved through normalization.",
      "category": "test"
    },
    {
      "name": "test_extract_cpu_with_ghz_in_description",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 1109,
      "signature": "test_extract_cpu_with_ghz_in_description(self, db_session: AsyncSession)",
      "summary": "Test CPU extraction when GHz is included in description.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test CPU extraction when GHz is included in description.",
      "category": "test"
    },
    {
      "name": "test_extract_storage_standard_formats",
      "kind": "method",
      "path": "tests/test_normalizer_service.py",
      "line": 1125,
      "signature": "test_extract_storage_standard_formats(self, db_session: AsyncSession)",
      "summary": "Test storage extraction with standard formats.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test storage extraction with standard formats.",
      "category": "test"
    },
    {
      "name": "test_normalize_with_empty_strings",
      "kind": "async_method",
      "path": "tests/test_normalizer_service.py",
      "line": 1150,
      "signature": "async test_normalize_with_empty_strings(self, db_session: AsyncSession)",
      "summary": "Test normalization with empty string fields.",
      "layer": "test",
      "parent": "TestEdgeCasesAndUnusualFormats",
      "docstring": "Test normalization with empty string fields.",
      "category": "test"
    },
    {
      "name": "anyio_backend",
      "kind": "function",
      "path": "tests/test_listing_computed_properties.py",
      "line": 15,
      "signature": "anyio_backend()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "TestCpuNameProperty",
      "kind": "class",
      "path": "tests/test_listing_computed_properties.py",
      "line": 23,
      "signature": "class TestCpuNameProperty",
      "summary": "Test cpu_name computed property.",
      "layer": "test",
      "docstring": "Test cpu_name computed property.",
      "category": "test"
    },
    {
      "name": "test_cpu_name_with_cpu_attached",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 27,
      "signature": "async test_cpu_name_with_cpu_attached(self)",
      "summary": "Test cpu_name returns correct value when CPU is attached.",
      "layer": "test",
      "parent": "TestCpuNameProperty",
      "docstring": "Test cpu_name returns correct value when CPU is attached.",
      "category": "test"
    },
    {
      "name": "test_cpu_name_returns_none_when_no_cpu",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 65,
      "signature": "async test_cpu_name_returns_none_when_no_cpu(self)",
      "summary": "Test cpu_name returns None when no CPU is attached.",
      "layer": "test",
      "parent": "TestCpuNameProperty",
      "docstring": "Test cpu_name returns None when no CPU is attached.",
      "category": "test"
    },
    {
      "name": "TestGpuNameProperty",
      "kind": "class",
      "path": "tests/test_listing_computed_properties.py",
      "line": 90,
      "signature": "class TestGpuNameProperty",
      "summary": "Test gpu_name computed property.",
      "layer": "test",
      "docstring": "Test gpu_name computed property.",
      "category": "test"
    },
    {
      "name": "test_gpu_name_with_gpu_attached",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 94,
      "signature": "async test_gpu_name_with_gpu_attached(self)",
      "summary": "Test gpu_name returns correct value when GPU is attached.",
      "layer": "test",
      "parent": "TestGpuNameProperty",
      "docstring": "Test gpu_name returns correct value when GPU is attached.",
      "category": "test"
    },
    {
      "name": "test_gpu_name_returns_none_when_no_gpu",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 128,
      "signature": "async test_gpu_name_returns_none_when_no_gpu(self)",
      "summary": "Test gpu_name returns None when no GPU is attached.",
      "layer": "test",
      "parent": "TestGpuNameProperty",
      "docstring": "Test gpu_name returns None when no GPU is attached.",
      "category": "test"
    },
    {
      "name": "TestThumbnailUrlProperty",
      "kind": "class",
      "path": "tests/test_listing_computed_properties.py",
      "line": 153,
      "signature": "class TestThumbnailUrlProperty",
      "summary": "Test thumbnail_url computed property.",
      "layer": "test",
      "docstring": "Test thumbnail_url computed property.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_from_raw_listing_json_image_url",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 157,
      "signature": "async test_thumbnail_url_from_raw_listing_json_image_url(self)",
      "summary": "Test thumbnail_url extraction from raw_listing_json with 'image_url' key.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url extraction from raw_listing_json with 'image_url' key.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_from_raw_listing_json_thumbnail_url",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 183,
      "signature": "async test_thumbnail_url_from_raw_listing_json_thumbnail_url(self)",
      "summary": "Test thumbnail_url extraction from raw_listing_json with 'thumbnail_url' key.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url extraction from raw_listing_json with 'thumbnail_url' key.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_from_raw_listing_json_camel_case",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 209,
      "signature": "async test_thumbnail_url_from_raw_listing_json_camel_case(self)",
      "summary": "Test thumbnail_url extraction from raw_listing_json with camelCase keys.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url extraction from raw_listing_json with camelCase keys.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_fallback_to_attributes_json",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 235,
      "signature": "async test_thumbnail_url_fallback_to_attributes_json(self)",
      "summary": "Test thumbnail_url falls back to attributes_json when not in raw_listing_json.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url falls back to attributes_json when not in raw_listing_json.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_prefers_raw_listing_json_over_attributes",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 262,
      "signature": "async test_thumbnail_url_prefers_raw_listing_json_over_attributes(self)",
      "summary": "Test thumbnail_url prioritizes raw_listing_json over attributes_json.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url prioritizes raw_listing_json over attributes_json.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_returns_none_when_no_image_data",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 290,
      "signature": "async test_thumbnail_url_returns_none_when_no_image_data(self)",
      "summary": "Test thumbnail_url returns None when no image data is present.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url returns None when no image data is present.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_returns_none_when_empty_string",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 317,
      "signature": "async test_thumbnail_url_returns_none_when_empty_string(self)",
      "summary": "Test thumbnail_url returns None when image URL is empty string.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url returns None when image URL is empty string.",
      "category": "test"
    },
    {
      "name": "test_thumbnail_url_handles_none_raw_listing_json",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 343,
      "signature": "async test_thumbnail_url_handles_none_raw_listing_json(self)",
      "summary": "Test thumbnail_url handles None raw_listing_json gracefully.",
      "layer": "test",
      "parent": "TestThumbnailUrlProperty",
      "docstring": "Test thumbnail_url handles None raw_listing_json gracefully.",
      "category": "test"
    },
    {
      "name": "TestCombinedComputedProperties",
      "kind": "class",
      "path": "tests/test_listing_computed_properties.py",
      "line": 371,
      "signature": "class TestCombinedComputedProperties",
      "summary": "Test multiple computed properties together.",
      "layer": "test",
      "docstring": "Test multiple computed properties together.",
      "category": "test"
    },
    {
      "name": "test_all_computed_properties_together",
      "kind": "async_method",
      "path": "tests/test_listing_computed_properties.py",
      "line": 375,
      "signature": "async test_all_computed_properties_together(self)",
      "summary": "Test all computed properties work together on a single listing.",
      "layer": "test",
      "parent": "TestCombinedComputedProperties",
      "docstring": "Test all computed properties work together on a single listing.",
      "category": "test"
    },
    {
      "name": "anyio_backend",
      "kind": "function",
      "path": "tests/test_listing_computed_properties_api.py",
      "line": 15,
      "signature": "anyio_backend()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_listing_read_schema_includes_computed_properties",
      "kind": "async_function",
      "path": "tests/test_listing_computed_properties_api.py",
      "line": 25,
      "signature": "async test_listing_read_schema_includes_computed_properties()",
      "summary": "Test that ListingRead schema serializes computed properties correctly.",
      "layer": "test",
      "docstring": "Test that ListingRead schema serializes computed properties correctly.",
      "category": "test"
    },
    {
      "name": "test_listing_read_schema_handles_missing_computed_properties",
      "kind": "async_function",
      "path": "tests/test_listing_computed_properties_api.py",
      "line": 92,
      "signature": "async test_listing_read_schema_handles_missing_computed_properties()",
      "summary": "Test that ListingRead schema handles None values for computed properties.",
      "layer": "test",
      "docstring": "Test that ListingRead schema handles None values for computed properties.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/test_ingestion_metrics_calculation.py",
      "line": 24,
      "signature": "async db_session()",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "sample_cpu",
      "kind": "async_function",
      "path": "tests/test_ingestion_metrics_calculation.py",
      "line": 43,
      "signature": "async sample_cpu(db_session: AsyncSession)",
      "summary": "Create a sample CPU for testing.",
      "layer": "test",
      "docstring": "Create a sample CPU for testing.",
      "category": "test"
    },
    {
      "name": "test_url_ingestion_calculates_metrics_on_create",
      "kind": "async_function",
      "path": "tests/test_ingestion_metrics_calculation.py",
      "line": 58,
      "signature": "async test_url_ingestion_calculates_metrics_on_create(db_session: AsyncSession, sample_cpu: Cpu)",
      "summary": "Test that URL ingestion calculates performance metrics when creating a new listing.",
      "layer": "test",
      "docstring": "Test that URL ingestion calculates performance metrics when creating a new listing.",
      "category": "test"
    },
    {
      "name": "test_url_ingestion_calculates_metrics_on_update",
      "kind": "async_function",
      "path": "tests/test_ingestion_metrics_calculation.py",
      "line": 110,
      "signature": "async test_url_ingestion_calculates_metrics_on_update(db_session: AsyncSession, sample_cpu: Cpu)",
      "summary": "Test that URL ingestion recalculates metrics when updating an existing listing.",
      "layer": "test",
      "docstring": "Test that URL ingestion recalculates metrics when updating an existing listing.",
      "category": "test"
    },
    {
      "name": "test_url_ingestion_skips_metrics_without_cpu",
      "kind": "async_function",
      "path": "tests/test_ingestion_metrics_calculation.py",
      "line": 173,
      "signature": "async test_url_ingestion_skips_metrics_without_cpu(db_session: AsyncSession)",
      "summary": "Test that URL ingestion skips metrics calculation when no CPU is identified.",
      "layer": "test",
      "docstring": "Test that URL ingestion skips metrics calculation when no CPU is identified.",
      "category": "test"
    },
    {
      "name": "TestBasicOperators",
      "kind": "class",
      "path": "tests/core/test_rule_conditions.py",
      "line": 17,
      "signature": "class TestBasicOperators",
      "summary": "Test basic comparison operators.",
      "layer": "test",
      "docstring": "Test basic comparison operators.",
      "category": "test"
    },
    {
      "name": "test_equals_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 20,
      "signature": "test_equals_operator(self)",
      "summary": "Test equality comparison.",
      "layer": "test",
      "parent": "TestBasicOperators",
      "docstring": "Test equality comparison.",
      "category": "test"
    },
    {
      "name": "test_not_equals_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 37,
      "signature": "test_not_equals_operator(self)",
      "summary": "Test inequality comparison.",
      "layer": "test",
      "parent": "TestBasicOperators",
      "docstring": "Test inequality comparison.",
      "category": "test"
    },
    {
      "name": "test_greater_than_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 52,
      "signature": "test_greater_than_operator(self)",
      "summary": "Test greater than comparison.",
      "layer": "test",
      "parent": "TestBasicOperators",
      "docstring": "Test greater than comparison.",
      "category": "test"
    },
    {
      "name": "test_less_than_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 70,
      "signature": "test_less_than_operator(self)",
      "summary": "Test less than comparison.",
      "layer": "test",
      "parent": "TestBasicOperators",
      "docstring": "Test less than comparison.",
      "category": "test"
    },
    {
      "name": "test_greater_than_or_equal_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 85,
      "signature": "test_greater_than_or_equal_operator(self)",
      "summary": "Test >= comparison.",
      "layer": "test",
      "parent": "TestBasicOperators",
      "docstring": "Test >= comparison.",
      "category": "test"
    },
    {
      "name": "test_less_than_or_equal_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 103,
      "signature": "test_less_than_or_equal_operator(self)",
      "summary": "Test <= comparison.",
      "layer": "test",
      "parent": "TestBasicOperators",
      "docstring": "Test <= comparison.",
      "category": "test"
    },
    {
      "name": "test_between_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 121,
      "signature": "test_between_operator(self)",
      "summary": "Test between operator (inclusive).",
      "layer": "test",
      "parent": "TestBasicOperators",
      "docstring": "Test between operator (inclusive).",
      "category": "test"
    },
    {
      "name": "TestStringOperators",
      "kind": "class",
      "path": "tests/core/test_rule_conditions.py",
      "line": 146,
      "signature": "class TestStringOperators",
      "summary": "Test string-specific operators.",
      "layer": "test",
      "docstring": "Test string-specific operators.",
      "category": "test"
    },
    {
      "name": "test_contains_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 149,
      "signature": "test_contains_operator(self)",
      "summary": "Test contains operator.",
      "layer": "test",
      "parent": "TestStringOperators",
      "docstring": "Test contains operator.",
      "category": "test"
    },
    {
      "name": "test_starts_with_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 164,
      "signature": "test_starts_with_operator(self)",
      "summary": "Test starts_with operator.",
      "layer": "test",
      "parent": "TestStringOperators",
      "docstring": "Test starts_with operator.",
      "category": "test"
    },
    {
      "name": "test_ends_with_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 179,
      "signature": "test_ends_with_operator(self)",
      "summary": "Test ends_with operator.",
      "layer": "test",
      "parent": "TestStringOperators",
      "docstring": "Test ends_with operator.",
      "category": "test"
    },
    {
      "name": "test_regex_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 194,
      "signature": "test_regex_operator(self)",
      "summary": "Test regex operator.",
      "layer": "test",
      "parent": "TestStringOperators",
      "docstring": "Test regex operator.",
      "category": "test"
    },
    {
      "name": "TestSetOperators",
      "kind": "class",
      "path": "tests/core/test_rule_conditions.py",
      "line": 210,
      "signature": "class TestSetOperators",
      "summary": "Test set membership operators.",
      "layer": "test",
      "docstring": "Test set membership operators.",
      "category": "test"
    },
    {
      "name": "test_in_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 213,
      "signature": "test_in_operator(self)",
      "summary": "Test 'in' operator.",
      "layer": "test",
      "parent": "TestSetOperators",
      "docstring": "Test 'in' operator.",
      "category": "test"
    },
    {
      "name": "test_not_in_operator",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 228,
      "signature": "test_not_in_operator(self)",
      "summary": "Test 'not in' operator.",
      "layer": "test",
      "parent": "TestSetOperators",
      "docstring": "Test 'not in' operator.",
      "category": "test"
    },
    {
      "name": "TestNestedConditions",
      "kind": "class",
      "path": "tests/core/test_rule_conditions.py",
      "line": 244,
      "signature": "class TestNestedConditions",
      "summary": "Test nested condition groups with AND/OR logic.",
      "layer": "test",
      "docstring": "Test nested condition groups with AND/OR logic.",
      "category": "test"
    },
    {
      "name": "test_and_group",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 247,
      "signature": "test_and_group(self)",
      "summary": "Test AND group - all conditions must match.",
      "layer": "test",
      "parent": "TestNestedConditions",
      "docstring": "Test AND group - all conditions must match.",
      "category": "test"
    },
    {
      "name": "test_or_group",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 281,
      "signature": "test_or_group(self)",
      "summary": "Test OR group - any condition can match.",
      "layer": "test",
      "parent": "TestNestedConditions",
      "docstring": "Test OR group - any condition can match.",
      "category": "test"
    },
    {
      "name": "test_deeply_nested_groups",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 315,
      "signature": "test_deeply_nested_groups(self)",
      "summary": "Test deeply nested condition groups.",
      "layer": "test",
      "parent": "TestNestedConditions",
      "docstring": "Test deeply nested condition groups.",
      "category": "test"
    },
    {
      "name": "TestEdgeCases",
      "kind": "class",
      "path": "tests/core/test_rule_conditions.py",
      "line": 353,
      "signature": "class TestEdgeCases",
      "summary": "Test edge cases and error handling.",
      "layer": "test",
      "docstring": "Test edge cases and error handling.",
      "category": "test"
    },
    {
      "name": "test_missing_field",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 356,
      "signature": "test_missing_field(self)",
      "summary": "Test behavior when field is missing from context.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test behavior when field is missing from context.",
      "category": "test"
    },
    {
      "name": "test_null_value",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 372,
      "signature": "test_null_value(self)",
      "summary": "Test behavior with null/None values.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test behavior with null/None values.",
      "category": "test"
    },
    {
      "name": "test_type_coercion",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 383,
      "signature": "test_type_coercion(self)",
      "summary": "Test automatic type coercion.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test automatic type coercion.",
      "category": "test"
    },
    {
      "name": "test_case_insensitive_string_compare",
      "kind": "method",
      "path": "tests/core/test_rule_conditions.py",
      "line": 396,
      "signature": "test_case_insensitive_string_compare(self)",
      "summary": "Test case-insensitive string comparison.",
      "layer": "test",
      "parent": "TestEdgeCases",
      "docstring": "Test case-insensitive string comparison.",
      "category": "test"
    },
    {
      "name": "TestFormulaParserBasics",
      "kind": "class",
      "path": "tests/core/test_formula_parser.py",
      "line": 14,
      "signature": "class TestFormulaParserBasics",
      "summary": "Test basic formula parsing functionality",
      "layer": "test",
      "docstring": "Test basic formula parsing functionality",
      "category": "test"
    },
    {
      "name": "test_parse_simple_arithmetic",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 17,
      "signature": "test_parse_simple_arithmetic(self)",
      "summary": "Test parsing simple arithmetic expressions",
      "layer": "test",
      "parent": "TestFormulaParserBasics",
      "docstring": "Test parsing simple arithmetic expressions",
      "category": "test"
    },
    {
      "name": "test_parse_with_variables",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 29,
      "signature": "test_parse_with_variables(self)",
      "summary": "Test parsing with variable references",
      "layer": "test",
      "parent": "TestFormulaParserBasics",
      "docstring": "Test parsing with variable references",
      "category": "test"
    },
    {
      "name": "test_parse_nested_attributes",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 37,
      "signature": "test_parse_nested_attributes(self)",
      "summary": "Test parsing nested attribute access",
      "layer": "test",
      "parent": "TestFormulaParserBasics",
      "docstring": "Test parsing nested attribute access",
      "category": "test"
    },
    {
      "name": "test_parse_functions",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 45,
      "signature": "test_parse_functions(self)",
      "summary": "Test parsing function calls",
      "layer": "test",
      "parent": "TestFormulaParserBasics",
      "docstring": "Test parsing function calls",
      "category": "test"
    },
    {
      "name": "test_parse_comparisons",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 56,
      "signature": "test_parse_comparisons(self)",
      "summary": "Test parsing comparison operations",
      "layer": "test",
      "parent": "TestFormulaParserBasics",
      "docstring": "Test parsing comparison operations",
      "category": "test"
    },
    {
      "name": "test_parse_ternary",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 66,
      "signature": "test_parse_ternary(self)",
      "summary": "Test parsing ternary expressions",
      "layer": "test",
      "parent": "TestFormulaParserBasics",
      "docstring": "Test parsing ternary expressions",
      "category": "test"
    },
    {
      "name": "test_parse_complex_formula",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 73,
      "signature": "test_parse_complex_formula(self)",
      "summary": "Test parsing complex nested formula",
      "layer": "test",
      "parent": "TestFormulaParserBasics",
      "docstring": "Test parsing complex nested formula",
      "category": "test"
    },
    {
      "name": "TestFormulaParserErrors",
      "kind": "class",
      "path": "tests/core/test_formula_parser.py",
      "line": 85,
      "signature": "class TestFormulaParserErrors",
      "summary": "Test formula parser error handling",
      "layer": "test",
      "docstring": "Test formula parser error handling",
      "category": "test"
    },
    {
      "name": "test_empty_formula",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 88,
      "signature": "test_empty_formula(self)",
      "summary": "Test that empty formula raises error",
      "layer": "test",
      "parent": "TestFormulaParserErrors",
      "docstring": "Test that empty formula raises error",
      "category": "test"
    },
    {
      "name": "test_syntax_error_with_position",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 97,
      "signature": "test_syntax_error_with_position(self)",
      "summary": "Test that syntax errors include position information",
      "layer": "test",
      "parent": "TestFormulaParserErrors",
      "docstring": "Test that syntax errors include position information",
      "category": "test"
    },
    {
      "name": "test_unmatched_parentheses_suggestion",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 110,
      "signature": "test_unmatched_parentheses_suggestion(self)",
      "summary": "Test helpful suggestion for unmatched parentheses",
      "layer": "test",
      "parent": "TestFormulaParserErrors",
      "docstring": "Test helpful suggestion for unmatched parentheses",
      "category": "test"
    },
    {
      "name": "test_incomplete_operation_suggestion",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 131,
      "signature": "test_incomplete_operation_suggestion(self)",
      "summary": "Test helpful suggestion for incomplete operations",
      "layer": "test",
      "parent": "TestFormulaParserErrors",
      "docstring": "Test helpful suggestion for incomplete operations",
      "category": "test"
    },
    {
      "name": "test_disallowed_function",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 142,
      "signature": "test_disallowed_function(self)",
      "summary": "Test that disallowed functions raise validation error",
      "layer": "test",
      "parent": "TestFormulaParserErrors",
      "docstring": "Test that disallowed functions raise validation error",
      "category": "test"
    },
    {
      "name": "test_disallowed_operator",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 153,
      "signature": "test_disallowed_operator(self)",
      "summary": "Test that disallowed operators raise validation error",
      "layer": "test",
      "parent": "TestFormulaParserErrors",
      "docstring": "Test that disallowed operators raise validation error",
      "category": "test"
    },
    {
      "name": "test_disallowed_ast_node",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 164,
      "signature": "test_disallowed_ast_node(self)",
      "summary": "Test that disallowed AST nodes raise validation error",
      "layer": "test",
      "parent": "TestFormulaParserErrors",
      "docstring": "Test that disallowed AST nodes raise validation error",
      "category": "test"
    },
    {
      "name": "TestFormulaEngine",
      "kind": "class",
      "path": "tests/core/test_formula_parser.py",
      "line": 182,
      "signature": "class TestFormulaEngine",
      "summary": "Test formula evaluation engine",
      "layer": "test",
      "docstring": "Test formula evaluation engine",
      "category": "test"
    },
    {
      "name": "test_evaluate_simple_arithmetic",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 185,
      "signature": "test_evaluate_simple_arithmetic(self)",
      "summary": "Test evaluating simple arithmetic",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test evaluating simple arithmetic",
      "category": "test"
    },
    {
      "name": "test_evaluate_with_variables",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 193,
      "signature": "test_evaluate_with_variables(self)",
      "summary": "Test evaluating with variable context",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test evaluating with variable context",
      "category": "test"
    },
    {
      "name": "test_evaluate_with_nested_fields",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 202,
      "signature": "test_evaluate_with_nested_fields(self)",
      "summary": "Test evaluating with nested field access",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test evaluating with nested field access",
      "category": "test"
    },
    {
      "name": "test_evaluate_with_functions",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 219,
      "signature": "test_evaluate_with_functions(self)",
      "summary": "Test evaluating formulas with functions",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test evaluating formulas with functions",
      "category": "test"
    },
    {
      "name": "test_evaluate_clamp_function",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 229,
      "signature": "test_evaluate_clamp_function(self)",
      "summary": "Test clamp function",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test clamp function",
      "category": "test"
    },
    {
      "name": "test_evaluate_ternary",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 249,
      "signature": "test_evaluate_ternary(self)",
      "summary": "Test evaluating ternary expressions",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test evaluating ternary expressions",
      "category": "test"
    },
    {
      "name": "test_evaluate_complex_formula",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 262,
      "signature": "test_evaluate_complex_formula(self)",
      "summary": "Test evaluating complex formula",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test evaluating complex formula",
      "category": "test"
    },
    {
      "name": "test_evaluate_undefined_variable_error",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 285,
      "signature": "test_evaluate_undefined_variable_error(self)",
      "summary": "Test that undefined variables raise helpful error",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test that undefined variables raise helpful error",
      "category": "test"
    },
    {
      "name": "test_evaluate_zero_division_error",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 299,
      "signature": "test_evaluate_zero_division_error(self)",
      "summary": "Test that division by zero raises helpful error",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test that division by zero raises helpful error",
      "category": "test"
    },
    {
      "name": "test_evaluate_type_error",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 310,
      "signature": "test_evaluate_type_error(self)",
      "summary": "Test that type errors raise helpful error",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test that type errors raise helpful error",
      "category": "test"
    },
    {
      "name": "test_empty_formula_returns_zero",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 319,
      "signature": "test_empty_formula_returns_zero(self)",
      "summary": "Test that empty formula returns 0",
      "layer": "test",
      "parent": "TestFormulaEngine",
      "docstring": "Test that empty formula returns 0",
      "category": "test"
    },
    {
      "name": "TestFormulaEngineSecurity",
      "kind": "class",
      "path": "tests/core/test_formula_parser.py",
      "line": 327,
      "signature": "class TestFormulaEngineSecurity",
      "summary": "Test formula engine security restrictions",
      "layer": "test",
      "docstring": "Test formula engine security restrictions",
      "category": "test"
    },
    {
      "name": "test_cannot_access_builtins",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 330,
      "signature": "test_cannot_access_builtins(self)",
      "summary": "Test that builtins are not accessible",
      "layer": "test",
      "parent": "TestFormulaEngineSecurity",
      "docstring": "Test that builtins are not accessible",
      "category": "test"
    },
    {
      "name": "test_cannot_import_modules",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 338,
      "signature": "test_cannot_import_modules(self)",
      "summary": "Test that import statements are blocked",
      "layer": "test",
      "parent": "TestFormulaEngineSecurity",
      "docstring": "Test that import statements are blocked",
      "category": "test"
    },
    {
      "name": "test_cannot_execute_code",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 345,
      "signature": "test_cannot_execute_code(self)",
      "summary": "Test that code execution is blocked",
      "layer": "test",
      "parent": "TestFormulaEngineSecurity",
      "docstring": "Test that code execution is blocked",
      "category": "test"
    },
    {
      "name": "test_cannot_use_eval",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 352,
      "signature": "test_cannot_use_eval(self)",
      "summary": "Test that eval is blocked",
      "layer": "test",
      "parent": "TestFormulaEngineSecurity",
      "docstring": "Test that eval is blocked",
      "category": "test"
    },
    {
      "name": "TestFormulaEngineTestCases",
      "kind": "class",
      "path": "tests/core/test_formula_parser.py",
      "line": 360,
      "signature": "class TestFormulaEngineTestCases",
      "summary": "Test formula test case functionality",
      "layer": "test",
      "docstring": "Test formula test case functionality",
      "category": "test"
    },
    {
      "name": "test_test_formula_with_cases",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 363,
      "signature": "test_test_formula_with_cases(self)",
      "summary": "Test testing a formula against multiple cases",
      "layer": "test",
      "parent": "TestFormulaEngineTestCases",
      "docstring": "Test testing a formula against multiple cases",
      "category": "test"
    },
    {
      "name": "test_test_formula_with_failing_case",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 384,
      "signature": "test_test_formula_with_failing_case(self)",
      "summary": "Test that failing cases are reported",
      "layer": "test",
      "parent": "TestFormulaEngineTestCases",
      "docstring": "Test that failing cases are reported",
      "category": "test"
    },
    {
      "name": "TestFormulaPerformance",
      "kind": "class",
      "path": "tests/core/test_formula_parser.py",
      "line": 403,
      "signature": "class TestFormulaPerformance",
      "summary": "Test formula parsing and evaluation performance",
      "layer": "test",
      "docstring": "Test formula parsing and evaluation performance",
      "category": "test"
    },
    {
      "name": "test_parse_performance",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 406,
      "signature": "test_parse_performance(self)",
      "summary": "Test that parsing is fast enough",
      "layer": "test",
      "parent": "TestFormulaPerformance",
      "docstring": "Test that parsing is fast enough",
      "category": "test"
    },
    {
      "name": "test_evaluate_performance",
      "kind": "method",
      "path": "tests/core/test_formula_parser.py",
      "line": 428,
      "signature": "test_evaluate_performance(self)",
      "summary": "Test that evaluation is fast enough",
      "layer": "test",
      "parent": "TestFormulaPerformance",
      "docstring": "Test that evaluation is fast enough",
      "category": "test"
    },
    {
      "name": "TestFormulaValidatorBasics",
      "kind": "class",
      "path": "tests/core/test_formula_validator.py",
      "line": 8,
      "signature": "class TestFormulaValidatorBasics",
      "summary": "Test basic formula validation",
      "layer": "test",
      "docstring": "Test basic formula validation",
      "category": "test"
    },
    {
      "name": "test_validate_simple_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 11,
      "signature": "test_validate_simple_formula(self)",
      "summary": "Test validating simple formula",
      "layer": "test",
      "parent": "TestFormulaValidatorBasics",
      "docstring": "Test validating simple formula",
      "category": "test"
    },
    {
      "name": "test_validate_complex_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 18,
      "signature": "test_validate_complex_formula(self)",
      "summary": "Test validating complex formula",
      "layer": "test",
      "parent": "TestFormulaValidatorBasics",
      "docstring": "Test validating complex formula",
      "category": "test"
    },
    {
      "name": "test_validate_empty_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 29,
      "signature": "test_validate_empty_formula(self)",
      "summary": "Test that empty formula returns error",
      "layer": "test",
      "parent": "TestFormulaValidatorBasics",
      "docstring": "Test that empty formula returns error",
      "category": "test"
    },
    {
      "name": "test_validate_syntax_error",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 38,
      "signature": "test_validate_syntax_error(self)",
      "summary": "Test that syntax errors are captured",
      "layer": "test",
      "parent": "TestFormulaValidatorBasics",
      "docstring": "Test that syntax errors are captured",
      "category": "test"
    },
    {
      "name": "test_validate_invalid_function",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 47,
      "signature": "test_validate_invalid_function(self)",
      "summary": "Test that invalid functions are captured",
      "layer": "test",
      "parent": "TestFormulaValidatorBasics",
      "docstring": "Test that invalid functions are captured",
      "category": "test"
    },
    {
      "name": "TestFormulaValidatorFieldExtraction",
      "kind": "class",
      "path": "tests/core/test_formula_validator.py",
      "line": 56,
      "signature": "class TestFormulaValidatorFieldExtraction",
      "summary": "Test field reference extraction",
      "layer": "test",
      "docstring": "Test field reference extraction",
      "category": "test"
    },
    {
      "name": "test_extract_simple_fields",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 59,
      "signature": "test_extract_simple_fields(self)",
      "summary": "Test extracting simple field references",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldExtraction",
      "docstring": "Test extracting simple field references",
      "category": "test"
    },
    {
      "name": "test_extract_nested_fields",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 66,
      "signature": "test_extract_nested_fields(self)",
      "summary": "Test extracting nested field references",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldExtraction",
      "docstring": "Test extracting nested field references",
      "category": "test"
    },
    {
      "name": "test_extract_fields_from_functions",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 74,
      "signature": "test_extract_fields_from_functions(self)",
      "summary": "Test extracting fields from function calls",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldExtraction",
      "docstring": "Test extracting fields from function calls",
      "category": "test"
    },
    {
      "name": "test_extract_fields_from_ternary",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 81,
      "signature": "test_extract_fields_from_ternary(self)",
      "summary": "Test extracting fields from ternary expressions",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldExtraction",
      "docstring": "Test extracting fields from ternary expressions",
      "category": "test"
    },
    {
      "name": "test_extract_fields_from_complex_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 91,
      "signature": "test_extract_fields_from_complex_formula(self)",
      "summary": "Test extracting fields from complex formula",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldExtraction",
      "docstring": "Test extracting fields from complex formula",
      "category": "test"
    },
    {
      "name": "test_extract_fields_ignores_constants",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 104,
      "signature": "test_extract_fields_ignores_constants(self)",
      "summary": "Test that constants are not extracted as fields",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldExtraction",
      "docstring": "Test that constants are not extracted as fields",
      "category": "test"
    },
    {
      "name": "test_extract_fields_from_invalid_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 113,
      "signature": "test_extract_fields_from_invalid_formula(self)",
      "summary": "Test that field extraction handles invalid formulas gracefully",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldExtraction",
      "docstring": "Test that field extraction handles invalid formulas gracefully",
      "category": "test"
    },
    {
      "name": "TestFormulaValidatorASTVisualization",
      "kind": "class",
      "path": "tests/core/test_formula_validator.py",
      "line": 122,
      "signature": "class TestFormulaValidatorASTVisualization",
      "summary": "Test AST visualization",
      "layer": "test",
      "docstring": "Test AST visualization",
      "category": "test"
    },
    {
      "name": "test_visualize_simple_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 125,
      "signature": "test_visualize_simple_formula(self)",
      "summary": "Test visualizing simple formula",
      "layer": "test",
      "parent": "TestFormulaValidatorASTVisualization",
      "docstring": "Test visualizing simple formula",
      "category": "test"
    },
    {
      "name": "test_visualize_nested_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 137,
      "signature": "test_visualize_nested_formula(self)",
      "summary": "Test visualizing nested formula",
      "layer": "test",
      "parent": "TestFormulaValidatorASTVisualization",
      "docstring": "Test visualizing nested formula",
      "category": "test"
    },
    {
      "name": "test_visualize_complex_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 148,
      "signature": "test_visualize_complex_formula(self)",
      "summary": "Test visualizing complex formula",
      "layer": "test",
      "parent": "TestFormulaValidatorASTVisualization",
      "docstring": "Test visualizing complex formula",
      "category": "test"
    },
    {
      "name": "test_visualize_attribute_access",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 161,
      "signature": "test_visualize_attribute_access(self)",
      "summary": "Test visualizing attribute access",
      "layer": "test",
      "parent": "TestFormulaValidatorASTVisualization",
      "docstring": "Test visualizing attribute access",
      "category": "test"
    },
    {
      "name": "test_visualize_invalid_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 170,
      "signature": "test_visualize_invalid_formula(self)",
      "summary": "Test that visualization handles invalid formulas",
      "layer": "test",
      "parent": "TestFormulaValidatorASTVisualization",
      "docstring": "Test that visualization handles invalid formulas",
      "category": "test"
    },
    {
      "name": "test_visualize_with_custom_indent",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 179,
      "signature": "test_visualize_with_custom_indent(self)",
      "summary": "Test visualization with custom indentation",
      "layer": "test",
      "parent": "TestFormulaValidatorASTVisualization",
      "docstring": "Test visualization with custom indentation",
      "category": "test"
    },
    {
      "name": "TestFormulaValidatorFieldAvailability",
      "kind": "class",
      "path": "tests/core/test_formula_validator.py",
      "line": 190,
      "signature": "class TestFormulaValidatorFieldAvailability",
      "summary": "Test field availability validation",
      "layer": "test",
      "docstring": "Test field availability validation",
      "category": "test"
    },
    {
      "name": "test_validate_all_fields_available",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 193,
      "signature": "test_validate_all_fields_available(self)",
      "summary": "Test that validation passes when all fields are available",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldAvailability",
      "docstring": "Test that validation passes when all fields are available",
      "category": "test"
    },
    {
      "name": "test_validate_missing_field",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 203,
      "signature": "test_validate_missing_field(self)",
      "summary": "Test that missing fields are reported",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldAvailability",
      "docstring": "Test that missing fields are reported",
      "category": "test"
    },
    {
      "name": "test_validate_multiple_missing_fields",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 215,
      "signature": "test_validate_multiple_missing_fields(self)",
      "summary": "Test that multiple missing fields are reported",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldAvailability",
      "docstring": "Test that multiple missing fields are reported",
      "category": "test"
    },
    {
      "name": "test_validate_suggests_similar_field",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 225,
      "signature": "test_validate_suggests_similar_field(self)",
      "summary": "Test that similar fields are suggested",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldAvailability",
      "docstring": "Test that similar fields are suggested",
      "category": "test"
    },
    {
      "name": "test_validate_nested_field_availability",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 237,
      "signature": "test_validate_nested_field_availability(self)",
      "summary": "Test validating nested field availability",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldAvailability",
      "docstring": "Test validating nested field availability",
      "category": "test"
    },
    {
      "name": "test_validate_nested_field_missing",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 247,
      "signature": "test_validate_nested_field_missing(self)",
      "summary": "Test that missing nested fields are reported",
      "layer": "test",
      "parent": "TestFormulaValidatorFieldAvailability",
      "docstring": "Test that missing nested fields are reported",
      "category": "test"
    },
    {
      "name": "TestFormulaValidatorWarnings",
      "kind": "class",
      "path": "tests/core/test_formula_validator.py",
      "line": 259,
      "signature": "class TestFormulaValidatorWarnings",
      "summary": "Test best practice warnings",
      "layer": "test",
      "docstring": "Test best practice warnings",
      "category": "test"
    },
    {
      "name": "test_warning_for_division",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 262,
      "signature": "test_warning_for_division(self)",
      "summary": "Test warning for division operations",
      "layer": "test",
      "parent": "TestFormulaValidatorWarnings",
      "docstring": "Test warning for division operations",
      "category": "test"
    },
    {
      "name": "test_warning_for_deep_nesting",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 273,
      "signature": "test_warning_for_deep_nesting(self)",
      "summary": "Test warning for deeply nested formulas",
      "layer": "test",
      "parent": "TestFormulaValidatorWarnings",
      "docstring": "Test warning for deeply nested formulas",
      "category": "test"
    },
    {
      "name": "test_info_for_multiple_divisions",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 285,
      "signature": "test_info_for_multiple_divisions(self)",
      "summary": "Test info message for multiple divisions",
      "layer": "test",
      "parent": "TestFormulaValidatorWarnings",
      "docstring": "Test info message for multiple divisions",
      "category": "test"
    },
    {
      "name": "test_no_warnings_for_simple_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 296,
      "signature": "test_no_warnings_for_simple_formula(self)",
      "summary": "Test that simple formulas don't generate warnings",
      "layer": "test",
      "parent": "TestFormulaValidatorWarnings",
      "docstring": "Test that simple formulas don't generate warnings",
      "category": "test"
    },
    {
      "name": "TestValidationErrorClass",
      "kind": "class",
      "path": "tests/core/test_formula_validator.py",
      "line": 307,
      "signature": "class TestValidationErrorClass",
      "summary": "Test ValidationError class",
      "layer": "test",
      "docstring": "Test ValidationError class",
      "category": "test"
    },
    {
      "name": "test_validation_error_basic",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 310,
      "signature": "test_validation_error_basic(self)",
      "summary": "Test basic ValidationError creation",
      "layer": "test",
      "parent": "TestValidationErrorClass",
      "docstring": "Test basic ValidationError creation",
      "category": "test"
    },
    {
      "name": "test_validation_error_with_details",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 319,
      "signature": "test_validation_error_with_details(self)",
      "summary": "Test ValidationError with all details",
      "layer": "test",
      "parent": "TestValidationErrorClass",
      "docstring": "Test ValidationError with all details",
      "category": "test"
    },
    {
      "name": "test_validation_error_repr",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 333,
      "signature": "test_validation_error_repr(self)",
      "summary": "Test ValidationError string representation",
      "layer": "test",
      "parent": "TestValidationErrorClass",
      "docstring": "Test ValidationError string representation",
      "category": "test"
    },
    {
      "name": "test_validation_error_to_dict",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 348,
      "signature": "test_validation_error_to_dict(self)",
      "summary": "Test ValidationError dictionary conversion",
      "layer": "test",
      "parent": "TestValidationErrorClass",
      "docstring": "Test ValidationError dictionary conversion",
      "category": "test"
    },
    {
      "name": "test_validation_error_to_dict_minimal",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 363,
      "signature": "test_validation_error_to_dict_minimal(self)",
      "summary": "Test ValidationError dict with minimal data",
      "layer": "test",
      "parent": "TestValidationErrorClass",
      "docstring": "Test ValidationError dict with minimal data",
      "category": "test"
    },
    {
      "name": "TestFormulaValidatorEdgeCases",
      "kind": "class",
      "path": "tests/core/test_formula_validator.py",
      "line": 374,
      "signature": "class TestFormulaValidatorEdgeCases",
      "summary": "Test edge cases and corner cases",
      "layer": "test",
      "docstring": "Test edge cases and corner cases",
      "category": "test"
    },
    {
      "name": "test_validate_whitespace_only_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 377,
      "signature": "test_validate_whitespace_only_formula(self)",
      "summary": "Test that whitespace-only formula is treated as empty",
      "layer": "test",
      "parent": "TestFormulaValidatorEdgeCases",
      "docstring": "Test that whitespace-only formula is treated as empty",
      "category": "test"
    },
    {
      "name": "test_validate_very_long_formula",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 385,
      "signature": "test_validate_very_long_formula(self)",
      "summary": "Test validating very long formula",
      "layer": "test",
      "parent": "TestFormulaValidatorEdgeCases",
      "docstring": "Test validating very long formula",
      "category": "test"
    },
    {
      "name": "test_extract_fields_with_subscripts",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 397,
      "signature": "test_extract_fields_with_subscripts(self)",
      "summary": "Test field extraction with array subscripts",
      "layer": "test",
      "parent": "TestFormulaValidatorEdgeCases",
      "docstring": "Test field extraction with array subscripts",
      "category": "test"
    },
    {
      "name": "test_visualize_list_literals",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 404,
      "signature": "test_visualize_list_literals(self)",
      "summary": "Test visualizing list literals",
      "layer": "test",
      "parent": "TestFormulaValidatorEdgeCases",
      "docstring": "Test visualizing list literals",
      "category": "test"
    },
    {
      "name": "test_validate_formula_with_unicode",
      "kind": "method",
      "path": "tests/core/test_formula_validator.py",
      "line": 411,
      "signature": "test_validate_formula_with_unicode(self)",
      "summary": "Test that unicode characters are handled",
      "layer": "test",
      "parent": "TestFormulaValidatorEdgeCases",
      "docstring": "Test that unicode characters are handled",
      "category": "test"
    },
    {
      "name": "rules_service",
      "kind": "async_function",
      "path": "tests/services/test_rules_service.py",
      "line": 58,
      "signature": "async rules_service()",
      "summary": "Create RulesService instance.",
      "layer": "test",
      "docstring": "Create RulesService instance.",
      "category": "test"
    },
    {
      "name": "sample_ruleset_data",
      "kind": "async_function",
      "path": "tests/services/test_rules_service.py",
      "line": 64,
      "signature": "async sample_ruleset_data() -> RulesetCreate",
      "summary": "Sample ruleset creation data.",
      "layer": "test",
      "docstring": "Sample ruleset creation data.",
      "category": "test"
    },
    {
      "name": "sample_rule_group_data",
      "kind": "async_function",
      "path": "tests/services/test_rules_service.py",
      "line": 76,
      "signature": "async sample_rule_group_data() -> RuleGroupCreate",
      "summary": "Sample rule group creation data.",
      "layer": "test",
      "docstring": "Sample rule group creation data.",
      "category": "test"
    },
    {
      "name": "sample_rule_data",
      "kind": "async_function",
      "path": "tests/services/test_rules_service.py",
      "line": 88,
      "signature": "async sample_rule_data() -> RuleCreate",
      "summary": "Sample rule creation data.",
      "layer": "test",
      "docstring": "Sample rule creation data.",
      "category": "test"
    },
    {
      "name": "recalculation_spy",
      "kind": "function",
      "path": "tests/services/test_rules_service.py",
      "line": 122,
      "signature": "recalculation_spy(monkeypatch)",
      "summary": "Capture recalculation enqueue invocations.",
      "layer": "test",
      "docstring": "Capture recalculation enqueue invocations.",
      "category": "test"
    },
    {
      "name": "TestRulesetCRUD",
      "kind": "class",
      "path": "tests/services/test_rules_service.py",
      "line": 136,
      "signature": "class TestRulesetCRUD",
      "summary": "Test ruleset CRUD operations.",
      "layer": "test",
      "docstring": "Test ruleset CRUD operations.",
      "category": "test"
    },
    {
      "name": "test_create_ruleset",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 140,
      "signature": "async test_create_ruleset(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, recalculation_spy)",
      "summary": "Test creating a new ruleset.",
      "layer": "test",
      "parent": "TestRulesetCRUD",
      "docstring": "Test creating a new ruleset.",
      "category": "test"
    },
    {
      "name": "test_get_ruleset",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 161,
      "signature": "async test_get_ruleset(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate)",
      "summary": "Test retrieving a ruleset by ID.",
      "layer": "test",
      "parent": "TestRulesetCRUD",
      "docstring": "Test retrieving a ruleset by ID.",
      "category": "test"
    },
    {
      "name": "test_get_ruleset_not_found",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 173,
      "signature": "async test_get_ruleset_not_found(self, db_session: AsyncSession, rules_service: RulesService)",
      "summary": "Test retrieving non-existent ruleset returns None.",
      "layer": "test",
      "parent": "TestRulesetCRUD",
      "docstring": "Test retrieving non-existent ruleset returns None.",
      "category": "test"
    },
    {
      "name": "test_list_rulesets",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 179,
      "signature": "async test_list_rulesets(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate)",
      "summary": "Test listing all rulesets.",
      "layer": "test",
      "parent": "TestRulesetCRUD",
      "docstring": "Test listing all rulesets.",
      "category": "test"
    },
    {
      "name": "test_list_rulesets_active_only",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 194,
      "signature": "async test_list_rulesets_active_only(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate)",
      "summary": "Test filtering rulesets by active status.",
      "layer": "test",
      "parent": "TestRulesetCRUD",
      "docstring": "Test filtering rulesets by active status.",
      "category": "test"
    },
    {
      "name": "test_update_ruleset",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 211,
      "signature": "async test_update_ruleset(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, recalculation_spy)",
      "summary": "Test updating a ruleset.",
      "layer": "test",
      "parent": "TestRulesetCRUD",
      "docstring": "Test updating a ruleset.",
      "category": "test"
    },
    {
      "name": "test_delete_ruleset",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 238,
      "signature": "async test_delete_ruleset(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, recalculation_spy)",
      "summary": "Test deleting a ruleset.",
      "layer": "test",
      "parent": "TestRulesetCRUD",
      "docstring": "Test deleting a ruleset.",
      "category": "test"
    },
    {
      "name": "TestRuleGroupCRUD",
      "kind": "class",
      "path": "tests/services/test_rules_service.py",
      "line": 258,
      "signature": "class TestRuleGroupCRUD",
      "summary": "Test rule group CRUD operations.",
      "layer": "test",
      "docstring": "Test rule group CRUD operations.",
      "category": "test"
    },
    {
      "name": "test_create_rule_group",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 262,
      "signature": "async test_create_rule_group(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate, recalculation_spy)",
      "summary": "Test creating a rule group.",
      "layer": "test",
      "parent": "TestRuleGroupCRUD",
      "docstring": "Test creating a rule group.",
      "category": "test"
    },
    {
      "name": "test_list_rule_groups",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 286,
      "signature": "async test_list_rule_groups(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate)",
      "summary": "Test listing rule groups for a ruleset.",
      "layer": "test",
      "parent": "TestRuleGroupCRUD",
      "docstring": "Test listing rule groups for a ruleset.",
      "category": "test"
    },
    {
      "name": "test_delete_rule_group",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 308,
      "signature": "async test_delete_rule_group(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate)",
      "summary": "Test deleting a rule group.",
      "layer": "test",
      "parent": "TestRuleGroupCRUD",
      "docstring": "Test deleting a rule group.",
      "category": "test"
    },
    {
      "name": "TestRuleCRUD",
      "kind": "class",
      "path": "tests/services/test_rules_service.py",
      "line": 325,
      "signature": "class TestRuleCRUD",
      "summary": "Test rule CRUD operations.",
      "layer": "test",
      "docstring": "Test rule CRUD operations.",
      "category": "test"
    },
    {
      "name": "test_create_rule",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 329,
      "signature": "async test_create_rule(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate, sample_rule_data: RuleCreate, recalculation_spy)",
      "summary": "Test creating a rule.",
      "layer": "test",
      "parent": "TestRuleCRUD",
      "docstring": "Test creating a rule.",
      "category": "test"
    },
    {
      "name": "test_create_per_unit_rule_requires_metric",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 357,
      "signature": "async test_create_per_unit_rule_requires_metric(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate)",
      "summary": "Per-unit actions without metrics should be rejected.",
      "layer": "test",
      "parent": "TestRuleCRUD",
      "docstring": "Per-unit actions without metrics should be rejected.",
      "category": "test"
    },
    {
      "name": "test_create_rule_with_nested_conditions",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 386,
      "signature": "async test_create_rule_with_nested_conditions(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate)",
      "summary": "Test creating a rule with nested AND/OR conditions.",
      "layer": "test",
      "parent": "TestRuleCRUD",
      "docstring": "Test creating a rule with nested AND/OR conditions.",
      "category": "test"
    },
    {
      "name": "test_list_rules",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 448,
      "signature": "async test_list_rules(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate, sample_rule_data: RuleCreate)",
      "summary": "Test listing rules in a group.",
      "layer": "test",
      "parent": "TestRuleCRUD",
      "docstring": "Test listing rules in a group.",
      "category": "test"
    },
    {
      "name": "test_update_rule",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 473,
      "signature": "async test_update_rule(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate, sample_rule_data: RuleCreate, recalculation_spy)",
      "summary": "Test updating a rule.",
      "layer": "test",
      "parent": "TestRuleCRUD",
      "docstring": "Test updating a rule.",
      "category": "test"
    },
    {
      "name": "test_delete_rule",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 506,
      "signature": "async test_delete_rule(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate, sample_rule_data: RuleCreate, recalculation_spy)",
      "summary": "Test deleting a rule.",
      "layer": "test",
      "parent": "TestRuleCRUD",
      "docstring": "Test deleting a rule.",
      "category": "test"
    },
    {
      "name": "test_delete_ruleset_cascades",
      "kind": "async_method",
      "path": "tests/services/test_rules_service.py",
      "line": 528,
      "signature": "async test_delete_ruleset_cascades(self, db_session: AsyncSession, rules_service: RulesService, sample_ruleset_data: RulesetCreate, sample_rule_group_data: RuleGroupCreate, sample_rule_data: RuleCreate)",
      "summary": "Test that deleting a ruleset cascades to groups and rules.",
      "layer": "test",
      "parent": "TestRuleCRUD",
      "docstring": "Test that deleting a ruleset cascades to groups and rules.",
      "category": "test"
    },
    {
      "name": "evaluation_service",
      "kind": "async_function",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 27,
      "signature": "async evaluation_service()",
      "summary": "Create RuleEvaluationService instance.",
      "layer": "test",
      "docstring": "Create RuleEvaluationService instance.",
      "category": "test"
    },
    {
      "name": "rules_service",
      "kind": "async_function",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 33,
      "signature": "async rules_service()",
      "summary": "Create RulesService instance.",
      "layer": "test",
      "docstring": "Create RulesService instance.",
      "category": "test"
    },
    {
      "name": "sample_cpu",
      "kind": "async_function",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 39,
      "signature": "async sample_cpu(db_session: AsyncSession) -> CPU",
      "summary": "Create a sample CPU for testing.",
      "layer": "test",
      "docstring": "Create a sample CPU for testing.",
      "category": "test"
    },
    {
      "name": "sample_gpu",
      "kind": "async_function",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 59,
      "signature": "async sample_gpu(db_session: AsyncSession) -> GPU",
      "summary": "Create a sample GPU for testing.",
      "layer": "test",
      "docstring": "Create a sample GPU for testing.",
      "category": "test"
    },
    {
      "name": "sample_listing",
      "kind": "async_function",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 75,
      "signature": "async sample_listing(db_session: AsyncSession, sample_cpu: CPU, sample_gpu: GPU) -> Listing",
      "summary": "Create a sample listing for testing.",
      "layer": "test",
      "docstring": "Create a sample listing for testing.",
      "category": "test"
    },
    {
      "name": "TestBasicEvaluation",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 102,
      "signature": "class TestBasicEvaluation",
      "summary": "Test basic rule evaluation scenarios.",
      "layer": "test",
      "docstring": "Test basic rule evaluation scenarios.",
      "category": "test"
    },
    {
      "name": "test_evaluate_simple_condition",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 106,
      "signature": "async test_evaluate_simple_condition(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test evaluating a simple condition rule.",
      "layer": "test",
      "parent": "TestBasicEvaluation",
      "docstring": "Test evaluating a simple condition rule.",
      "category": "test"
    },
    {
      "name": "test_evaluate_no_match",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 169,
      "signature": "async test_evaluate_no_match(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test evaluation when no rules match.",
      "layer": "test",
      "parent": "TestBasicEvaluation",
      "docstring": "Test evaluation when no rules match.",
      "category": "test"
    },
    {
      "name": "test_evaluate_multiple_rules",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 227,
      "signature": "async test_evaluate_multiple_rules(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test evaluation with multiple matching rules.",
      "layer": "test",
      "parent": "TestBasicEvaluation",
      "docstring": "Test evaluation with multiple matching rules.",
      "category": "test"
    },
    {
      "name": "TestComplexConditions",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 300,
      "signature": "class TestComplexConditions",
      "summary": "Test evaluation with complex nested conditions.",
      "layer": "test",
      "docstring": "Test evaluation with complex nested conditions.",
      "category": "test"
    },
    {
      "name": "test_evaluate_nested_and_conditions",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 304,
      "signature": "async test_evaluate_nested_and_conditions(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test evaluation with nested AND conditions.",
      "layer": "test",
      "parent": "TestComplexConditions",
      "docstring": "Test evaluation with nested AND conditions.",
      "category": "test"
    },
    {
      "name": "test_evaluate_nested_or_conditions",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 359,
      "signature": "async test_evaluate_nested_or_conditions(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test evaluation with nested OR conditions.",
      "layer": "test",
      "parent": "TestComplexConditions",
      "docstring": "Test evaluation with nested OR conditions.",
      "category": "test"
    },
    {
      "name": "TestActionTypes",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 415,
      "signature": "class TestActionTypes",
      "summary": "Test different action types.",
      "layer": "test",
      "docstring": "Test different action types.",
      "category": "test"
    },
    {
      "name": "test_per_unit_action",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 419,
      "signature": "async test_per_unit_action(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test per-unit pricing action.",
      "layer": "test",
      "parent": "TestActionTypes",
      "docstring": "Test per-unit pricing action.",
      "category": "test"
    },
    {
      "name": "test_multiplier_action",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 471,
      "signature": "async test_multiplier_action(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test multiplier action.",
      "layer": "test",
      "parent": "TestActionTypes",
      "docstring": "Test multiplier action.",
      "category": "test"
    },
    {
      "name": "TestPriorityOrdering",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 522,
      "signature": "class TestPriorityOrdering",
      "summary": "Test rule evaluation order based on priority.",
      "layer": "test",
      "docstring": "Test rule evaluation order based on priority.",
      "category": "test"
    },
    {
      "name": "test_rules_evaluated_by_priority",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation.py",
      "line": 526,
      "signature": "async test_rules_evaluated_by_priority(self, db_session: AsyncSession, rules_service: RulesService, evaluation_service: RuleEvaluationService, sample_listing: Listing)",
      "summary": "Test that rules are evaluated in priority order (higher first).",
      "layer": "test",
      "parent": "TestPriorityOrdering",
      "docstring": "Test that rules are evaluated in priority order (higher first).",
      "category": "test"
    },
    {
      "name": "preview_service",
      "kind": "async_function",
      "path": "tests/services/test_rule_preview.py",
      "line": 26,
      "signature": "async preview_service()",
      "summary": "Create RulePreviewService instance.",
      "layer": "test",
      "docstring": "Create RulePreviewService instance.",
      "category": "test"
    },
    {
      "name": "rules_service",
      "kind": "async_function",
      "path": "tests/services/test_rule_preview.py",
      "line": 32,
      "signature": "async rules_service()",
      "summary": "Create RulesService instance.",
      "layer": "test",
      "docstring": "Create RulesService instance.",
      "category": "test"
    },
    {
      "name": "sample_cpu",
      "kind": "async_function",
      "path": "tests/services/test_rule_preview.py",
      "line": 38,
      "signature": "async sample_cpu(db_session: AsyncSession) -> CPU",
      "summary": "Create a sample CPU for testing.",
      "layer": "test",
      "docstring": "Create a sample CPU for testing.",
      "category": "test"
    },
    {
      "name": "multiple_listings",
      "kind": "async_function",
      "path": "tests/services/test_rule_preview.py",
      "line": 58,
      "signature": "async multiple_listings(db_session: AsyncSession, sample_cpu: CPU) -> list[Listing]",
      "summary": "Create multiple listings for preview testing.",
      "layer": "test",
      "docstring": "Create multiple listings for preview testing.",
      "category": "test"
    },
    {
      "name": "TestPreviewImpact",
      "kind": "class",
      "path": "tests/services/test_rule_preview.py",
      "line": 123,
      "signature": "class TestPreviewImpact",
      "summary": "Test rule impact preview functionality.",
      "layer": "test",
      "docstring": "Test rule impact preview functionality.",
      "category": "test"
    },
    {
      "name": "test_preview_single_rule",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 127,
      "signature": "async test_preview_single_rule(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService, multiple_listings: list[Listing])",
      "summary": "Test preview impact of a single rule.",
      "layer": "test",
      "parent": "TestPreviewImpact",
      "docstring": "Test preview impact of a single rule.",
      "category": "test"
    },
    {
      "name": "test_preview_ruleset_impact",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 179,
      "signature": "async test_preview_ruleset_impact(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService, multiple_listings: list[Listing])",
      "summary": "Test preview impact of entire ruleset.",
      "layer": "test",
      "parent": "TestPreviewImpact",
      "docstring": "Test preview impact of entire ruleset.",
      "category": "test"
    },
    {
      "name": "test_preview_with_filters",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 251,
      "signature": "async test_preview_with_filters(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService, multiple_listings: list[Listing])",
      "summary": "Test preview with filtered listings.",
      "layer": "test",
      "parent": "TestPreviewImpact",
      "docstring": "Test preview with filtered listings.",
      "category": "test"
    },
    {
      "name": "test_preview_sample_listings",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 298,
      "signature": "async test_preview_sample_listings(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService, multiple_listings: list[Listing])",
      "summary": "Test that preview includes sample affected listings.",
      "layer": "test",
      "parent": "TestPreviewImpact",
      "docstring": "Test that preview includes sample affected listings.",
      "category": "test"
    },
    {
      "name": "TestPreviewStatistics",
      "kind": "class",
      "path": "tests/services/test_rule_preview.py",
      "line": 349,
      "signature": "class TestPreviewStatistics",
      "summary": "Test preview statistics calculations.",
      "layer": "test",
      "docstring": "Test preview statistics calculations.",
      "category": "test"
    },
    {
      "name": "test_average_adjustment_calculation",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 353,
      "signature": "async test_average_adjustment_calculation(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService, multiple_listings: list[Listing])",
      "summary": "Test average adjustment calculation.",
      "layer": "test",
      "parent": "TestPreviewStatistics",
      "docstring": "Test average adjustment calculation.",
      "category": "test"
    },
    {
      "name": "test_min_max_adjustments",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 406,
      "signature": "async test_min_max_adjustments(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService, multiple_listings: list[Listing])",
      "summary": "Test min/max adjustment tracking.",
      "layer": "test",
      "parent": "TestPreviewStatistics",
      "docstring": "Test min/max adjustment tracking.",
      "category": "test"
    },
    {
      "name": "TestPreviewEdgeCases",
      "kind": "class",
      "path": "tests/services/test_rule_preview.py",
      "line": 456,
      "signature": "class TestPreviewEdgeCases",
      "summary": "Test edge cases in preview functionality.",
      "layer": "test",
      "docstring": "Test edge cases in preview functionality.",
      "category": "test"
    },
    {
      "name": "test_preview_inactive_rule",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 460,
      "signature": "async test_preview_inactive_rule(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService, multiple_listings: list[Listing])",
      "summary": "Test preview of inactive rule.",
      "layer": "test",
      "parent": "TestPreviewEdgeCases",
      "docstring": "Test preview of inactive rule.",
      "category": "test"
    },
    {
      "name": "test_preview_with_no_listings",
      "kind": "async_method",
      "path": "tests/services/test_rule_preview.py",
      "line": 503,
      "signature": "async test_preview_with_no_listings(self, db_session: AsyncSession, rules_service: RulesService, preview_service: RulePreviewService)",
      "summary": "Test preview when no listings exist.",
      "layer": "test",
      "parent": "TestPreviewEdgeCases",
      "docstring": "Test preview when no listings exist.",
      "category": "test"
    },
    {
      "name": "packaging_service",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 27,
      "signature": "async packaging_service()",
      "summary": "Create RulesetPackagingService instance.",
      "layer": "test",
      "docstring": "Create RulesetPackagingService instance.",
      "category": "test"
    },
    {
      "name": "rules_service",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 33,
      "signature": "async rules_service()",
      "summary": "Create RulesService instance.",
      "layer": "test",
      "docstring": "Create RulesService instance.",
      "category": "test"
    },
    {
      "name": "complete_ruleset",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 39,
      "signature": "async complete_ruleset(db_session: AsyncSession, rules_service: RulesService)",
      "summary": "Create a complete ruleset with groups and rules for testing.",
      "layer": "test",
      "docstring": "Create a complete ruleset with groups and rules for testing.",
      "category": "test"
    },
    {
      "name": "TestPackageExport",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 136,
      "signature": "class TestPackageExport",
      "summary": "Test ruleset package export functionality.",
      "layer": "test",
      "docstring": "Test ruleset package export functionality.",
      "category": "test"
    },
    {
      "name": "test_export_basic_package",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 140,
      "signature": "async test_export_basic_package(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test exporting a basic package.",
      "layer": "test",
      "parent": "TestPackageExport",
      "docstring": "Test exporting a basic package.",
      "category": "test"
    },
    {
      "name": "test_export_with_dependencies",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 169,
      "signature": "async test_export_with_dependencies(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test export includes all dependencies.",
      "layer": "test",
      "parent": "TestPackageExport",
      "docstring": "Test export includes all dependencies.",
      "category": "test"
    },
    {
      "name": "test_export_to_file",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 200,
      "signature": "async test_export_to_file(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict, tmp_path: Path)",
      "summary": "Test exporting package to .dbrs file.",
      "layer": "test",
      "parent": "TestPackageExport",
      "docstring": "Test exporting package to .dbrs file.",
      "category": "test"
    },
    {
      "name": "test_export_active_rules_only",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 235,
      "signature": "async test_export_active_rules_only(self, db_session: AsyncSession, rules_service: RulesService, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test exporting only active rules.",
      "layer": "test",
      "parent": "TestPackageExport",
      "docstring": "Test exporting only active rules.",
      "category": "test"
    },
    {
      "name": "TestPackageImport",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 282,
      "signature": "class TestPackageImport",
      "summary": "Test ruleset package import functionality.",
      "layer": "test",
      "docstring": "Test ruleset package import functionality.",
      "category": "test"
    },
    {
      "name": "test_import_basic_package",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 286,
      "signature": "async test_import_basic_package(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test importing a package.",
      "layer": "test",
      "parent": "TestPackageImport",
      "docstring": "Test importing a package.",
      "category": "test"
    },
    {
      "name": "test_import_with_merge_strategy_skip",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 322,
      "signature": "async test_import_with_merge_strategy_skip(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test import with SKIP merge strategy.",
      "layer": "test",
      "parent": "TestPackageImport",
      "docstring": "Test import with SKIP merge strategy.",
      "category": "test"
    },
    {
      "name": "test_import_with_merge_strategy_replace",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 352,
      "signature": "async test_import_with_merge_strategy_replace(self, db_session: AsyncSession, rules_service: RulesService, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test import with REPLACE merge strategy.",
      "layer": "test",
      "parent": "TestPackageImport",
      "docstring": "Test import with REPLACE merge strategy.",
      "category": "test"
    },
    {
      "name": "test_import_from_file",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 398,
      "signature": "async test_import_from_file(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict, tmp_path: Path)",
      "summary": "Test importing package from .dbrs file.",
      "layer": "test",
      "parent": "TestPackageImport",
      "docstring": "Test importing package from .dbrs file.",
      "category": "test"
    },
    {
      "name": "TestPackageValidation",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 434,
      "signature": "class TestPackageValidation",
      "summary": "Test package validation and compatibility checking.",
      "layer": "test",
      "docstring": "Test package validation and compatibility checking.",
      "category": "test"
    },
    {
      "name": "test_validate_compatible_package",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 438,
      "signature": "async test_validate_compatible_package(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test validating a compatible package.",
      "layer": "test",
      "parent": "TestPackageValidation",
      "docstring": "Test validating a compatible package.",
      "category": "test"
    },
    {
      "name": "test_validate_incompatible_version",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 468,
      "signature": "async test_validate_incompatible_version(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test validating package with incompatible app version.",
      "layer": "test",
      "parent": "TestPackageValidation",
      "docstring": "Test validating package with incompatible app version.",
      "category": "test"
    },
    {
      "name": "test_validate_missing_fields",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 498,
      "signature": "async test_validate_missing_fields(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test validation with missing required fields.",
      "layer": "test",
      "parent": "TestPackageValidation",
      "docstring": "Test validation with missing required fields.",
      "category": "test"
    },
    {
      "name": "TestPackageRoundTrip",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 528,
      "signature": "class TestPackageRoundTrip",
      "summary": "Test complete export/import round trip.",
      "layer": "test",
      "docstring": "Test complete export/import round trip.",
      "category": "test"
    },
    {
      "name": "test_complete_round_trip",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging.py",
      "line": 532,
      "signature": "async test_complete_round_trip(self, db_session: AsyncSession, rules_service: RulesService, packaging_service: RulesetPackagingService, complete_ruleset: dict)",
      "summary": "Test complete export and re-import preserves all data.",
      "layer": "test",
      "parent": "TestPackageRoundTrip",
      "docstring": "Test complete export and re-import preserves all data.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/services/test_baseline_loader.py",
      "line": 33,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for baseline tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for baseline tests.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "function",
      "path": "tests/services/test_baseline_loader.py",
      "line": 54,
      "signature": "db_session() -> AsyncSession",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "disable_recalculation",
      "kind": "function",
      "path": "tests/services/test_baseline_loader.py",
      "line": 59,
      "signature": "disable_recalculation(monkeypatch: pytest.MonkeyPatch) -> None",
      "summary": "Prevent recalculation tasks from firing during tests.",
      "layer": "test",
      "docstring": "Prevent recalculation tasks from firing during tests.",
      "category": "test"
    },
    {
      "name": "test_load_creates_ruleset_and_groups",
      "kind": "async_function",
      "path": "tests/services/test_baseline_loader.py",
      "line": 106,
      "signature": "async test_load_creates_ruleset_and_groups(db_session: AsyncSession) -> None",
      "summary": "Loader should create baseline ruleset, groups, and placeholder rules.",
      "layer": "test",
      "docstring": "Loader should create baseline ruleset, groups, and placeholder rules.",
      "category": "test"
    },
    {
      "name": "test_load_skips_when_hash_matches",
      "kind": "async_function",
      "path": "tests/services/test_baseline_loader.py",
      "line": 139,
      "signature": "async test_load_skips_when_hash_matches(db_session: AsyncSession) -> None",
      "summary": "Loader should skip creating duplicate baseline rulesets for same content.",
      "layer": "test",
      "docstring": "Loader should skip creating duplicate baseline rulesets for same content.",
      "category": "test"
    },
    {
      "name": "test_ensure_basic_adjustments_group",
      "kind": "async_function",
      "path": "tests/services/test_baseline_loader.py",
      "line": 152,
      "signature": "async test_ensure_basic_adjustments_group(db_session: AsyncSession) -> None",
      "summary": "Basic adjustments group should be provisioned on demand.",
      "layer": "test",
      "docstring": "Basic adjustments group should be provisioned on demand.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 30,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests.",
      "category": "test"
    },
    {
      "name": "evaluation_service",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 50,
      "signature": "async evaluation_service()",
      "summary": "Create RuleEvaluationService instance.",
      "layer": "test",
      "docstring": "Create RuleEvaluationService instance.",
      "category": "test"
    },
    {
      "name": "baseline_loader",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 56,
      "signature": "async baseline_loader()",
      "summary": "Create BaselineLoaderService instance.",
      "layer": "test",
      "docstring": "Create BaselineLoaderService instance.",
      "category": "test"
    },
    {
      "name": "sample_cpu",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 62,
      "signature": "async sample_cpu(db_session: AsyncSession) -> Cpu",
      "summary": "Create a sample CPU for testing.",
      "layer": "test",
      "docstring": "Create a sample CPU for testing.",
      "category": "test"
    },
    {
      "name": "sample_gpu",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 81,
      "signature": "async sample_gpu(db_session: AsyncSession) -> Gpu",
      "summary": "Create a sample GPU for testing.",
      "layer": "test",
      "docstring": "Create a sample GPU for testing.",
      "category": "test"
    },
    {
      "name": "sample_listing",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 98,
      "signature": "async sample_listing(db_session: AsyncSession, sample_cpu: Cpu, sample_gpu: Gpu) -> Listing",
      "summary": "Create a sample listing for testing.",
      "layer": "test",
      "docstring": "Create a sample listing for testing.",
      "category": "test"
    },
    {
      "name": "baseline_ruleset",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 127,
      "signature": "async baseline_ruleset(db_session: AsyncSession) -> ValuationRuleset",
      "summary": "Create a baseline ruleset with priority=5.",
      "layer": "test",
      "docstring": "Create a baseline ruleset with priority=5.",
      "category": "test"
    },
    {
      "name": "standard_ruleset",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 149,
      "signature": "async standard_ruleset(db_session: AsyncSession) -> ValuationRuleset",
      "summary": "Create a standard ruleset with priority=10.",
      "layer": "test",
      "docstring": "Create a standard ruleset with priority=10.",
      "category": "test"
    },
    {
      "name": "advanced_ruleset",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 167,
      "signature": "async advanced_ruleset(db_session: AsyncSession) -> ValuationRuleset",
      "summary": "Create an advanced ruleset with priority=20.",
      "layer": "test",
      "docstring": "Create an advanced ruleset with priority=20.",
      "category": "test"
    },
    {
      "name": "create_simple_rule",
      "kind": "async_function",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 184,
      "signature": "async create_simple_rule(db_session: AsyncSession, ruleset_id: int, group_name: str, rule_name: str, adjustment_value: float, condition_field: str, condition_value: int) -> ValuationRuleV2",
      "summary": "Helper to create a simple rule with a single condition and action.",
      "layer": "test",
      "docstring": "Helper to create a simple rule with a single condition and action.",
      "category": "test"
    },
    {
      "name": "TestMultiRulesetEvaluation",
      "kind": "class",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 245,
      "signature": "class TestMultiRulesetEvaluation",
      "summary": "Test multi-ruleset evaluation with proper precedence.",
      "layer": "test",
      "docstring": "Test multi-ruleset evaluation with proper precedence.",
      "category": "test"
    },
    {
      "name": "test_evaluates_multiple_rulesets_in_priority_order",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 249,
      "signature": "async test_evaluates_multiple_rulesets_in_priority_order(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService, sample_listing: Listing, baseline_ruleset: ValuationRuleset, standard_ruleset: ValuationRuleset, advanced_ruleset: ValuationRuleset)",
      "summary": "Test that multiple active rulesets are evaluated in priority order.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that multiple active rulesets are evaluated in priority order.",
      "category": "test"
    },
    {
      "name": "test_single_ruleset_evaluation_when_specified",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 324,
      "signature": "async test_single_ruleset_evaluation_when_specified(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService, sample_listing: Listing, baseline_ruleset: ValuationRuleset, standard_ruleset: ValuationRuleset)",
      "summary": "Test that only specified ruleset is evaluated when ruleset_id is provided.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that only specified ruleset is evaluated when ruleset_id is provided.",
      "category": "test"
    },
    {
      "name": "test_breakdown_stored_with_layer_attribution",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 362,
      "signature": "async test_breakdown_stored_with_layer_attribution(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService, sample_listing: Listing, baseline_ruleset: ValuationRuleset, standard_ruleset: ValuationRuleset)",
      "summary": "Test that valuation breakdown is stored with proper layer attribution.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that valuation breakdown is stored with proper layer attribution.",
      "category": "test"
    },
    {
      "name": "test_inactive_rulesets_are_skipped",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 418,
      "signature": "async test_inactive_rulesets_are_skipped(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService, sample_listing: Listing, baseline_ruleset: ValuationRuleset, standard_ruleset: ValuationRuleset)",
      "summary": "Test that inactive rulesets are not evaluated.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that inactive rulesets are not evaluated.",
      "category": "test"
    },
    {
      "name": "test_excluded_rulesets_are_skipped",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 460,
      "signature": "async test_excluded_rulesets_are_skipped(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService, sample_listing: Listing, baseline_ruleset: ValuationRuleset, standard_ruleset: ValuationRuleset)",
      "summary": "Test that excluded rulesets are not evaluated.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that excluded rulesets are not evaluated.",
      "category": "test"
    },
    {
      "name": "test_conditional_ruleset_matching",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 504,
      "signature": "async test_conditional_ruleset_matching(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService, sample_listing: Listing, baseline_ruleset: ValuationRuleset)",
      "summary": "Test that rulesets with conditions are only evaluated when conditions match.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that rulesets with conditions are only evaluated when conditions match.",
      "category": "test"
    },
    {
      "name": "test_layer_type_detection",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 568,
      "signature": "async test_layer_type_detection(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService)",
      "summary": "Test that layer types are correctly detected based on metadata and priority.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that layer types are correctly detected based on metadata and priority.",
      "category": "test"
    },
    {
      "name": "test_empty_ruleset_handling",
      "kind": "async_method",
      "path": "tests/services/test_multi_ruleset_evaluation.py",
      "line": 609,
      "signature": "async test_empty_ruleset_handling(self, db_session: AsyncSession, evaluation_service: RuleEvaluationService, sample_listing: Listing, baseline_ruleset: ValuationRuleset, standard_ruleset: ValuationRuleset)",
      "summary": "Test that empty rulesets (no rules) are handled gracefully.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that empty rulesets (no rules) are handled gracefully.",
      "category": "test"
    },
    {
      "name": "TestLayerTypeDetection",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 17,
      "signature": "class TestLayerTypeDetection",
      "summary": "Test layer type detection based on ruleset metadata and priority.",
      "layer": "test",
      "docstring": "Test layer type detection based on ruleset metadata and priority.",
      "category": "test"
    },
    {
      "name": "test_detects_baseline_via_metadata",
      "kind": "method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 20,
      "signature": "test_detects_baseline_via_metadata(self)",
      "summary": "Test that system_baseline metadata flag identifies baseline layer.",
      "layer": "test",
      "parent": "TestLayerTypeDetection",
      "docstring": "Test that system_baseline metadata flag identifies baseline layer.",
      "category": "test"
    },
    {
      "name": "test_detects_baseline_via_priority",
      "kind": "method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 32,
      "signature": "test_detects_baseline_via_priority(self)",
      "summary": "Test that priority <= 5 identifies baseline layer.",
      "layer": "test",
      "parent": "TestLayerTypeDetection",
      "docstring": "Test that priority <= 5 identifies baseline layer.",
      "category": "test"
    },
    {
      "name": "test_detects_basic_layer",
      "kind": "method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 44,
      "signature": "test_detects_basic_layer(self)",
      "summary": "Test that priority 6-10 identifies basic layer.",
      "layer": "test",
      "parent": "TestLayerTypeDetection",
      "docstring": "Test that priority 6-10 identifies basic layer.",
      "category": "test"
    },
    {
      "name": "test_detects_advanced_layer",
      "kind": "method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 56,
      "signature": "test_detects_advanced_layer(self)",
      "summary": "Test that priority > 10 identifies advanced layer.",
      "layer": "test",
      "parent": "TestLayerTypeDetection",
      "docstring": "Test that priority > 10 identifies advanced layer.",
      "category": "test"
    },
    {
      "name": "TestMatchedRulesFlattening",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 69,
      "signature": "class TestMatchedRulesFlattening",
      "summary": "Test the flattening of matched rules for backward compatibility.",
      "layer": "test",
      "docstring": "Test the flattening of matched rules for backward compatibility.",
      "category": "test"
    },
    {
      "name": "test_flattens_rules_with_layer_attribution",
      "kind": "method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 72,
      "signature": "test_flattens_rules_with_layer_attribution(self)",
      "summary": "Test that matched rules are properly flattened with layer info.",
      "layer": "test",
      "parent": "TestMatchedRulesFlattening",
      "docstring": "Test that matched rules are properly flattened with layer info.",
      "category": "test"
    },
    {
      "name": "test_handles_empty_layers",
      "kind": "method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 123,
      "signature": "test_handles_empty_layers(self)",
      "summary": "Test that empty layers are handled correctly.",
      "layer": "test",
      "parent": "TestMatchedRulesFlattening",
      "docstring": "Test that empty layers are handled correctly.",
      "category": "test"
    },
    {
      "name": "TestMultiRulesetEvaluation",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 133,
      "signature": "class TestMultiRulesetEvaluation",
      "summary": "Test multi-ruleset evaluation logic with mocked dependencies.",
      "layer": "test",
      "docstring": "Test multi-ruleset evaluation logic with mocked dependencies.",
      "category": "test"
    },
    {
      "name": "test_get_rulesets_for_evaluation_ordering",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 137,
      "signature": "async test_get_rulesets_for_evaluation_ordering(self)",
      "summary": "Test that rulesets are returned in priority order.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that rulesets are returned in priority order.",
      "category": "test"
    },
    {
      "name": "test_excludes_disabled_rulesets",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 182,
      "signature": "async test_excludes_disabled_rulesets(self)",
      "summary": "Test that excluded rulesets are filtered out.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that excluded rulesets are filtered out.",
      "category": "test"
    },
    {
      "name": "test_filters_conditional_rulesets",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 215,
      "signature": "async test_filters_conditional_rulesets(self)",
      "summary": "Test that conditional rulesets are filtered based on context.",
      "layer": "test",
      "parent": "TestMultiRulesetEvaluation",
      "docstring": "Test that conditional rulesets are filtered based on context.",
      "category": "test"
    },
    {
      "name": "TestBackwardCompatibility",
      "kind": "class",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 252,
      "signature": "class TestBackwardCompatibility",
      "summary": "Test that the enhanced evaluation maintains backward compatibility.",
      "layer": "test",
      "docstring": "Test that the enhanced evaluation maintains backward compatibility.",
      "category": "test"
    },
    {
      "name": "test_single_ruleset_mode_compatibility",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 256,
      "signature": "async test_single_ruleset_mode_compatibility(self)",
      "summary": "Test that specifying a ruleset_id evaluates only that ruleset.",
      "layer": "test",
      "parent": "TestBackwardCompatibility",
      "docstring": "Test that specifying a ruleset_id evaluates only that ruleset.",
      "category": "test"
    },
    {
      "name": "test_valuation_breakdown_structure",
      "kind": "async_method",
      "path": "tests/services/test_rule_evaluation_layers.py",
      "line": 315,
      "signature": "async test_valuation_breakdown_structure(self)",
      "summary": "Test that valuation breakdown maintains expected structure.",
      "layer": "test",
      "parent": "TestBackwardCompatibility",
      "docstring": "Test that valuation breakdown maintains expected structure.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 47,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for baseline tests.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for baseline tests.",
      "category": "test"
    },
    {
      "name": "packaging_service",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 67,
      "signature": "async packaging_service()",
      "summary": "Create RulesetPackagingService instance.",
      "layer": "test",
      "docstring": "Create RulesetPackagingService instance.",
      "category": "test"
    },
    {
      "name": "rules_service",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 73,
      "signature": "async rules_service()",
      "summary": "Create RulesService instance.",
      "layer": "test",
      "docstring": "Create RulesService instance.",
      "category": "test"
    },
    {
      "name": "baseline_ruleset",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 79,
      "signature": "async baseline_ruleset(db_session: AsyncSession)",
      "summary": "Create a baseline ruleset for testing.",
      "layer": "test",
      "docstring": "Create a baseline ruleset for testing.",
      "category": "test"
    },
    {
      "name": "customer_ruleset",
      "kind": "async_function",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 120,
      "signature": "async customer_ruleset(db_session: AsyncSession, rules_service: RulesService)",
      "summary": "Create a customer ruleset for testing.",
      "layer": "test",
      "docstring": "Create a customer ruleset for testing.",
      "category": "test"
    },
    {
      "name": "TestBaselineExport",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 150,
      "signature": "class TestBaselineExport",
      "summary": "Test baseline ruleset export functionality.",
      "layer": "test",
      "docstring": "Test baseline ruleset export functionality.",
      "category": "test"
    },
    {
      "name": "test_export_baseline_requires_flag",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 154,
      "signature": "async test_export_baseline_requires_flag(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset)",
      "summary": "Test that baseline rulesets require explicit flag for export.",
      "layer": "test",
      "parent": "TestBaselineExport",
      "docstring": "Test that baseline rulesets require explicit flag for export.",
      "category": "test"
    },
    {
      "name": "test_export_preserves_baseline_metadata",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 187,
      "signature": "async test_export_preserves_baseline_metadata(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset)",
      "summary": "Test that baseline metadata is preserved during export.",
      "layer": "test",
      "parent": "TestBaselineExport",
      "docstring": "Test that baseline metadata is preserved during export.",
      "category": "test"
    },
    {
      "name": "test_export_customer_ruleset_default",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 218,
      "signature": "async test_export_customer_ruleset_default(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, customer_ruleset: dict)",
      "summary": "Test that customer rulesets export normally without baseline flag.",
      "layer": "test",
      "parent": "TestBaselineExport",
      "docstring": "Test that customer rulesets export normally without baseline flag.",
      "category": "test"
    },
    {
      "name": "TestBaselineImport",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 243,
      "signature": "class TestBaselineImport",
      "summary": "Test baseline ruleset import functionality.",
      "layer": "test",
      "docstring": "Test baseline ruleset import functionality.",
      "category": "test"
    },
    {
      "name": "test_import_baseline_creates_version",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 247,
      "signature": "async test_import_baseline_creates_version(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset)",
      "summary": "Test that importing a baseline creates a new version.",
      "layer": "test",
      "parent": "TestBaselineImport",
      "docstring": "Test that importing a baseline creates a new version.",
      "category": "test"
    },
    {
      "name": "test_import_baseline_validates_priority",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 299,
      "signature": "async test_import_baseline_validates_priority(self, db_session: AsyncSession, packaging_service: RulesetPackagingService)",
      "summary": "Test that baseline imports validate priority <= 5.",
      "layer": "test",
      "parent": "TestBaselineImport",
      "docstring": "Test that baseline imports validate priority <= 5.",
      "category": "test"
    },
    {
      "name": "test_import_baseline_preserves_read_only",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 343,
      "signature": "async test_import_baseline_preserves_read_only(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset)",
      "summary": "Test that baseline imports preserve read_only flags.",
      "layer": "test",
      "parent": "TestBaselineImport",
      "docstring": "Test that baseline imports preserve read_only flags.",
      "category": "test"
    },
    {
      "name": "test_import_baseline_replace_mode",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 390,
      "signature": "async test_import_baseline_replace_mode(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset)",
      "summary": "Test baseline import with replace mode.",
      "layer": "test",
      "parent": "TestBaselineImport",
      "docstring": "Test baseline import with replace mode.",
      "category": "test"
    },
    {
      "name": "TestMixedPackageImport",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 432,
      "signature": "class TestMixedPackageImport",
      "summary": "Test importing packages with both baseline and customer rulesets.",
      "layer": "test",
      "docstring": "Test importing packages with both baseline and customer rulesets.",
      "category": "test"
    },
    {
      "name": "test_mixed_package_import",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 436,
      "signature": "async test_mixed_package_import(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset, customer_ruleset: dict)",
      "summary": "Test importing a package with both baseline and customer rulesets.",
      "layer": "test",
      "parent": "TestMixedPackageImport",
      "docstring": "Test importing a package with both baseline and customer rulesets.",
      "category": "test"
    },
    {
      "name": "TestBaselineExportToFile",
      "kind": "class",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 521,
      "signature": "class TestBaselineExportToFile",
      "summary": "Test exporting baseline rulesets to file.",
      "layer": "test",
      "docstring": "Test exporting baseline rulesets to file.",
      "category": "test"
    },
    {
      "name": "test_export_baseline_to_file",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 525,
      "signature": "async test_export_baseline_to_file(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset, tmp_path: Path)",
      "summary": "Test exporting baseline to .dbrs file.",
      "layer": "test",
      "parent": "TestBaselineExportToFile",
      "docstring": "Test exporting baseline to .dbrs file.",
      "category": "test"
    },
    {
      "name": "test_import_baseline_from_file",
      "kind": "async_method",
      "path": "tests/services/test_ruleset_packaging_baseline.py",
      "line": 561,
      "signature": "async test_import_baseline_from_file(self, db_session: AsyncSession, packaging_service: RulesetPackagingService, baseline_ruleset: ValuationRuleset, tmp_path: Path)",
      "summary": "Test importing baseline from .dbrs file.",
      "layer": "test",
      "parent": "TestBaselineExportToFile",
      "docstring": "Test importing baseline from .dbrs file.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 143,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session.",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 164,
      "signature": "db_session() -> AsyncSession",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "disable_recalculation",
      "kind": "function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 169,
      "signature": "disable_recalculation(monkeypatch: pytest.MonkeyPatch) -> None",
      "summary": "Prevent recalculation tasks from firing during tests.",
      "layer": "test",
      "docstring": "Prevent recalculation tasks from firing during tests.",
      "category": "test"
    },
    {
      "name": "hydration_service",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 187,
      "signature": "async hydration_service()",
      "summary": "Create BaselineHydrationService instance.",
      "layer": "test",
      "docstring": "Create BaselineHydrationService instance.",
      "category": "test"
    },
    {
      "name": "sample_ruleset",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 192,
      "signature": "async sample_ruleset(db_session: AsyncSession) -> ValuationRuleset",
      "summary": "Create a sample ruleset.",
      "layer": "test",
      "docstring": "Create a sample ruleset.",
      "category": "test"
    },
    {
      "name": "sample_rule_group",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 207,
      "signature": "async sample_rule_group(db_session: AsyncSession, sample_ruleset: ValuationRuleset) -> ValuationRuleGroup",
      "summary": "Create a sample rule group.",
      "layer": "test",
      "docstring": "Create a sample rule group.",
      "category": "test"
    },
    {
      "name": "hydration_service",
      "kind": "function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 227,
      "signature": "hydration_service()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "sample_ruleset",
      "kind": "function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 231,
      "signature": "sample_ruleset()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "sample_rule_group",
      "kind": "function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 235,
      "signature": "sample_rule_group()",
      "summary": "",
      "layer": "test",
      "category": "test"
    },
    {
      "name": "test_hydrate_enum_multiplier_field",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 242,
      "signature": "async test_hydrate_enum_multiplier_field(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test hydration of enum_multiplier field (DDR Generation example).",
      "layer": "test",
      "docstring": "Test hydration of enum_multiplier field (DDR Generation example).",
      "category": "test"
    },
    {
      "name": "test_hydrate_formula_field",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 315,
      "signature": "async test_hydrate_formula_field(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test hydration of formula field (RAM Capacity formula example).",
      "layer": "test",
      "docstring": "Test hydration of formula field (RAM Capacity formula example).",
      "category": "test"
    },
    {
      "name": "test_hydrate_fixed_field",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 376,
      "signature": "async test_hydrate_fixed_field(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test hydration of fixed field (Base depreciation example).",
      "layer": "test",
      "docstring": "Test hydration of fixed field (Base depreciation example).",
      "category": "test"
    },
    {
      "name": "test_hydrate_ruleset_all_types",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 435,
      "signature": "async test_hydrate_ruleset_all_types(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_ruleset: ValuationRuleset, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test hydrating a ruleset with mixed field types.",
      "layer": "test",
      "docstring": "Test hydrating a ruleset with mixed field types.",
      "category": "test"
    },
    {
      "name": "test_skip_already_hydrated",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 524,
      "signature": "async test_skip_already_hydrated(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_ruleset: ValuationRuleset, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test idempotency - skips already hydrated rules.",
      "layer": "test",
      "docstring": "Test idempotency - skips already hydrated rules.",
      "category": "test"
    },
    {
      "name": "test_deactivate_original_rules",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 567,
      "signature": "async test_deactivate_original_rules(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that original placeholder rules are properly deactivated.",
      "layer": "test",
      "docstring": "Test that original placeholder rules are properly deactivated.",
      "category": "test"
    },
    {
      "name": "test_foreign_key_rule_metadata",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 621,
      "signature": "async test_foreign_key_rule_metadata(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test that expanded rules are properly linked to source via metadata.",
      "layer": "test",
      "docstring": "Test that expanded rules are properly linked to source via metadata.",
      "category": "test"
    },
    {
      "name": "test_hydration_summary",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 654,
      "signature": "async test_hydration_summary(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_ruleset: ValuationRuleset, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test that hydration summary contains correct information.",
      "layer": "test",
      "docstring": "Test that hydration summary contains correct information.",
      "category": "test"
    },
    {
      "name": "test_formula_without_formula_text_fallback",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 702,
      "signature": "async test_formula_without_formula_text_fallback(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that formula type without formula_text falls back to fixed strategy.",
      "layer": "test",
      "docstring": "Test that formula type without formula_text falls back to fixed strategy.",
      "category": "test"
    },
    {
      "name": "test_error_on_non_existent_rule",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 747,
      "signature": "async test_error_on_non_existent_rule(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that hydrating non-existent rule raises ValueError.",
      "layer": "test",
      "docstring": "Test that hydrating non-existent rule raises ValueError.",
      "category": "test"
    },
    {
      "name": "test_error_on_non_placeholder_rule",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 755,
      "signature": "async test_error_on_non_placeholder_rule(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test that hydrating non-placeholder rule raises ValueError.",
      "layer": "test",
      "docstring": "Test that hydrating non-placeholder rule raises ValueError.",
      "category": "test"
    },
    {
      "name": "test_empty_valuation_buckets",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 777,
      "signature": "async test_empty_valuation_buckets(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test enum multiplier with empty buckets returns empty list.",
      "layer": "test",
      "docstring": "Test enum multiplier with empty buckets returns empty list.",
      "category": "test"
    },
    {
      "name": "test_fixed_field_default_value_zero",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 807,
      "signature": "async test_fixed_field_default_value_zero(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test fixed field without default_value uses 0.0.",
      "layer": "test",
      "docstring": "Test fixed field without default_value uses 0.0.",
      "category": "test"
    },
    {
      "name": "test_comprehensive_all_strategies_non_null_values",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 851,
      "signature": "async test_comprehensive_all_strategies_non_null_values(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Comprehensive test verifying all hydration strategies produce non-null values.",
      "layer": "test",
      "docstring": "Comprehensive test verifying all hydration strategies produce non-null values.",
      "category": "test"
    },
    {
      "name": "test_fixed_value_multiple_key_variants",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 973,
      "signature": "async test_fixed_value_multiple_key_variants(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that fixed value strategy checks multiple key variants.",
      "layer": "test",
      "docstring": "Test that fixed value strategy checks multiple key variants.",
      "category": "test"
    },
    {
      "name": "test_enum_multiplier_with_null_values",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 1044,
      "signature": "async test_enum_multiplier_with_null_values(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that enum_multiplier handles null multiplier values gracefully.",
      "layer": "test",
      "docstring": "Test that enum_multiplier handles null multiplier values gracefully.",
      "category": "test"
    },
    {
      "name": "test_metadata_preservation_all_strategies",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 1095,
      "signature": "async test_metadata_preservation_all_strategies(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that all strategies properly preserve metadata in hydrated rules.",
      "layer": "test",
      "docstring": "Test that all strategies properly preserve metadata in hydrated rules.",
      "category": "test"
    },
    {
      "name": "test_scalar_field_type_skipped",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 1179,
      "signature": "async test_scalar_field_type_skipped(db_session: AsyncSession, hydration_service: BaselineHydrationService, sample_rule_group: ValuationRuleGroup)",
      "summary": "Test that scalar field types are skipped during hydration (Issue #1).",
      "layer": "test",
      "docstring": "Test that scalar field types are skipped during hydration (Issue #1).",
      "category": "test"
    },
    {
      "name": "test_foreign_key_rule_tagging",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 1212,
      "signature": "async test_foreign_key_rule_tagging(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that FK-related rules are tagged with is_foreign_key_rule metadata (Issue #2).",
      "layer": "test",
      "docstring": "Test that FK-related rules are tagged with is_foreign_key_rule metadata (Issue #2).",
      "category": "test"
    },
    {
      "name": "test_foreign_key_tagging_all_strategies",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 1293,
      "signature": "async test_foreign_key_tagging_all_strategies(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that is_foreign_key_rule is set correctly for all hydration strategies.",
      "layer": "test",
      "docstring": "Test that is_foreign_key_rule is set correctly for all hydration strategies.",
      "category": "test"
    },
    {
      "name": "test_pseudo_code_formula_handling",
      "kind": "async_function",
      "path": "tests/services/test_baseline_hydration.py",
      "line": 1377,
      "signature": "async test_pseudo_code_formula_handling(db_session: AsyncSession, hydration_service: BaselineHydrationService)",
      "summary": "Test that pseudo-code formulas are handled gracefully with metadata preservation.",
      "layer": "test",
      "docstring": "Test that pseudo-code formulas are handled gracefully with metadata preservation.",
      "category": "test"
    },
    {
      "name": "db_session",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 26,
      "signature": "async db_session() -> AsyncSession",
      "summary": "Provide an isolated in-memory database session for tests",
      "layer": "test",
      "docstring": "Provide an isolated in-memory database session for tests",
      "category": "test"
    },
    {
      "name": "validation_service",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 46,
      "signature": "async validation_service()",
      "summary": "Create FormulaValidationService instance",
      "layer": "test",
      "docstring": "Create FormulaValidationService instance",
      "category": "test"
    },
    {
      "name": "sample_cpu",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 52,
      "signature": "async sample_cpu(db_session: AsyncSession) -> Cpu",
      "summary": "Create a sample CPU for testing",
      "layer": "test",
      "docstring": "Create a sample CPU for testing",
      "category": "test"
    },
    {
      "name": "sample_gpu",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 72,
      "signature": "async sample_gpu(db_session: AsyncSession) -> Gpu",
      "summary": "Create a sample GPU for testing",
      "layer": "test",
      "docstring": "Create a sample GPU for testing",
      "category": "test"
    },
    {
      "name": "sample_listing",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 86,
      "signature": "async sample_listing(db_session: AsyncSession, sample_cpu: Cpu, sample_gpu: Gpu) -> Listing",
      "summary": "Create a sample listing for testing",
      "layer": "test",
      "docstring": "Create a sample listing for testing",
      "category": "test"
    },
    {
      "name": "custom_field",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 115,
      "signature": "async custom_field(db_session: AsyncSession) -> CustomFieldDefinition",
      "summary": "Create a custom field for testing",
      "layer": "test",
      "docstring": "Create a custom field for testing",
      "category": "test"
    },
    {
      "name": "test_validate_simple_formula",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 135,
      "signature": "async test_validate_simple_formula(validation_service: FormulaValidationService, db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test validation of simple formula",
      "layer": "test",
      "docstring": "Test validation of simple formula",
      "category": "test"
    },
    {
      "name": "test_validate_complex_formula",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 155,
      "signature": "async test_validate_complex_formula(validation_service: FormulaValidationService, db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test validation of complex formula with multiple operations",
      "layer": "test",
      "docstring": "Test validation of complex formula with multiple operations",
      "category": "test"
    },
    {
      "name": "test_validate_formula_with_functions",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 177,
      "signature": "async test_validate_formula_with_functions(validation_service: FormulaValidationService, db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test validation of formula with allowed functions",
      "layer": "test",
      "docstring": "Test validation of formula with allowed functions",
      "category": "test"
    },
    {
      "name": "test_validate_formula_with_conditional",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 196,
      "signature": "async test_validate_formula_with_conditional(validation_service: FormulaValidationService, db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test validation of formula with ternary conditional",
      "layer": "test",
      "docstring": "Test validation of formula with ternary conditional",
      "category": "test"
    },
    {
      "name": "test_validate_empty_formula",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 217,
      "signature": "async test_validate_empty_formula(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test validation of empty formula",
      "layer": "test",
      "docstring": "Test validation of empty formula",
      "category": "test"
    },
    {
      "name": "test_validate_formula_syntax_error",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 235,
      "signature": "async test_validate_formula_syntax_error(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test validation of formula with syntax error",
      "layer": "test",
      "docstring": "Test validation of formula with syntax error",
      "category": "test"
    },
    {
      "name": "test_validate_formula_unmatched_parentheses",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 253,
      "signature": "async test_validate_formula_unmatched_parentheses(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test validation of formula with unmatched parentheses",
      "layer": "test",
      "docstring": "Test validation of formula with unmatched parentheses",
      "category": "test"
    },
    {
      "name": "test_validate_formula_undefined_field",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 271,
      "signature": "async test_validate_formula_undefined_field(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test validation of formula with undefined field",
      "layer": "test",
      "docstring": "Test validation of formula with undefined field",
      "category": "test"
    },
    {
      "name": "test_validate_formula_disallowed_function",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 288,
      "signature": "async test_validate_formula_disallowed_function(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test validation of formula with disallowed function",
      "layer": "test",
      "docstring": "Test validation of formula with disallowed function",
      "category": "test"
    },
    {
      "name": "test_get_available_fields_listing",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 307,
      "signature": "async test_get_available_fields_listing(validation_service: FormulaValidationService, db_session: AsyncSession, custom_field: CustomFieldDefinition)",
      "summary": "Test getting available fields for Listing entity",
      "layer": "test",
      "docstring": "Test getting available fields for Listing entity",
      "category": "test"
    },
    {
      "name": "test_get_available_fields_cpu",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 333,
      "signature": "async test_get_available_fields_cpu(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test getting available fields for CPU entity",
      "layer": "test",
      "docstring": "Test getting available fields for CPU entity",
      "category": "test"
    },
    {
      "name": "test_get_available_fields_gpu",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 351,
      "signature": "async test_get_available_fields_gpu(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test getting available fields for GPU entity",
      "layer": "test",
      "docstring": "Test getting available fields for GPU entity",
      "category": "test"
    },
    {
      "name": "test_get_sample_context_from_database",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 369,
      "signature": "async test_get_sample_context_from_database(validation_service: FormulaValidationService, db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test getting sample context from database",
      "layer": "test",
      "docstring": "Test getting sample context from database",
      "category": "test"
    },
    {
      "name": "test_get_sample_context_with_provided_values",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 387,
      "signature": "async test_get_sample_context_with_provided_values(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test getting sample context with user-provided values",
      "layer": "test",
      "docstring": "Test getting sample context with user-provided values",
      "category": "test"
    },
    {
      "name": "test_get_sample_context_default_values",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 409,
      "signature": "async test_get_sample_context_default_values(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test getting sample context with default values when no data exists",
      "layer": "test",
      "docstring": "Test getting sample context with default values when no data exists",
      "category": "test"
    },
    {
      "name": "test_preview_with_custom_context",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 428,
      "signature": "async test_preview_with_custom_context(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test preview calculation with custom context",
      "layer": "test",
      "docstring": "Test preview calculation with custom context",
      "category": "test"
    },
    {
      "name": "test_preview_with_nested_fields",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 452,
      "signature": "async test_preview_with_nested_fields(validation_service: FormulaValidationService, db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test preview calculation with nested CPU fields",
      "layer": "test",
      "docstring": "Test preview calculation with nested CPU fields",
      "category": "test"
    },
    {
      "name": "test_validation_warnings_division",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 473,
      "signature": "async test_validation_warnings_division(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test that division operations produce warnings",
      "layer": "test",
      "docstring": "Test that division operations produce warnings",
      "category": "test"
    },
    {
      "name": "test_validation_warnings_deep_nesting",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 492,
      "signature": "async test_validation_warnings_deep_nesting(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test that deeply nested formulas produce warnings",
      "layer": "test",
      "docstring": "Test that deeply nested formulas produce warnings",
      "category": "test"
    },
    {
      "name": "test_validation_performance",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 512,
      "signature": "async test_validation_performance(validation_service: FormulaValidationService, db_session: AsyncSession, sample_listing: Listing)",
      "summary": "Test that validation completes within performance target (<200ms)",
      "layer": "test",
      "docstring": "Test that validation completes within performance target (<200ms)",
      "category": "test"
    },
    {
      "name": "test_security_injection_attempt",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 535,
      "signature": "async test_security_injection_attempt(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test that injection attempts are blocked",
      "layer": "test",
      "docstring": "Test that injection attempts are blocked",
      "category": "test"
    },
    {
      "name": "test_validate_formula_with_zero_division_risk",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 562,
      "signature": "async test_validate_formula_with_zero_division_risk(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test formula with potential zero division",
      "layer": "test",
      "docstring": "Test formula with potential zero division",
      "category": "test"
    },
    {
      "name": "test_validate_formula_case_insensitive_entity",
      "kind": "async_function",
      "path": "tests/services/test_formula_validation.py",
      "line": 580,
      "signature": "async test_validate_formula_case_insensitive_entity(validation_service: FormulaValidationService, db_session: AsyncSession)",
      "summary": "Test that entity type is case-insensitive",
      "layer": "test",
      "docstring": "Test that entity type is case-insensitive",
      "category": "test"
    },
    {
      "name": "sample_ruleset_data",
      "kind": "async_function",
      "path": "tests/api/test_rules_api.py",
      "line": 15,
      "signature": "async sample_ruleset_data()",
      "summary": "Sample ruleset data for testing.",
      "layer": "test",
      "docstring": "Sample ruleset data for testing.",
      "category": "test"
    },
    {
      "name": "sample_rule_group_data",
      "kind": "async_function",
      "path": "tests/api/test_rules_api.py",
      "line": 27,
      "signature": "async sample_rule_group_data()",
      "summary": "Sample rule group data for testing.",
      "layer": "test",
      "docstring": "Sample rule group data for testing.",
      "category": "test"
    },
    {
      "name": "sample_rule_data",
      "kind": "async_function",
      "path": "tests/api/test_rules_api.py",
      "line": 39,
      "signature": "async sample_rule_data()",
      "summary": "Sample rule data for testing.",
      "layer": "test",
      "docstring": "Sample rule data for testing.",
      "category": "test"
    },
    {
      "name": "TestRulesetEndpoints",
      "kind": "class",
      "path": "tests/api/test_rules_api.py",
      "line": 63,
      "signature": "class TestRulesetEndpoints",
      "summary": "Test ruleset CRUD endpoints.",
      "layer": "test",
      "docstring": "Test ruleset CRUD endpoints.",
      "category": "test"
    },
    {
      "name": "test_create_ruleset",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 67,
      "signature": "async test_create_ruleset(self, client: AsyncClient, sample_ruleset_data: dict)",
      "summary": "Test POST /api/v1/rulesets - Create ruleset.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test POST /api/v1/rulesets - Create ruleset.",
      "category": "test"
    },
    {
      "name": "test_create_ruleset_invalid_data",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 79,
      "signature": "async test_create_ruleset_invalid_data(self, client: AsyncClient)",
      "summary": "Test POST /api/v1/rulesets - Invalid data returns 422.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test POST /api/v1/rulesets - Invalid data returns 422.",
      "category": "test"
    },
    {
      "name": "test_list_rulesets",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 88,
      "signature": "async test_list_rulesets(self, client: AsyncClient, sample_ruleset_data: dict)",
      "summary": "Test GET /api/v1/rulesets - List all rulesets.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test GET /api/v1/rulesets - List all rulesets.",
      "category": "test"
    },
    {
      "name": "test_list_rulesets_active_only",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 101,
      "signature": "async test_list_rulesets_active_only(self, client: AsyncClient, sample_ruleset_data: dict)",
      "summary": "Test GET /api/v1/rulesets?active_only=true - Filter active rulesets.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test GET /api/v1/rulesets?active_only=true - Filter active rulesets.",
      "category": "test"
    },
    {
      "name": "test_get_ruleset",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 121,
      "signature": "async test_get_ruleset(self, client: AsyncClient, sample_ruleset_data: dict)",
      "summary": "Test GET /api/v1/rulesets/{id} - Get single ruleset.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test GET /api/v1/rulesets/{id} - Get single ruleset.",
      "category": "test"
    },
    {
      "name": "test_get_ruleset_not_found",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 136,
      "signature": "async test_get_ruleset_not_found(self, client: AsyncClient)",
      "summary": "Test GET /api/v1/rulesets/{id} - Non-existent ID returns 404.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test GET /api/v1/rulesets/{id} - Non-existent ID returns 404.",
      "category": "test"
    },
    {
      "name": "test_update_ruleset",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 143,
      "signature": "async test_update_ruleset(self, client: AsyncClient, sample_ruleset_data: dict)",
      "summary": "Test PUT /api/v1/rulesets/{id} - Update ruleset.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test PUT /api/v1/rulesets/{id} - Update ruleset.",
      "category": "test"
    },
    {
      "name": "test_delete_ruleset",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 164,
      "signature": "async test_delete_ruleset(self, client: AsyncClient, sample_ruleset_data: dict)",
      "summary": "Test DELETE /api/v1/rulesets/{id} - Delete ruleset.",
      "layer": "test",
      "parent": "TestRulesetEndpoints",
      "docstring": "Test DELETE /api/v1/rulesets/{id} - Delete ruleset.",
      "category": "test"
    },
    {
      "name": "TestRuleGroupEndpoints",
      "kind": "class",
      "path": "tests/api/test_rules_api.py",
      "line": 180,
      "signature": "class TestRuleGroupEndpoints",
      "summary": "Test rule group endpoints.",
      "layer": "test",
      "docstring": "Test rule group endpoints.",
      "category": "test"
    },
    {
      "name": "test_create_rule_group",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 184,
      "signature": "async test_create_rule_group(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict)",
      "summary": "Test POST /api/v1/rulesets/{id}/groups - Create rule group.",
      "layer": "test",
      "parent": "TestRuleGroupEndpoints",
      "docstring": "Test POST /api/v1/rulesets/{id}/groups - Create rule group.",
      "category": "test"
    },
    {
      "name": "test_list_rule_groups",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 207,
      "signature": "async test_list_rule_groups(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict)",
      "summary": "Test GET /api/v1/rulesets/{id}/groups - List rule groups.",
      "layer": "test",
      "parent": "TestRuleGroupEndpoints",
      "docstring": "Test GET /api/v1/rulesets/{id}/groups - List rule groups.",
      "category": "test"
    },
    {
      "name": "test_delete_rule_group",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 231,
      "signature": "async test_delete_rule_group(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict)",
      "summary": "Test DELETE /api/v1/rule-groups/{id} - Delete rule group.",
      "layer": "test",
      "parent": "TestRuleGroupEndpoints",
      "docstring": "Test DELETE /api/v1/rule-groups/{id} - Delete rule group.",
      "category": "test"
    },
    {
      "name": "TestRuleEndpoints",
      "kind": "class",
      "path": "tests/api/test_rules_api.py",
      "line": 253,
      "signature": "class TestRuleEndpoints",
      "summary": "Test rule endpoints.",
      "layer": "test",
      "docstring": "Test rule endpoints.",
      "category": "test"
    },
    {
      "name": "test_create_rule",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 257,
      "signature": "async test_create_rule(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict, sample_rule_data: dict)",
      "summary": "Test POST /api/v1/rule-groups/{id}/rules - Create rule.",
      "layer": "test",
      "parent": "TestRuleEndpoints",
      "docstring": "Test POST /api/v1/rule-groups/{id}/rules - Create rule.",
      "category": "test"
    },
    {
      "name": "test_list_rules",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 288,
      "signature": "async test_list_rules(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict, sample_rule_data: dict)",
      "summary": "Test GET /api/v1/rule-groups/{id}/rules - List rules.",
      "layer": "test",
      "parent": "TestRuleEndpoints",
      "docstring": "Test GET /api/v1/rule-groups/{id}/rules - List rules.",
      "category": "test"
    },
    {
      "name": "test_update_rule",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 316,
      "signature": "async test_update_rule(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict, sample_rule_data: dict)",
      "summary": "Test PUT /api/v1/rules/{id} - Update rule.",
      "layer": "test",
      "parent": "TestRuleEndpoints",
      "docstring": "Test PUT /api/v1/rules/{id} - Update rule.",
      "category": "test"
    },
    {
      "name": "test_delete_rule",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 354,
      "signature": "async test_delete_rule(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict, sample_rule_data: dict)",
      "summary": "Test DELETE /api/v1/rules/{id} - Delete rule.",
      "layer": "test",
      "parent": "TestRuleEndpoints",
      "docstring": "Test DELETE /api/v1/rules/{id} - Delete rule.",
      "category": "test"
    },
    {
      "name": "TestPreviewEndpoint",
      "kind": "class",
      "path": "tests/api/test_rules_api.py",
      "line": 382,
      "signature": "class TestPreviewEndpoint",
      "summary": "Test rule preview endpoint.",
      "layer": "test",
      "docstring": "Test rule preview endpoint.",
      "category": "test"
    },
    {
      "name": "test_preview_rule_impact",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 386,
      "signature": "async test_preview_rule_impact(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict, sample_rule_data: dict)",
      "summary": "Test POST /api/v1/rules/{id}/preview - Preview rule impact.",
      "layer": "test",
      "parent": "TestPreviewEndpoint",
      "docstring": "Test POST /api/v1/rules/{id}/preview - Preview rule impact.",
      "category": "test"
    },
    {
      "name": "TestApplyEndpoint",
      "kind": "class",
      "path": "tests/api/test_rules_api.py",
      "line": 418,
      "signature": "class TestApplyEndpoint",
      "summary": "Test ruleset apply endpoint.",
      "layer": "test",
      "docstring": "Test ruleset apply endpoint.",
      "category": "test"
    },
    {
      "name": "test_apply_ruleset",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 422,
      "signature": "async test_apply_ruleset(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict, sample_rule_data: dict)",
      "summary": "Test POST /api/v1/rulesets/{id}/apply - Apply ruleset to listings.",
      "layer": "test",
      "parent": "TestApplyEndpoint",
      "docstring": "Test POST /api/v1/rulesets/{id}/apply - Apply ruleset to listings.",
      "category": "test"
    },
    {
      "name": "TestPackageEndpoints",
      "kind": "class",
      "path": "tests/api/test_rules_api.py",
      "line": 450,
      "signature": "class TestPackageEndpoints",
      "summary": "Test package export/import endpoints.",
      "layer": "test",
      "docstring": "Test package export/import endpoints.",
      "category": "test"
    },
    {
      "name": "test_export_package",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 454,
      "signature": "async test_export_package(self, client: AsyncClient, sample_ruleset_data: dict, sample_rule_group_data: dict, sample_rule_data: dict)",
      "summary": "Test POST /api/v1/rulesets/{id}/export - Export package.",
      "layer": "test",
      "parent": "TestPackageEndpoints",
      "docstring": "Test POST /api/v1/rulesets/{id}/export - Export package.",
      "category": "test"
    },
    {
      "name": "test_install_package",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 495,
      "signature": "async test_install_package(self, client: AsyncClient)",
      "summary": "Test POST /api/v1/packages/install - Install package.",
      "layer": "test",
      "parent": "TestPackageEndpoints",
      "docstring": "Test POST /api/v1/packages/install - Install package.",
      "category": "test"
    },
    {
      "name": "TestErrorHandling",
      "kind": "class",
      "path": "tests/api/test_rules_api.py",
      "line": 529,
      "signature": "class TestErrorHandling",
      "summary": "Test API error handling.",
      "layer": "test",
      "docstring": "Test API error handling.",
      "category": "test"
    },
    {
      "name": "test_invalid_json",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 533,
      "signature": "async test_invalid_json(self, client: AsyncClient)",
      "summary": "Test that invalid JSON returns 400.",
      "layer": "test",
      "parent": "TestErrorHandling",
      "docstring": "Test that invalid JSON returns 400.",
      "category": "test"
    },
    {
      "name": "test_missing_required_field",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 544,
      "signature": "async test_missing_required_field(self, client: AsyncClient)",
      "summary": "Test that missing required fields returns 422.",
      "layer": "test",
      "parent": "TestErrorHandling",
      "docstring": "Test that missing required fields returns 422.",
      "category": "test"
    },
    {
      "name": "test_invalid_id_type",
      "kind": "async_method",
      "path": "tests/api/test_rules_api.py",
      "line": 555,
      "signature": "async test_invalid_id_type(self, client: AsyncClient)",
      "summary": "Test that invalid ID type returns 422.",
      "layer": "test",
      "parent": "TestErrorHandling",
      "docstring": "Test that invalid ID type returns 422.",
      "category": "test"
    },
    {
      "name": "sample_cpu",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 16,
      "signature": "async sample_cpu(db_session: AsyncSession) -> Cpu",
      "summary": "Create a sample CPU for testing",
      "layer": "test",
      "docstring": "Create a sample CPU for testing",
      "category": "test"
    },
    {
      "name": "sample_listing",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 37,
      "signature": "async sample_listing(db_session: AsyncSession, sample_cpu: Cpu) -> Listing",
      "summary": "Create a sample listing for testing",
      "layer": "test",
      "docstring": "Create a sample listing for testing",
      "category": "test"
    },
    {
      "name": "custom_field",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 61,
      "signature": "async custom_field(db_session: AsyncSession) -> CustomFieldDefinition",
      "summary": "Create a custom field for testing",
      "layer": "test",
      "docstring": "Create a custom field for testing",
      "category": "test"
    },
    {
      "name": "test_api_validate_simple_formula",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 79,
      "signature": "async test_api_validate_simple_formula(async_client: AsyncClient, sample_listing: Listing)",
      "summary": "Test API validation of simple formula",
      "layer": "test",
      "docstring": "Test API validation of simple formula",
      "category": "test"
    },
    {
      "name": "test_api_validate_complex_formula",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 104,
      "signature": "async test_api_validate_complex_formula(async_client: AsyncClient, sample_listing: Listing)",
      "summary": "Test API validation of complex formula",
      "layer": "test",
      "docstring": "Test API validation of complex formula",
      "category": "test"
    },
    {
      "name": "test_api_validate_formula_with_functions",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 128,
      "signature": "async test_api_validate_formula_with_functions(async_client: AsyncClient, sample_listing: Listing)",
      "summary": "Test API validation with allowed functions",
      "layer": "test",
      "docstring": "Test API validation with allowed functions",
      "category": "test"
    },
    {
      "name": "test_api_validate_formula_with_conditional",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 149,
      "signature": "async test_api_validate_formula_with_conditional(async_client: AsyncClient, sample_listing: Listing)",
      "summary": "Test API validation with ternary conditional",
      "layer": "test",
      "docstring": "Test API validation with ternary conditional",
      "category": "test"
    },
    {
      "name": "test_api_validate_formula_with_custom_context",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 170,
      "signature": "async test_api_validate_formula_with_custom_context(async_client: AsyncClient)",
      "summary": "Test API validation with custom context",
      "layer": "test",
      "docstring": "Test API validation with custom context",
      "category": "test"
    },
    {
      "name": "test_api_validate_empty_formula",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 198,
      "signature": "async test_api_validate_empty_formula(async_client: AsyncClient)",
      "summary": "Test API validation of empty formula",
      "layer": "test",
      "docstring": "Test API validation of empty formula",
      "category": "test"
    },
    {
      "name": "test_api_validate_syntax_error",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 213,
      "signature": "async test_api_validate_syntax_error(async_client: AsyncClient)",
      "summary": "Test API validation with syntax error",
      "layer": "test",
      "docstring": "Test API validation with syntax error",
      "category": "test"
    },
    {
      "name": "test_api_validate_unmatched_parentheses",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 233,
      "signature": "async test_api_validate_unmatched_parentheses(async_client: AsyncClient)",
      "summary": "Test API validation with unmatched parentheses",
      "layer": "test",
      "docstring": "Test API validation with unmatched parentheses",
      "category": "test"
    },
    {
      "name": "test_api_validate_undefined_field",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 252,
      "signature": "async test_api_validate_undefined_field(async_client: AsyncClient)",
      "summary": "Test API validation with undefined field",
      "layer": "test",
      "docstring": "Test API validation with undefined field",
      "category": "test"
    },
    {
      "name": "test_api_validate_disallowed_function",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 271,
      "signature": "async test_api_validate_disallowed_function(async_client: AsyncClient)",
      "summary": "Test API validation with disallowed function",
      "layer": "test",
      "docstring": "Test API validation with disallowed function",
      "category": "test"
    },
    {
      "name": "test_api_validate_cpu_formula",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 291,
      "signature": "async test_api_validate_cpu_formula(async_client: AsyncClient, sample_cpu: Cpu)",
      "summary": "Test API validation for CPU entity type",
      "layer": "test",
      "docstring": "Test API validation for CPU entity type",
      "category": "test"
    },
    {
      "name": "test_api_validate_gpu_formula",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 311,
      "signature": "async test_api_validate_gpu_formula(async_client: AsyncClient)",
      "summary": "Test API validation for GPU entity type",
      "layer": "test",
      "docstring": "Test API validation for GPU entity type",
      "category": "test"
    },
    {
      "name": "test_api_validate_with_custom_field",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 332,
      "signature": "async test_api_validate_with_custom_field(async_client: AsyncClient, custom_field: CustomFieldDefinition)",
      "summary": "Test API validation with custom field",
      "layer": "test",
      "docstring": "Test API validation with custom field",
      "category": "test"
    },
    {
      "name": "test_api_validation_warnings",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 356,
      "signature": "async test_api_validation_warnings(async_client: AsyncClient)",
      "summary": "Test that warnings are returned for risky operations",
      "layer": "test",
      "docstring": "Test that warnings are returned for risky operations",
      "category": "test"
    },
    {
      "name": "test_api_security_injection_attempts",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 379,
      "signature": "async test_api_security_injection_attempts(async_client: AsyncClient)",
      "summary": "Test that security injection attempts are blocked",
      "layer": "test",
      "docstring": "Test that security injection attempts are blocked",
      "category": "test"
    },
    {
      "name": "test_api_missing_required_fields",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 405,
      "signature": "async test_api_missing_required_fields(async_client: AsyncClient)",
      "summary": "Test API validation with missing required fields",
      "layer": "test",
      "docstring": "Test API validation with missing required fields",
      "category": "test"
    },
    {
      "name": "test_api_default_entity_type",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 419,
      "signature": "async test_api_default_entity_type(async_client: AsyncClient, sample_listing: Listing)",
      "summary": "Test that entity_type defaults to Listing",
      "layer": "test",
      "docstring": "Test that entity_type defaults to Listing",
      "category": "test"
    },
    {
      "name": "test_api_response_structure",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 439,
      "signature": "async test_api_response_structure(async_client: AsyncClient, sample_listing: Listing)",
      "summary": "Test that API response has correct structure",
      "layer": "test",
      "docstring": "Test that API response has correct structure",
      "category": "test"
    },
    {
      "name": "test_api_error_structure",
      "kind": "async_function",
      "path": "tests/api/test_formula_validation_endpoint.py",
      "line": 467,
      "signature": "async test_api_error_structure(async_client: AsyncClient)",
      "summary": "Test that error objects have correct structure",
      "layer": "test",
      "docstring": "Test that error objects have correct structure",
      "category": "test"
    },
    {
      "name": "test_enqueue_listing_recalculation_accepts_reason",
      "kind": "function",
      "path": "tests/tasks/test_enqueue_recalculation.py",
      "line": 38,
      "signature": "test_enqueue_listing_recalculation_accepts_reason(monkeypatch)",
      "summary": "Ensure enqueue supports optional reason argument without Celery errors.",
      "layer": "test",
      "docstring": "Ensure enqueue supports optional reason argument without Celery errors.",
      "category": "test"
    },
    {
      "name": "reference_path",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 10,
      "signature": "reference_path()",
      "summary": "Path to the formula reference JSON file.",
      "layer": "test",
      "docstring": "Path to the formula reference JSON file.",
      "category": "test"
    },
    {
      "name": "reference_data",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 16,
      "signature": "reference_data(reference_path)",
      "summary": "Load the formula reference JSON.",
      "layer": "test",
      "docstring": "Load the formula reference JSON.",
      "category": "test"
    },
    {
      "name": "test_reference_file_exists",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 25,
      "signature": "test_reference_file_exists(reference_path)",
      "summary": "Test that the reference file exists.",
      "layer": "test",
      "docstring": "Test that the reference file exists.",
      "category": "test"
    },
    {
      "name": "test_reference_has_required_top_level_keys",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 30,
      "signature": "test_reference_has_required_top_level_keys(reference_data)",
      "summary": "Test that reference has all required top-level keys.",
      "layer": "test",
      "docstring": "Test that reference has all required top-level keys.",
      "category": "test"
    },
    {
      "name": "test_entities_structure",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 50,
      "signature": "test_entities_structure(reference_data)",
      "summary": "Test entities section has correct structure.",
      "layer": "test",
      "docstring": "Test entities section has correct structure.",
      "category": "test"
    },
    {
      "name": "test_custom_fields_structure",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 75,
      "signature": "test_custom_fields_structure(reference_data)",
      "summary": "Test custom_fields section has correct structure.",
      "layer": "test",
      "docstring": "Test custom_fields section has correct structure.",
      "category": "test"
    },
    {
      "name": "test_enums_structure",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 94,
      "signature": "test_enums_structure(reference_data)",
      "summary": "Test enums section has correct structure.",
      "layer": "test",
      "docstring": "Test enums section has correct structure.",
      "category": "test"
    },
    {
      "name": "test_operators_structure",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 112,
      "signature": "test_operators_structure(reference_data)",
      "summary": "Test operators section has correct structure.",
      "layer": "test",
      "docstring": "Test operators section has correct structure.",
      "category": "test"
    },
    {
      "name": "test_functions_structure",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 136,
      "signature": "test_functions_structure(reference_data)",
      "summary": "Test functions section has correct structure.",
      "layer": "test",
      "docstring": "Test functions section has correct structure.",
      "category": "test"
    },
    {
      "name": "test_syntax_patterns_structure",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 153,
      "signature": "test_syntax_patterns_structure(reference_data)",
      "summary": "Test syntax_patterns section has correct structure.",
      "layer": "test",
      "docstring": "Test syntax_patterns section has correct structure.",
      "category": "test"
    },
    {
      "name": "test_examples_structure",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 171,
      "signature": "test_examples_structure(reference_data)",
      "summary": "Test examples section has correct structure.",
      "layer": "test",
      "docstring": "Test examples section has correct structure.",
      "category": "test"
    },
    {
      "name": "test_notes_section_exists",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 191,
      "signature": "test_notes_section_exists(reference_data)",
      "summary": "Test that notes section provides helpful guidance.",
      "layer": "test",
      "docstring": "Test that notes section provides helpful guidance.",
      "category": "test"
    },
    {
      "name": "test_listing_entity_has_key_fields",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 206,
      "signature": "test_listing_entity_has_key_fields(reference_data)",
      "summary": "Test that listing entity has essential fields.",
      "layer": "test",
      "docstring": "Test that listing entity has essential fields.",
      "category": "test"
    },
    {
      "name": "test_cpu_entity_has_benchmark_fields",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 222,
      "signature": "test_cpu_entity_has_benchmark_fields(reference_data)",
      "summary": "Test that CPU entity has benchmark fields.",
      "layer": "test",
      "docstring": "Test that CPU entity has benchmark fields.",
      "category": "test"
    },
    {
      "name": "test_ram_spec_has_ddr_generation",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 232,
      "signature": "test_ram_spec_has_ddr_generation(reference_data)",
      "summary": "Test that RAM spec has DDR generation field.",
      "layer": "test",
      "docstring": "Test that RAM spec has DDR generation field.",
      "category": "test"
    },
    {
      "name": "test_storage_has_medium_field",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 245,
      "signature": "test_storage_has_medium_field(reference_data)",
      "summary": "Test that storage entities have medium field.",
      "layer": "test",
      "docstring": "Test that storage entities have medium field.",
      "category": "test"
    },
    {
      "name": "test_examples_use_valid_field_references",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 256,
      "signature": "test_examples_use_valid_field_references(reference_data)",
      "summary": "Test that examples reference fields that exist in entities.",
      "layer": "test",
      "docstring": "Test that examples reference fields that exist in entities.",
      "category": "test"
    },
    {
      "name": "test_version_is_semver",
      "kind": "function",
      "path": "tests/scripts/test_formula_reference_generation.py",
      "line": 286,
      "signature": "test_version_is_semver(reference_data)",
      "summary": "Test that version follows semantic versioning.",
      "layer": "test",
      "docstring": "Test that version follows semantic versioning.",
      "category": "test"
    },
    {
      "name": "package_skill",
      "kind": "function",
      "path": ".claude/skills/skill-creator/scripts/package_skill.py",
      "line": 19,
      "signature": "package_skill(skill_path, output_dir)",
      "summary": "Package a skill folder into a zip file.",
      "layer": "core",
      "docstring": "Package a skill folder into a zip file.\n\nArgs:\n    skill_path: Path to the skill folder\n    output_dir: Optional output directory for the zip file (defaults to current directory)\n\nReturns:\n    Path to the created zip file, or None if error",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/skill-creator/scripts/package_skill.py",
      "line": 85,
      "signature": "main()",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "title_case_skill_name",
      "kind": "function",
      "path": ".claude/skills/skill-creator/scripts/init_skill.py",
      "line": 189,
      "signature": "title_case_skill_name(skill_name)",
      "summary": "Convert hyphenated skill name to Title Case for display.",
      "layer": "core",
      "docstring": "Convert hyphenated skill name to Title Case for display.",
      "category": "script"
    },
    {
      "name": "init_skill",
      "kind": "function",
      "path": ".claude/skills/skill-creator/scripts/init_skill.py",
      "line": 194,
      "signature": "init_skill(skill_name, path)",
      "summary": "Initialize a new skill directory with template SKILL.md.",
      "layer": "core",
      "docstring": "Initialize a new skill directory with template SKILL.md.\n\nArgs:\n    skill_name: Name of the skill\n    path: Path where the skill directory should be created\n\nReturns:\n    Path to created skill directory, or None if error",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/skill-creator/scripts/init_skill.py",
      "line": 273,
      "signature": "main()",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "validate_skill",
      "kind": "function",
      "path": ".claude/skills/skill-creator/scripts/quick_validate.py",
      "line": 11,
      "signature": "validate_skill(skill_path)",
      "summary": "Basic validation of a skill",
      "layer": "core",
      "docstring": "Basic validation of a skill",
      "category": "script"
    },
    {
      "name": "get_layer",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/add_layer_tags.py",
      "line": 62,
      "signature": "get_layer(path: str) -> str",
      "summary": "Determine layer from file path.",
      "layer": "core",
      "docstring": "Determine layer from file path.",
      "category": "script"
    },
    {
      "name": "add_layer_to_symbols",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/add_layer_tags.py",
      "line": 86,
      "signature": "add_layer_to_symbols(data: dict) -> dict",
      "summary": "Add layer field to all symbols in the structure.",
      "layer": "core",
      "docstring": "Add layer field to all symbols in the structure.",
      "category": "script"
    },
    {
      "name": "process_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/add_layer_tags.py",
      "line": 106,
      "signature": "process_file(input_path: str, output_path: str) -> tuple[int, int]",
      "summary": "Process a single symbol file and add layer tags.",
      "layer": "core",
      "docstring": "Process a single symbol file and add layer tags.\n\nReturns: (total_symbols, symbols_with_new_tags)",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/add_layer_tags.py",
      "line": 138,
      "signature": "main()",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "backfill_symbol",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/backfill_schema.py",
      "line": 39,
      "signature": "backfill_symbol(symbol: Dict[str, Any], module_path: str) -> Dict[str, Any]",
      "summary": "Backfill a single symbol to Schema v2.0.",
      "layer": "schema",
      "docstring": "Backfill a single symbol to Schema v2.0.\n\nArgs:\n    symbol: Symbol dictionary from old schema\n    module_path: Path from module level (for module-based structure)\n\nReturns:\n    Updated symbol dictionary conforming to Schema v2.0",
      "category": "business_logic"
    },
    {
      "name": "backfill_module",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/backfill_schema.py",
      "line": 92,
      "signature": "backfill_module(module: Dict[str, Any]) -> Dict[str, Any]",
      "summary": "Backfill all symbols in a module.",
      "layer": "schema",
      "docstring": "Backfill all symbols in a module.\n\nArgs:\n    module: Module dictionary with 'path' and 'symbols'\n\nReturns:\n    Updated module dictionary",
      "category": "business_logic"
    },
    {
      "name": "backfill_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/backfill_schema.py",
      "line": 114,
      "signature": "backfill_file(file_path: Path, dry_run: bool) -> Dict[str, Any]",
      "summary": "Backfill a symbol file to Schema v2.0.",
      "layer": "schema",
      "docstring": "Backfill a symbol file to Schema v2.0.\n\nArgs:\n    file_path: Path to symbol JSON file\n    dry_run: If True, don't write changes\n\nReturns:\n    Dictionary with results and statistics",
      "category": "business_logic"
    },
    {
      "name": "validate_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/backfill_schema.py",
      "line": 188,
      "signature": "validate_file(file_path: Path) -> Dict[str, Any]",
      "summary": "Validate a symbol file against Schema v2.0.",
      "layer": "schema",
      "docstring": "Validate a symbol file against Schema v2.0.\n\nArgs:\n    file_path: Path to symbol JSON file\n\nReturns:\n    Validation results dictionary",
      "category": "business_logic"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/backfill_schema.py",
      "line": 256,
      "signature": "main()",
      "summary": "Main entry point for the script.",
      "layer": "schema",
      "docstring": "Main entry point for the script.",
      "category": "business_logic"
    },
    {
      "name": "ConfigurationError",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 36,
      "signature": "class ConfigurationError(Exception)",
      "summary": "Raised when configuration is invalid or missing.",
      "layer": "core",
      "docstring": "Raised when configuration is invalid or missing.",
      "category": "script"
    },
    {
      "name": "DomainConfig",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 43,
      "signature": "class DomainConfig",
      "summary": "Configuration for a single domain.",
      "layer": "core",
      "docstring": "Configuration for a single domain.",
      "category": "script"
    },
    {
      "name": "LayerConfig",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 53,
      "signature": "class LayerConfig",
      "summary": "Configuration for a single API layer.",
      "layer": "core",
      "docstring": "Configuration for a single API layer.",
      "category": "script"
    },
    {
      "name": "ExtractionConfig",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 62,
      "signature": "class ExtractionConfig",
      "summary": "Configuration for symbol extraction.",
      "layer": "core",
      "docstring": "Configuration for symbol extraction.",
      "category": "script"
    },
    {
      "name": "MetadataConfig",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 73,
      "signature": "class MetadataConfig",
      "summary": "Optional metadata about the configuration.",
      "layer": "core",
      "docstring": "Optional metadata about the configuration.",
      "category": "script"
    },
    {
      "name": "SymbolConfig",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 82,
      "signature": "class SymbolConfig",
      "summary": "Symbol system configuration loader and accessor.",
      "layer": "core",
      "docstring": "Symbol system configuration loader and accessor.\n\nLoads configuration from symbols.config.json and provides convenient\nmethods for accessing paths, domains, layers, and extraction settings.\n\nAttributes:\n    project_name: Name of the project\n    symbols_dir: Directory where symbol files are stored\n    domains: Dictionary of domain configurations\n    api_layers: Dictionary of API layer configurations (optional)\n    extraction: Dictionary of extraction configurations by language\n    metadata: Optional metadata about the configuration",
      "category": "script"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 98,
      "signature": "__init__(self, config_path: Optional[Path])",
      "summary": "Initialize configuration from JSON file.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Initialize configuration from JSON file.\n\nArgs:\n    config_path: Path to configuration file (default: auto-detect)\n\nRaises:\n    ConfigurationError: If config file is missing or invalid",
      "category": "script"
    },
    {
      "name": "get_symbols_dir",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 314,
      "signature": "get_symbols_dir(self) -> Path",
      "summary": "Get the symbols directory path.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get the symbols directory path.\n\nReturns:\n    Absolute path to symbols directory",
      "category": "script"
    },
    {
      "name": "get_domain_file",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 323,
      "signature": "get_domain_file(self, domain: str) -> Path",
      "summary": "Get the symbol file path for a specific domain.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get the symbol file path for a specific domain.\n\nArgs:\n    domain: Domain name (e.g., \"ui\", \"web\", \"api\", \"shared\")\n\nReturns:\n    Absolute path to domain symbol file\n\nRaises:\n    ConfigurationError: If domain not found or disabled",
      "category": "script"
    },
    {
      "name": "get_test_file",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 352,
      "signature": "get_test_file(self, domain: str) -> Optional[Path]",
      "summary": "Get the test symbol file path for a specific domain.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get the test symbol file path for a specific domain.\n\nArgs:\n    domain: Domain name (e.g., \"ui\", \"web\", \"api\")\n\nReturns:\n    Absolute path to test symbol file, or None if not configured\n\nRaises:\n    ConfigurationError: If domain not found",
      "category": "script"
    },
    {
      "name": "get_api_layer_file",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 381,
      "signature": "get_api_layer_file(self, layer: str) -> Path",
      "summary": "Get the symbol file path for a specific API layer.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get the symbol file path for a specific API layer.\n\nArgs:\n    layer: Layer name (e.g., \"routers\", \"services\", \"repositories\")\n\nReturns:\n    Absolute path to layer symbol file\n\nRaises:\n    ConfigurationError: If layer not found, disabled, or not configured",
      "category": "script"
    },
    {
      "name": "get_domains",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 415,
      "signature": "get_domains(self) -> List[str]",
      "summary": "Get list of all configured domain names.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get list of all configured domain names.\n\nReturns:\n    List of domain names (enabled and disabled)",
      "category": "script"
    },
    {
      "name": "get_enabled_domains",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 424,
      "signature": "get_enabled_domains(self) -> List[str]",
      "summary": "Get list of enabled domain names.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get list of enabled domain names.\n\nReturns:\n    List of enabled domain names",
      "category": "script"
    },
    {
      "name": "get_api_layers",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 433,
      "signature": "get_api_layers(self) -> List[str]",
      "summary": "Get list of all configured API layer names.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get list of all configured API layer names.\n\nReturns:\n    List of layer names (enabled and disabled), or empty list if not configured",
      "category": "script"
    },
    {
      "name": "get_enabled_api_layers",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 442,
      "signature": "get_enabled_api_layers(self) -> List[str]",
      "summary": "Get list of enabled API layer names.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get list of enabled API layer names.\n\nReturns:\n    List of enabled layer names, or empty list if not configured",
      "category": "script"
    },
    {
      "name": "get_extraction_config",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 451,
      "signature": "get_extraction_config(self, language: Literal['python', 'typescript']) -> ExtractionConfig",
      "summary": "Get extraction configuration for a specific language.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get extraction configuration for a specific language.\n\nArgs:\n    language: Language name (\"python\" or \"typescript\")\n\nReturns:\n    Extraction configuration for the language\n\nRaises:\n    ConfigurationError: If language not configured",
      "category": "script"
    },
    {
      "name": "get_extraction_directories",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 473,
      "signature": "get_extraction_directories(self, language: Literal['python', 'typescript']) -> List[Path]",
      "summary": "Get absolute paths to extraction directories for a language.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "Get absolute paths to extraction directories for a language.\n\nArgs:\n    language: Language name (\"python\" or \"typescript\")\n\nReturns:\n    List of absolute directory paths\n\nRaises:\n    ConfigurationError: If language not configured",
      "category": "script"
    },
    {
      "name": "__repr__",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 489,
      "signature": "__repr__(self) -> str",
      "summary": "String representation of configuration.",
      "layer": "core",
      "parent": "SymbolConfig",
      "docstring": "String representation of configuration.",
      "category": "script"
    },
    {
      "name": "get_config",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 502,
      "signature": "get_config(config_path: Optional[Path], reload: bool) -> SymbolConfig",
      "summary": "Get the singleton configuration instance.",
      "layer": "core",
      "docstring": "Get the singleton configuration instance.\n\nArgs:\n    config_path: Path to configuration file (default: auto-detect)\n    reload: Force reload of configuration (default: False)\n\nReturns:\n    SymbolConfig instance\n\nRaises:\n    ConfigurationError: If configuration is invalid or missing\n\nExamples:\n    # Get default configuration\n    config = get_config()\n\n    # Force reload\n    config = get_config(reload=True)\n\n    # Use specific config file\n    config = get_config(Path(\"custom.config.json\"))",
      "category": "script"
    },
    {
      "name": "reset_config",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config.py",
      "line": 534,
      "signature": "reset_config() -> None",
      "summary": "Reset the singleton configuration instance (useful for testing).",
      "layer": "core",
      "docstring": "Reset the singleton configuration instance (useful for testing).",
      "category": "script"
    },
    {
      "name": "example_basic_usage",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config_example.py",
      "line": 17,
      "signature": "example_basic_usage()",
      "summary": "Example 1: Basic configuration access.",
      "layer": "core",
      "docstring": "Example 1: Basic configuration access.",
      "category": "script"
    },
    {
      "name": "example_domain_files",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config_example.py",
      "line": 32,
      "signature": "example_domain_files()",
      "summary": "Example 2: Accessing domain symbol files.",
      "layer": "core",
      "docstring": "Example 2: Accessing domain symbol files.",
      "category": "script"
    },
    {
      "name": "example_extraction_config",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config_example.py",
      "line": 73,
      "signature": "example_extraction_config()",
      "summary": "Example 3: Using extraction configuration.",
      "layer": "core",
      "docstring": "Example 3: Using extraction configuration.",
      "category": "script"
    },
    {
      "name": "example_migration_pattern",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config_example.py",
      "line": 99,
      "signature": "example_migration_pattern()",
      "summary": "Example 4: How to migrate from hardcoded paths.",
      "layer": "core",
      "docstring": "Example 4: How to migrate from hardcoded paths.",
      "category": "script"
    },
    {
      "name": "example_error_handling",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config_example.py",
      "line": 130,
      "signature": "example_error_handling()",
      "summary": "Example 5: Error handling.",
      "layer": "core",
      "docstring": "Example 5: Error handling.",
      "category": "script"
    },
    {
      "name": "example_conditional_features",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/config_example.py",
      "line": 154,
      "signature": "example_conditional_features()",
      "summary": "Example 6: Conditional features based on config.",
      "layer": "core",
      "docstring": "Example 6: Conditional features based on config.",
      "category": "script"
    },
    {
      "name": "Symbol",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 57,
      "signature": "class Symbol",
      "summary": "Represents a single extracted symbol (Schema v2.0).",
      "layer": "core",
      "docstring": "Represents a single extracted symbol (Schema v2.0).",
      "category": "script"
    },
    {
      "name": "PythonSymbolExtractor",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 71,
      "signature": "class PythonSymbolExtractor(ast.NodeVisitor)",
      "summary": "AST visitor that extracts symbols from Python source code.",
      "layer": "core",
      "docstring": "AST visitor that extracts symbols from Python source code.",
      "category": "script"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 74,
      "signature": "__init__(self, file_path: str, source_code: str)",
      "summary": "",
      "layer": "core",
      "parent": "PythonSymbolExtractor",
      "category": "script"
    },
    {
      "name": "visit_ClassDef",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 81,
      "signature": "visit_ClassDef(self, node: ast.ClassDef) -> None",
      "summary": "Extract class definitions.",
      "layer": "core",
      "parent": "PythonSymbolExtractor",
      "docstring": "Extract class definitions.",
      "category": "script"
    },
    {
      "name": "visit_FunctionDef",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 116,
      "signature": "visit_FunctionDef(self, node: ast.FunctionDef) -> None",
      "summary": "Extract function and method definitions.",
      "layer": "core",
      "parent": "PythonSymbolExtractor",
      "docstring": "Extract function and method definitions.",
      "category": "script"
    },
    {
      "name": "visit_AsyncFunctionDef",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 153,
      "signature": "visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None",
      "summary": "Extract async function and method definitions.",
      "layer": "core",
      "parent": "PythonSymbolExtractor",
      "docstring": "Extract async function and method definitions.",
      "category": "script"
    },
    {
      "name": "is_test_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 248,
      "signature": "is_test_file(file_path: Path) -> bool",
      "summary": "Check if a file is a test file.",
      "layer": "core",
      "docstring": "Check if a file is a test file.",
      "category": "script"
    },
    {
      "name": "categorize_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 259,
      "signature": "categorize_file(file_path: Path) -> tuple[str, str]",
      "summary": "Categorize a file by its architectural layer and optional category.",
      "layer": "core",
      "docstring": "Categorize a file by its architectural layer and optional category.\n\nReturns:\n    Tuple of (layer, category) where:\n    - layer: Architectural layer (router, service, repository, schema, model, core, middleware, auth, observability, test)\n    - category: Optional file category (business_logic, test, script, config, migration)",
      "category": "script"
    },
    {
      "name": "extract_symbols_from_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 328,
      "signature": "extract_symbols_from_file(file_path: Path, base_path: Path) -> List[Symbol]",
      "summary": "Extract symbols from a single Python file.",
      "layer": "core",
      "docstring": "Extract symbols from a single Python file.",
      "category": "script"
    },
    {
      "name": "extract_symbols_from_directory",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 361,
      "signature": "extract_symbols_from_directory(directory: Path, exclude_tests: bool, exclude_private: bool) -> List[Symbol]",
      "summary": "Extract symbols from all Python files in a directory.",
      "layer": "core",
      "docstring": "Extract symbols from all Python files in a directory.",
      "category": "script"
    },
    {
      "name": "symbols_to_dict",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 396,
      "signature": "symbols_to_dict(symbols: List[Symbol]) -> Dict[str, Any]",
      "summary": "Convert symbols list to output dictionary (Schema v2.0).",
      "layer": "core",
      "docstring": "Convert symbols list to output dictionary (Schema v2.0).",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_python.py",
      "line": 424,
      "signature": "main()",
      "summary": "Main entry point for the script.",
      "layer": "core",
      "docstring": "Main entry point for the script.",
      "category": "script"
    },
    {
      "name": "Symbol",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 54,
      "signature": "class Symbol",
      "summary": "Represents a single extracted symbol (Schema v2.0).",
      "layer": "core",
      "docstring": "Represents a single extracted symbol (Schema v2.0).",
      "category": "script"
    },
    {
      "name": "TypeScriptSymbolExtractor",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 68,
      "signature": "class TypeScriptSymbolExtractor",
      "summary": "Parser for TypeScript/JavaScript files using regex-based extraction.",
      "layer": "core",
      "docstring": "Parser for TypeScript/JavaScript files using regex-based extraction.",
      "category": "script"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 102,
      "signature": "__init__(self, file_path: str, source_code: str)",
      "summary": "",
      "layer": "core",
      "parent": "TypeScriptSymbolExtractor",
      "category": "script"
    },
    {
      "name": "extract",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 108,
      "signature": "extract(self) -> List[Symbol]",
      "summary": "Extract all symbols from the source code.",
      "layer": "core",
      "parent": "TypeScriptSymbolExtractor",
      "docstring": "Extract all symbols from the source code.",
      "category": "script"
    },
    {
      "name": "is_test_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 398,
      "signature": "is_test_file(file_path: Path) -> bool",
      "summary": "Check if a file is a test file.",
      "layer": "core",
      "docstring": "Check if a file is a test file.",
      "category": "script"
    },
    {
      "name": "is_typescript_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 416,
      "signature": "is_typescript_file(file_path: Path) -> bool",
      "summary": "Check if a file is a TypeScript or JavaScript file.",
      "layer": "core",
      "docstring": "Check if a file is a TypeScript or JavaScript file.",
      "category": "script"
    },
    {
      "name": "categorize_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 421,
      "signature": "categorize_file(file_path: Path) -> tuple[str, str]",
      "summary": "Categorize a TypeScript/JavaScript file by its architectural layer and category.",
      "layer": "core",
      "docstring": "Categorize a TypeScript/JavaScript file by its architectural layer and category.\n\nReturns:\n    Tuple of (layer, category) where:\n    - layer: Architectural layer (component, hook, page, util, router, service, test)\n    - category: Optional file category (ui, business_logic, test, config)",
      "category": "script"
    },
    {
      "name": "extract_symbols_from_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 470,
      "signature": "extract_symbols_from_file(file_path: Path, base_path: Path) -> List[Symbol]",
      "summary": "Extract symbols from a single TypeScript/JavaScript file.",
      "layer": "core",
      "docstring": "Extract symbols from a single TypeScript/JavaScript file.",
      "category": "script"
    },
    {
      "name": "extract_symbols_from_directory",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 497,
      "signature": "extract_symbols_from_directory(directory: Path, exclude_tests: bool, exclude_private: bool) -> List[Symbol]",
      "summary": "Extract symbols from all TypeScript/JavaScript files in a directory.",
      "layer": "core",
      "docstring": "Extract symbols from all TypeScript/JavaScript files in a directory.",
      "category": "script"
    },
    {
      "name": "symbols_to_dict",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 535,
      "signature": "symbols_to_dict(symbols: List[Symbol]) -> Dict[str, Any]",
      "summary": "Convert symbols list to output dictionary (Schema v2.0).",
      "layer": "core",
      "docstring": "Convert symbols list to output dictionary (Schema v2.0).",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/extract_symbols_typescript.py",
      "line": 563,
      "signature": "main()",
      "summary": "Main entry point for the script.",
      "layer": "core",
      "docstring": "Main entry point for the script.",
      "category": "script"
    },
    {
      "name": "separate_symbols_by_category",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/generate_api_symbols.py",
      "line": 34,
      "signature": "separate_symbols_by_category(symbols: List[Symbol]) -> Dict[str, List[Symbol]]",
      "summary": "Separate symbols into categories for different output files.",
      "layer": "core",
      "docstring": "Separate symbols into categories for different output files.\n\nReturns:\n    Dict with keys: 'business_logic', 'test', 'script'",
      "category": "script"
    },
    {
      "name": "symbols_to_output_format",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/generate_api_symbols.py",
      "line": 61,
      "signature": "symbols_to_output_format(symbols: List[Symbol], domain: str, category: str) -> Dict[str, Any]",
      "summary": "Convert symbols to output format grouped by file path.",
      "layer": "core",
      "docstring": "Convert symbols to output format grouped by file path.",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/generate_api_symbols.py",
      "line": 112,
      "signature": "main()",
      "summary": "Main entry point.",
      "layer": "core",
      "docstring": "Main entry point.",
      "category": "script"
    },
    {
      "name": "Fore",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 53,
      "signature": "class Fore",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "Style",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 56,
      "signature": "class Style",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "print_header",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 102,
      "signature": "print_header(text: str, char: str) -> None",
      "summary": "Print a formatted header.",
      "layer": "core",
      "docstring": "Print a formatted header.",
      "category": "script"
    },
    {
      "name": "print_success",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 112,
      "signature": "print_success(text: str) -> None",
      "summary": "Print success message.",
      "layer": "core",
      "docstring": "Print success message.",
      "category": "script"
    },
    {
      "name": "print_error",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 117,
      "signature": "print_error(text: str) -> None",
      "summary": "Print error message.",
      "layer": "core",
      "docstring": "Print error message.",
      "category": "script"
    },
    {
      "name": "print_warning",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 122,
      "signature": "print_warning(text: str) -> None",
      "summary": "Print warning message.",
      "layer": "core",
      "docstring": "Print warning message.",
      "category": "script"
    },
    {
      "name": "print_info",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 127,
      "signature": "print_info(text: str) -> None",
      "summary": "Print info message.",
      "layer": "core",
      "docstring": "Print info message.",
      "category": "script"
    },
    {
      "name": "print_step",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 132,
      "signature": "print_step(number: int, text: str) -> None",
      "summary": "Print step number and description.",
      "layer": "core",
      "docstring": "Print step number and description.",
      "category": "script"
    },
    {
      "name": "get_templates_dir",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 137,
      "signature": "get_templates_dir() -> Path",
      "summary": "Get the templates directory path.",
      "layer": "core",
      "docstring": "Get the templates directory path.",
      "category": "script"
    },
    {
      "name": "get_schema_path",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 143,
      "signature": "get_schema_path() -> Path",
      "summary": "Get the schema file path.",
      "layer": "core",
      "docstring": "Get the schema file path.",
      "category": "script"
    },
    {
      "name": "find_project_root",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 149,
      "signature": "find_project_root() -> Path",
      "summary": "Find the project root directory.",
      "layer": "core",
      "docstring": "Find the project root directory.\n\nLooks for common markers like .git, package.json, pyproject.toml.",
      "category": "script"
    },
    {
      "name": "detect_project_name",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 173,
      "signature": "detect_project_name() -> str",
      "summary": "Detect project name from git or directory name.",
      "layer": "core",
      "docstring": "Detect project name from git or directory name.",
      "category": "script"
    },
    {
      "name": "validate_project_name",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 200,
      "signature": "validate_project_name(name: str) -> bool",
      "summary": "Validate project name (alphanumeric, hyphens, underscores).",
      "layer": "core",
      "docstring": "Validate project name (alphanumeric, hyphens, underscores).",
      "category": "script"
    },
    {
      "name": "validate_directory",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 205,
      "signature": "validate_directory(directory: str) -> bool",
      "summary": "Validate directory name (no leading/trailing slashes).",
      "layer": "core",
      "docstring": "Validate directory name (no leading/trailing slashes).",
      "category": "script"
    },
    {
      "name": "list_templates",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 210,
      "signature": "list_templates() -> None",
      "summary": "List all available templates with details.",
      "layer": "core",
      "docstring": "List all available templates with details.",
      "category": "script"
    },
    {
      "name": "load_template",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 223,
      "signature": "load_template(template_id: str) -> Dict[str, Any]",
      "summary": "Load a template configuration.",
      "layer": "core",
      "docstring": "Load a template configuration.",
      "category": "script"
    },
    {
      "name": "replace_placeholders",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 235,
      "signature": "replace_placeholders(config: Dict[str, Any], project_name: str, symbols_dir: str) -> Dict[str, Any]",
      "summary": "Replace placeholders in template configuration.",
      "layer": "core",
      "docstring": "Replace placeholders in template configuration.",
      "category": "script"
    },
    {
      "name": "validate_against_schema",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 243,
      "signature": "validate_against_schema(config: Dict[str, Any]) -> tuple[bool, Optional[str]]",
      "summary": "Validate configuration against JSON schema.",
      "layer": "core",
      "docstring": "Validate configuration against JSON schema.\n\nReturns:\n    Tuple of (is_valid, error_message)",
      "category": "script"
    },
    {
      "name": "prompt_input",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 274,
      "signature": "prompt_input(prompt: str, default: Optional[str]) -> str",
      "summary": "Prompt user for input with optional default.",
      "layer": "core",
      "docstring": "Prompt user for input with optional default.",
      "category": "script"
    },
    {
      "name": "prompt_yes_no",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 285,
      "signature": "prompt_yes_no(prompt: str, default: bool) -> bool",
      "summary": "Prompt user for yes/no input.",
      "layer": "core",
      "docstring": "Prompt user for yes/no input.",
      "category": "script"
    },
    {
      "name": "show_welcome",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 296,
      "signature": "show_welcome() -> bool",
      "summary": "Show welcome screen and confirm user wants to proceed.",
      "layer": "core",
      "docstring": "Show welcome screen and confirm user wants to proceed.",
      "category": "script"
    },
    {
      "name": "select_template",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 319,
      "signature": "select_template(non_interactive: bool, template_arg: Optional[str]) -> str",
      "summary": "Select a project template.",
      "layer": "core",
      "docstring": "Select a project template.",
      "category": "script"
    },
    {
      "name": "customize_project",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 360,
      "signature": "customize_project(template_id: str, non_interactive: bool, project_name_arg: Optional[str], symbols_dir_arg: Optional[str]) -> tuple[str, str]",
      "summary": "Customize project name and symbols directory.",
      "layer": "core",
      "docstring": "Customize project name and symbols directory.",
      "category": "script"
    },
    {
      "name": "preview_configuration",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 402,
      "signature": "preview_configuration(config: Dict[str, Any]) -> None",
      "summary": "Preview the configuration before writing.",
      "layer": "core",
      "docstring": "Preview the configuration before writing.",
      "category": "script"
    },
    {
      "name": "write_configuration",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 436,
      "signature": "write_configuration(config: Dict[str, Any], output_path: Path, dry_run: bool, force: bool) -> bool",
      "summary": "Write configuration to file.",
      "layer": "core",
      "docstring": "Write configuration to file.\n\nReturns:\n    True if written successfully, False otherwise",
      "category": "script"
    },
    {
      "name": "show_next_steps",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 498,
      "signature": "show_next_steps(config: Dict[str, Any], output_path: Path) -> None",
      "summary": "Show next steps after configuration is created.",
      "layer": "core",
      "docstring": "Show next steps after configuration is created.",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/init_symbols.py",
      "line": 531,
      "signature": "main()",
      "summary": "Main entry point for the wizard.",
      "layer": "core",
      "docstring": "Main entry point for the wizard.",
      "category": "script"
    },
    {
      "name": "SymbolMerger",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/merge_symbols.py",
      "line": 62,
      "signature": "class SymbolMerger",
      "summary": "Handles merging of extracted symbols into existing symbol graphs.",
      "layer": "core",
      "docstring": "Handles merging of extracted symbols into existing symbol graphs.",
      "category": "script"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/merge_symbols.py",
      "line": 65,
      "signature": "__init__(self, project_root: Path, config)",
      "summary": "Initialize SymbolMerger.",
      "layer": "core",
      "parent": "SymbolMerger",
      "docstring": "Initialize SymbolMerger.\n\nArgs:\n    project_root: Project root directory\n    config: Optional SymbolConfig instance. If None, will attempt to load.",
      "category": "script"
    },
    {
      "name": "merge",
      "kind": "method",
      "path": ".claude/skills/symbols/scripts/merge_symbols.py",
      "line": 113,
      "signature": "merge(self, domain: str, extracted_symbols: List[Dict[str, Any]], validate: bool, backup: bool) -> Tuple[int, int, int]",
      "summary": "Merge extracted symbols into domain file.",
      "layer": "core",
      "parent": "SymbolMerger",
      "docstring": "Merge extracted symbols into domain file.\n\nArgs:\n    domain: Target domain (ui, api, shared)\n    extracted_symbols: List of extracted symbol dictionaries\n    validate: Whether to validate merged symbols\n    backup: Whether to create backup before writing\n\nReturns:\n    Tuple of (added, updated, total) counts",
      "category": "script"
    },
    {
      "name": "load_extracted_symbols",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/merge_symbols.py",
      "line": 423,
      "signature": "load_extracted_symbols(input_file: Path) -> List[Dict[str, Any]]",
      "summary": "Load extracted symbols from JSON file.",
      "layer": "core",
      "docstring": "Load extracted symbols from JSON file.",
      "category": "script"
    },
    {
      "name": "find_project_root",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/merge_symbols.py",
      "line": 443,
      "signature": "find_project_root() -> Path",
      "summary": "Find the project root directory (contains ai/ directory).",
      "layer": "core",
      "docstring": "Find the project root directory (contains ai/ directory).",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/merge_symbols.py",
      "line": 457,
      "signature": "main()",
      "summary": "Main entry point for the script.",
      "layer": "core",
      "docstring": "Main entry point for the script.",
      "category": "script"
    },
    {
      "name": "map_symbol_to_layer",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/split_api_by_layer.py",
      "line": 55,
      "signature": "map_symbol_to_layer(module_path: str) -> str",
      "summary": "Map a module path to its architectural layer.",
      "layer": "core",
      "docstring": "Map a module path to its architectural layer.\n\nArgs:\n    module_path: Relative path to the module (e.g., \"app/api/endpoints/prompts.py\")\n\nReturns:\n    Layer name: router, service, repository, schema, or core",
      "category": "script"
    },
    {
      "name": "validate_split",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/split_api_by_layer.py",
      "line": 78,
      "signature": "validate_split(original_modules: List[Dict], layers: Dict[str, List[Dict]]) -> Dict[str, Any]",
      "summary": "Validate that no symbols were lost during split.",
      "layer": "core",
      "docstring": "Validate that no symbols were lost during split.\n\nArgs:\n    original_modules: Original modules list from symbols-api.json\n    layers: Dictionary of layer -> modules mapping\n\nReturns:\n    Validation results dictionary with status and details",
      "category": "script"
    },
    {
      "name": "create_layer_file_metadata",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/split_api_by_layer.py",
      "line": 137,
      "signature": "create_layer_file_metadata(layer: str, modules: List[Dict]) -> Dict[str, Any]",
      "summary": "Create metadata for a layer file.",
      "layer": "core",
      "docstring": "Create metadata for a layer file.\n\nArgs:\n    layer: Layer name\n    modules: List of modules in this layer\n\nReturns:\n    Metadata dictionary with version, domain, language, etc.",
      "category": "script"
    },
    {
      "name": "split_api_by_layer",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/split_api_by_layer.py",
      "line": 162,
      "signature": "split_api_by_layer(input_path: Path, output_dir: Path, dry_run: bool) -> Dict[str, Any]",
      "summary": "Split symbols-api.json into layer-based files.",
      "layer": "core",
      "docstring": "Split symbols-api.json into layer-based files.\n\nArgs:\n    input_path: Path to symbols-api.json\n    output_dir: Directory to write layer files (usually ai/)\n    dry_run: If True, don't write files, just report what would happen\n\nReturns:\n    Dictionary with split results and statistics",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/split_api_by_layer.py",
      "line": 294,
      "signature": "main()",
      "summary": "Main entry point for the script.",
      "layer": "core",
      "docstring": "Main entry point for the script.",
      "category": "script"
    },
    {
      "name": "query_symbols",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/symbol_tools.py",
      "line": 115,
      "signature": "query_symbols(name: Optional[str], kind: Optional[str], domain: Optional[str], path: Optional[str], limit: int, summary_only: bool) -> List[Dict[str, Any]]",
      "summary": "Query symbols by name, kind, domain, or path without loading entire graph.",
      "layer": "core",
      "docstring": "Query symbols by name, kind, domain, or path without loading entire graph.\n\nArgs:\n    name: Symbol name (supports partial/fuzzy matching)\n    kind: Symbol kind (component, hook, function, class, interface, type, method)\n    domain: Domain filter (ui, api, shared)\n    path: File path pattern (e.g., \"components\", \"hooks\", \"services\")\n    limit: Maximum results to return (default: 20)\n    summary_only: Return only name and summary (default: False)\n\nReturns:\n    List of matching symbols with file path, line number, and summary",
      "category": "script"
    },
    {
      "name": "load_domain",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/symbol_tools.py",
      "line": 186,
      "signature": "load_domain(domain: Literal['ui', 'web', 'api', 'shared'], include_tests: bool, max_symbols: Optional[int]) -> Dict[str, Any]",
      "summary": "Load complete symbol set for a specific domain.",
      "layer": "core",
      "docstring": "Load complete symbol set for a specific domain.\n\nArgs:\n    domain: Domain to load (ui, web, api, shared)\n    include_tests: Include test file symbols (default: False)\n    max_symbols: Limit number of symbols returned (default: all)\n\nReturns:\n    Dict with domain, type, totalSymbols, and symbols array",
      "category": "script"
    },
    {
      "name": "load_api_layer",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/symbol_tools.py",
      "line": 264,
      "signature": "load_api_layer(layer: Literal['routers', 'services', 'repositories', 'schemas', 'cores'], max_symbols: Optional[int]) -> Dict[str, Any]",
      "summary": "Load symbols from a specific API architectural layer (Phase 2 optimization).",
      "layer": "core",
      "docstring": "Load symbols from a specific API architectural layer (Phase 2 optimization).\n\nProvides token-efficient access to specific API layers instead of loading\nthe entire 1.7MB unified API file. Use this for targeted backend development.\n\nArgs:\n    layer: API layer to load (routers, services, repositories, schemas, cores)\n    max_symbols: Limit number of symbols returned (default: all)\n\nReturns:\n    Dict with layer, totalSymbols, and symbols array\n\nExamples:\n    # Load only service layer for backend development (454 symbols, ~280KB)\n    services = load_api_layer(\"services\")\n\n    # Load schemas for DTO work (570 symbols, ~250KB)\n    schemas = load_api_layer(\"schemas\", max_symbols=100)",
      "category": "script"
    },
    {
      "name": "search_patterns",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/symbol_tools.py",
      "line": 327,
      "signature": "search_patterns(pattern: str, layer: Optional[str], priority: Optional[str], domain: Optional[str], limit: int) -> List[Dict[str, Any]]",
      "summary": "Advanced pattern-based search with architectural layer awareness.",
      "layer": "core",
      "docstring": "Advanced pattern-based search with architectural layer awareness.\n\nUses Schema v2.0 layer tags for precise filtering. Supports searching across\nall domains or targeting specific architectural layers.\n\nArgs:\n    pattern: Search pattern (supports regex)\n    layer: Architectural layer filter (router, service, repository, schema, component, hook, page, util, core, test)\n    priority: Priority filter (high, medium, low) - based on naming conventions\n    domain: Domain filter (ui, web, api, shared)\n    limit: Maximum results (default: 30)\n\nReturns:\n    List of matching symbols with layer and priority information\n\nExamples:\n    # Find all service classes matching \"Prompt\"\n    search_patterns(\"Prompt\", layer=\"service\")\n\n    # Find high-priority router functions\n    search_patterns(\".*Router\", layer=\"router\", priority=\"high\")\n\n    # Find UI components across all domains\n    search_patterns(\"Button\", layer=\"component\")",
      "category": "script"
    },
    {
      "name": "get_symbol_context",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/symbol_tools.py",
      "line": 430,
      "signature": "get_symbol_context(name: str, file: Optional[str], include_related: bool) -> Dict[str, Any]",
      "summary": "Get full context for a specific symbol including definition location and related symbols.",
      "layer": "core",
      "docstring": "Get full context for a specific symbol including definition location and related symbols.\n\nArgs:\n    name: Exact symbol name\n    file: File path if name is ambiguous\n    include_related: Include related symbols (imports, usages) (default: False)\n\nReturns:\n    Dict with symbol info and optionally related symbols",
      "category": "script"
    },
    {
      "name": "validate_symbols",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/symbol_tools.py",
      "line": 532,
      "signature": "validate_symbols(domain: Optional[str]) -> Dict[str, Any]",
      "summary": "Validate symbol files for all or specific domains.",
      "layer": "core",
      "docstring": "Validate symbol files for all or specific domains.\n\nPerforms comprehensive health checks including:\n- File existence and readability\n- Schema validity (required fields, valid kinds/layers)\n- Timestamp freshness (< 7 days warning, > 14 days error)\n- Duplicate detection (same name+file+line)\n- Missing required fields\n- Stale files (source file deleted but symbol exists)\n\nArgs:\n    domain: Specific domain to validate (None = all domains)\n\nReturns:\n    Validation report with status, errors, warnings, and statistics\n\nExample:\n    >>> report = validate_symbols()\n    >>> if report[\"status\"] == \"valid\":\n    ...     print(f\"All {report['summary']['total_symbols']} symbols are valid!\")\n    >>> else:\n    ...     print(f\"Found {report['summary']['total_errors']} errors\")\n\n    >>> report = validate_symbols(domain=\"ui\")\n    >>> ui_report = report[\"domains\"][\"ui\"]\n    >>> print(f\"UI domain has {ui_report['symbols_count']} symbols\")",
      "category": "script"
    },
    {
      "name": "update_symbols",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/symbol_tools.py",
      "line": 843,
      "signature": "update_symbols(mode: Literal['full', 'incremental', 'domain'], domain: Optional[str], files: Optional[List[str]], chunk: bool) -> Dict[str, Any]",
      "summary": "Trigger symbol graph regeneration or incremental update.",
      "layer": "core",
      "docstring": "Trigger symbol graph regeneration or incremental update.\n\nNote: This function provides the interface but delegates to existing\nslash commands for actual implementation.\n\nArgs:\n    mode: Update mode (full, incremental, domain)\n    domain: Specific domain to update (for domain mode)\n    files: Specific files to update (for incremental mode)\n    chunk: Re-chunk symbols after update (default: True)\n\nReturns:\n    Dict with update results",
      "category": "script"
    },
    {
      "name": "run_test",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/test_init_symbols.py",
      "line": 23,
      "signature": "run_test(name: str, command: list[str]) -> tuple[bool, str]",
      "summary": "Run a test command and return success status and output.",
      "layer": "test",
      "docstring": "Run a test command and return success status and output.",
      "category": "test"
    },
    {
      "name": "validate_config",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/test_init_symbols.py",
      "line": 54,
      "signature": "validate_config(config_path: Path) -> tuple[bool, str]",
      "summary": "Validate a generated configuration file.",
      "layer": "test",
      "docstring": "Validate a generated configuration file.",
      "category": "test"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/test_init_symbols.py",
      "line": 85,
      "signature": "main()",
      "summary": "Run all tests.",
      "layer": "test",
      "docstring": "Run all tests.",
      "category": "test"
    },
    {
      "name": "validate_symbol",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_schema.py",
      "line": 47,
      "signature": "validate_symbol(symbol: Dict[str, Any], context: str) -> Tuple[List[str], List[str]]",
      "summary": "Validate a single symbol against Schema v2.0.",
      "layer": "schema",
      "docstring": "Validate a single symbol against Schema v2.0.\n\nArgs:\n    symbol: Symbol dictionary\n    context: Context string for error messages (e.g., \"file:module:symbol\")\n\nReturns:\n    Tuple of (errors, warnings) lists",
      "category": "business_logic"
    },
    {
      "name": "validate_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_schema.py",
      "line": 94,
      "signature": "validate_file(file_path: Path, verbose: bool) -> Dict[str, Any]",
      "summary": "Validate a symbol file against Schema v2.0.",
      "layer": "schema",
      "docstring": "Validate a symbol file against Schema v2.0.\n\nArgs:\n    file_path: Path to symbol JSON file\n    verbose: If True, print all errors/warnings\n\nReturns:\n    Validation results dictionary",
      "category": "business_logic"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_schema.py",
      "line": 201,
      "signature": "main()",
      "summary": "Main entry point for the script.",
      "layer": "schema",
      "docstring": "Main entry point for the script.",
      "category": "business_logic"
    },
    {
      "name": "Fore",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 43,
      "signature": "class Fore",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "Style",
      "kind": "class",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 50,
      "signature": "class Style",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "print_color",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 78,
      "signature": "print_color(text: str, color: str, style: str) -> None",
      "summary": "Print colored text if colorama is available.",
      "layer": "core",
      "docstring": "Print colored text if colorama is available.",
      "category": "script"
    },
    {
      "name": "format_duration",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 86,
      "signature": "format_duration(seconds: float) -> str",
      "summary": "Format duration in human-readable format.",
      "layer": "core",
      "docstring": "Format duration in human-readable format.",
      "category": "script"
    },
    {
      "name": "validate_symbol_schema",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 97,
      "signature": "validate_symbol_schema(symbol: Dict[str, Any], file_path: Path, module_path: str) -> List[str]",
      "summary": "Validate a single symbol against Schema v2.0 requirements.",
      "layer": "core",
      "docstring": "Validate a single symbol against Schema v2.0 requirements.\n\nArgs:\n    symbol: Symbol dictionary to validate\n    file_path: Path to symbol file (for error messages)\n    module_path: Module path from symbol file (for error messages)\n\nReturns:\n    List of error messages (empty if valid)",
      "category": "script"
    },
    {
      "name": "check_source_file_exists",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 145,
      "signature": "check_source_file_exists(symbol_file_path: Path, source_path: str, project_root: Path) -> bool",
      "summary": "Check if the source file referenced in the symbol still exists.",
      "layer": "core",
      "docstring": "Check if the source file referenced in the symbol still exists.\n\nArgs:\n    symbol_file_path: Path to the symbol file\n    source_path: Source file path from symbol (relative or absolute)\n    project_root: Project root directory\n\nReturns:\n    True if source file exists, False otherwise",
      "category": "script"
    },
    {
      "name": "validate_domain_file",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 175,
      "signature": "validate_domain_file(domain_name: str, file_path: Path, project_root: Path, verbose: bool) -> Dict[str, Any]",
      "summary": "Validate a single domain symbol file.",
      "layer": "core",
      "docstring": "Validate a single domain symbol file.\n\nArgs:\n    domain_name: Domain name (e.g., \"ui\", \"api\")\n    file_path: Path to symbol file\n    project_root: Project root directory\n    verbose: Print detailed progress\n\nReturns:\n    Validation report for this domain",
      "category": "script"
    },
    {
      "name": "validate_symbols",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 315,
      "signature": "validate_symbols(domain: Optional[str], verbose: bool) -> Dict[str, Any]",
      "summary": "Validate symbol files for all or specific domains.",
      "layer": "core",
      "docstring": "Validate symbol files for all or specific domains.\n\nArgs:\n    domain: Specific domain to validate (None = all domains)\n    verbose: Print detailed progress\n\nReturns:\n    Validation report with status, errors, warnings, and statistics",
      "category": "script"
    },
    {
      "name": "print_report",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 452,
      "signature": "print_report(report: Dict[str, Any], verbose: bool) -> None",
      "summary": "Print formatted validation report to console.",
      "layer": "core",
      "docstring": "Print formatted validation report to console.\n\nArgs:\n    report: Validation report from validate_symbols()\n    verbose: Print detailed domain information",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/scripts/validate_symbols.py",
      "line": 555,
      "signature": "main() -> int",
      "summary": "Main entry point for validation command.",
      "layer": "core",
      "docstring": "Main entry point for validation command.\n\nReturns:\n    Exit code (0=success, 1=warnings, 2=errors)",
      "category": "script"
    },
    {
      "name": "TemplateValidator",
      "kind": "class",
      "path": ".claude/skills/symbols/templates/validate_templates.py",
      "line": 30,
      "signature": "class TemplateValidator",
      "summary": "Validates symbol configuration templates against the schema.",
      "layer": "core",
      "docstring": "Validates symbol configuration templates against the schema.",
      "category": "business_logic"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": ".claude/skills/symbols/templates/validate_templates.py",
      "line": 33,
      "signature": "__init__(self, schema_path: Path, templates_dir: Path)",
      "summary": "Initialize validator with schema and templates directory.",
      "layer": "core",
      "parent": "TemplateValidator",
      "docstring": "Initialize validator with schema and templates directory.\n\nArgs:\n    schema_path: Path to symbols-config-schema.json\n    templates_dir: Path to templates directory",
      "category": "business_logic"
    },
    {
      "name": "validate_template",
      "kind": "method",
      "path": ".claude/skills/symbols/templates/validate_templates.py",
      "line": 57,
      "signature": "validate_template(self, template_path: Path) -> Tuple[bool, List[str]]",
      "summary": "Validate a single template file.",
      "layer": "core",
      "parent": "TemplateValidator",
      "docstring": "Validate a single template file.\n\nArgs:\n    template_path: Path to template JSON file\n\nReturns:\n    Tuple of (is_valid, error_messages)",
      "category": "business_logic"
    },
    {
      "name": "validate_all",
      "kind": "method",
      "path": ".claude/skills/symbols/templates/validate_templates.py",
      "line": 167,
      "signature": "validate_all(self, verbose: bool) -> Tuple[int, int]",
      "summary": "Validate all template files in the templates directory.",
      "layer": "core",
      "parent": "TemplateValidator",
      "docstring": "Validate all template files in the templates directory.\n\nArgs:\n    verbose: If True, print detailed error messages\n\nReturns:\n    Tuple of (valid_count, total_count)",
      "category": "business_logic"
    },
    {
      "name": "main",
      "kind": "function",
      "path": ".claude/skills/symbols/templates/validate_templates.py",
      "line": 207,
      "signature": "main()",
      "summary": "Main entry point.",
      "layer": "core",
      "docstring": "Main entry point.",
      "category": "business_logic"
    },
    {
      "name": "parse",
      "kind": "function",
      "path": "node_modules/.pnpm/flatted@3.3.3/node_modules/flatted/python/flatted.py",
      "line": 117,
      "signature": "parse(value)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "stringify",
      "kind": "function",
      "path": "node_modules/.pnpm/flatted@3.3.3/node_modules/flatted/python/flatted.py",
      "line": 141,
      "signature": "stringify(value)",
      "summary": "",
      "layer": "core",
      "category": "business_logic"
    },
    {
      "name": "recalculate_all",
      "kind": "async_function",
      "path": "scripts/recalculate_all_metrics.py",
      "line": 25,
      "signature": "async recalculate_all()",
      "summary": "Recalculate metrics for all listings in the database.",
      "layer": "core",
      "docstring": "Recalculate metrics for all listings in the database.",
      "category": "script"
    },
    {
      "name": "seed_sample_listings",
      "kind": "async_function",
      "path": "scripts/seed_sample_listings.py",
      "line": 132,
      "signature": "async seed_sample_listings()",
      "summary": "Create sample listings with metadata and ports.",
      "layer": "core",
      "docstring": "Create sample listings with metadata and ports.",
      "category": "script"
    },
    {
      "name": "recalculate_all_cpu_marks",
      "kind": "async_function",
      "path": "scripts/recalculate_cpu_marks.py",
      "line": 21,
      "signature": "async recalculate_all_cpu_marks() -> None",
      "summary": "Recalculate CPU Mark metrics for all listings with CPUs.",
      "layer": "core",
      "docstring": "Recalculate CPU Mark metrics for all listings with CPUs.",
      "category": "script"
    },
    {
      "name": "LibraryImporter",
      "kind": "class",
      "path": "scripts/import_libraries.py",
      "line": 42,
      "signature": "class LibraryImporter",
      "summary": "Handles importing reference libraries into the database.",
      "layer": "core",
      "docstring": "Handles importing reference libraries into the database.",
      "category": "script"
    },
    {
      "name": "__init__",
      "kind": "method",
      "path": "scripts/import_libraries.py",
      "line": 45,
      "signature": "__init__(self, session: AsyncSession)",
      "summary": "",
      "layer": "core",
      "parent": "LibraryImporter",
      "category": "script"
    },
    {
      "name": "import_custom_fields",
      "kind": "async_method",
      "path": "scripts/import_libraries.py",
      "line": 50,
      "signature": "async import_custom_fields(self, filepath: Path) -> Dict[str, Any]",
      "summary": "Import custom field definitions from YAML.",
      "layer": "core",
      "parent": "LibraryImporter",
      "docstring": "Import custom field definitions from YAML.",
      "category": "script"
    },
    {
      "name": "import_rules_yaml",
      "kind": "async_method",
      "path": "scripts/import_libraries.py",
      "line": 113,
      "signature": "async import_rules_yaml(self, filepath: Path) -> Dict[str, Any]",
      "summary": "Import valuation rules from YAML.",
      "layer": "core",
      "parent": "LibraryImporter",
      "docstring": "Import valuation rules from YAML.",
      "category": "script"
    },
    {
      "name": "import_profiles",
      "kind": "async_method",
      "path": "scripts/import_libraries.py",
      "line": 253,
      "signature": "async import_profiles(self, filepath: Path) -> Dict[str, Any]",
      "summary": "Import scoring profiles from YAML.",
      "layer": "core",
      "parent": "LibraryImporter",
      "docstring": "Import scoring profiles from YAML.",
      "category": "script"
    },
    {
      "name": "import_all_fields",
      "kind": "async_function",
      "path": "scripts/import_libraries.py",
      "line": 310,
      "signature": "async import_all_fields(session: AsyncSession) -> List[Dict[str, Any]]",
      "summary": "Import all custom field libraries.",
      "layer": "core",
      "docstring": "Import all custom field libraries.",
      "category": "script"
    },
    {
      "name": "import_all_rules",
      "kind": "async_function",
      "path": "scripts/import_libraries.py",
      "line": 322,
      "signature": "async import_all_rules(session: AsyncSession) -> List[Dict[str, Any]]",
      "summary": "Import all rule libraries.",
      "layer": "core",
      "docstring": "Import all rule libraries.",
      "category": "script"
    },
    {
      "name": "import_all_profiles",
      "kind": "async_function",
      "path": "scripts/import_libraries.py",
      "line": 334,
      "signature": "async import_all_profiles(session: AsyncSession) -> List[Dict[str, Any]]",
      "summary": "Import all profile libraries.",
      "layer": "core",
      "docstring": "Import all profile libraries.",
      "category": "script"
    },
    {
      "name": "import_specific_ruleset",
      "kind": "async_function",
      "path": "scripts/import_libraries.py",
      "line": 346,
      "signature": "async import_specific_ruleset(session: AsyncSession, ruleset_name: str) -> Dict[str, Any]",
      "summary": "Import a specific ruleset by name.",
      "layer": "core",
      "docstring": "Import a specific ruleset by name.",
      "category": "script"
    },
    {
      "name": "print_summary",
      "kind": "function",
      "path": "scripts/import_libraries.py",
      "line": 366,
      "signature": "print_summary(results: List[Dict[str, Any]], import_type: str)",
      "summary": "Print import summary.",
      "layer": "core",
      "docstring": "Print import summary.",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "async_function",
      "path": "scripts/import_libraries.py",
      "line": 410,
      "signature": "async main()",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "parse_args",
      "kind": "function",
      "path": "scripts/import_entities.py",
      "line": 85,
      "signature": "parse_args() -> argparse.Namespace",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "async_function",
      "path": "scripts/import_entities.py",
      "line": 130,
      "signature": "async main() -> None",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "slugify",
      "kind": "function",
      "path": "scripts/update_cpus_from_passmark.py",
      "line": 31,
      "signature": "slugify(name: str) -> str",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "load_passmark_csv",
      "kind": "function",
      "path": "scripts/update_cpus_from_passmark.py",
      "line": 42,
      "signature": "load_passmark_csv(path: Path) -> Dict[str, Dict[str, Any]]",
      "summary": "Load PassMark CSV dump.",
      "layer": "core",
      "docstring": "Load PassMark CSV dump.\nSupported columns (CPUModelSummary.csv typical):\n  CPU Name,Rating,Rank,Num Thread Execution units,Avg Speed,Stock Speed,Samples,Single Thread,maxTDP,URL\nFallback supported (DetailedBenchmarks_sample.csv-like):\n  CPU name, CPU Mark, Single Thread, ... (we'll try to infer)\nReturns dict keyed by normalized name slug.",
      "category": "script"
    },
    {
      "name": "best_match",
      "kind": "function",
      "path": "scripts/update_cpus_from_passmark.py",
      "line": 105,
      "signature": "best_match(name: str, candidates: Dict[str, Dict[str, Any]]) -> Tuple[Optional[str], float]",
      "summary": "Return best matching key and score [0..1] for a given CPU name.",
      "layer": "core",
      "docstring": "Return best matching key and score [0..1] for a given CPU name.",
      "category": "script"
    },
    {
      "name": "update_cpu_json",
      "kind": "function",
      "path": "scripts/update_cpus_from_passmark.py",
      "line": 119,
      "signature": "update_cpu_json(cpu_json_path: Path, passmark_map: Dict[str, Dict[str, Any]], out_path: Path, min_match: float) -> Tuple[List[Dict[str, Any]], List[Tuple[str, str, float]]]",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "build_top_subset",
      "kind": "function",
      "path": "scripts/update_cpus_from_passmark.py",
      "line": 154,
      "signature": "build_top_subset(passmark_map: Dict[str, Dict[str, Any]], min_rating: int, min_samples: int, rank_top_n: int, keep_mobile: bool) -> List[Dict[str, Any]]",
      "summary": "Create a bounded 'top CPUs' list based on rating/samples (and optionally rank).",
      "layer": "core",
      "docstring": "Create a bounded 'top CPUs' list based on rating/samples (and optionally rank).\nHeuristics: filter out obscure ES/engineering samples; keep consumer desktop & mobile.",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": "scripts/update_cpus_from_passmark.py",
      "line": 199,
      "signature": "main()",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "function",
      "path": "scripts/import_passmark_data.py",
      "line": 35,
      "signature": "main() -> None",
      "summary": "",
      "layer": "core",
      "category": "script"
    },
    {
      "name": "derive_field_type",
      "kind": "function",
      "path": "scripts/fix_baseline_field_types.py",
      "line": 22,
      "signature": "derive_field_type(rule_meta: dict[str, Any]) -> str",
      "summary": "Derive the field type from rule metadata.",
      "layer": "core",
      "docstring": "Derive the field type from rule metadata.\n\nArgs:\n    rule_meta: Rule metadata dictionary\n\nReturns:\n    Field type: \"formula\", \"multiplier\", or \"scalar\"",
      "category": "script"
    },
    {
      "name": "fix_baseline_field_types",
      "kind": "async_function",
      "path": "scripts/fix_baseline_field_types.py",
      "line": 45,
      "signature": "async fix_baseline_field_types()",
      "summary": "Update all baseline rules with missing field_type.",
      "layer": "core",
      "docstring": "Update all baseline rules with missing field_type.",
      "category": "script"
    },
    {
      "name": "fetch_source_rule",
      "kind": "async_function",
      "path": "scripts/backfill_fk_metadata.py",
      "line": 82,
      "signature": "async fetch_source_rule(session: AsyncSession, source_rule_id: int) -> ValuationRuleV2 | None",
      "summary": "Fetch a source baseline rule by ID.",
      "layer": "core",
      "docstring": "Fetch a source baseline rule by ID.\n\nArgs:\n    session: Database session\n    source_rule_id: ID of the source rule\n\nReturns:\n    Source rule if found, None otherwise",
      "category": "script"
    },
    {
      "name": "backfill_fk_metadata",
      "kind": "async_function",
      "path": "scripts/backfill_fk_metadata.py",
      "line": 97,
      "signature": "async backfill_fk_metadata()",
      "summary": "Backfill is_foreign_key_rule metadata on existing hydrated rules.",
      "layer": "core",
      "docstring": "Backfill is_foreign_key_rule metadata on existing hydrated rules.",
      "category": "script"
    },
    {
      "name": "get_python_type_name",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 54,
      "signature": "get_python_type_name(column_type: Any) -> str",
      "summary": "Convert SQLAlchemy column type to Python type name.",
      "layer": "core",
      "docstring": "Convert SQLAlchemy column type to Python type name.",
      "category": "script"
    },
    {
      "name": "extract_model_fields",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 79,
      "signature": "extract_model_fields(model_class: Any, entity_name: str, access_pattern_prefix: str) -> dict[str, Any]",
      "summary": "Extract all fields from a SQLAlchemy model using inspection.",
      "layer": "core",
      "docstring": "Extract all fields from a SQLAlchemy model using inspection.\n\nArgs:\n    model_class: SQLAlchemy model class\n    entity_name: Human-readable entity name\n    access_pattern_prefix: Prefix for field access (e.g., \"cpu\" for cpu.cores)\n\nReturns:\n    Dictionary with field metadata",
      "category": "script"
    },
    {
      "name": "generate_field_description",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 149,
      "signature": "generate_field_description(field_name: str, entity_name: str) -> str",
      "summary": "Generate human-readable description for a field based on its name.",
      "layer": "core",
      "docstring": "Generate human-readable description for a field based on its name.",
      "category": "script"
    },
    {
      "name": "get_custom_fields",
      "kind": "async_function",
      "path": "scripts/generate_formula_reference.py",
      "line": 232,
      "signature": "async get_custom_fields(session: AsyncSession) -> dict[str, list[dict[str, Any]]]",
      "summary": "Query database for all custom field definitions grouped by entity.",
      "layer": "core",
      "docstring": "Query database for all custom field definitions grouped by entity.",
      "category": "script"
    },
    {
      "name": "generate_operators_reference",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 269,
      "signature": "generate_operators_reference() -> dict[str, Any]",
      "summary": "Generate reference for all supported operators.",
      "layer": "core",
      "docstring": "Generate reference for all supported operators.",
      "category": "script"
    },
    {
      "name": "generate_functions_reference",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 297,
      "signature": "generate_functions_reference() -> dict[str, Any]",
      "summary": "Generate reference for all supported functions.",
      "layer": "core",
      "docstring": "Generate reference for all supported functions.",
      "category": "script"
    },
    {
      "name": "generate_syntax_patterns",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 392,
      "signature": "generate_syntax_patterns() -> dict[str, Any]",
      "summary": "Generate reference for syntax patterns.",
      "layer": "core",
      "docstring": "Generate reference for syntax patterns.",
      "category": "script"
    },
    {
      "name": "generate_examples",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 454,
      "signature": "generate_examples() -> dict[str, Any]",
      "summary": "Generate example formulas with explanations.",
      "layer": "core",
      "docstring": "Generate example formulas with explanations.",
      "category": "script"
    },
    {
      "name": "generate_enum_reference",
      "kind": "function",
      "path": "scripts/generate_formula_reference.py",
      "line": 510,
      "signature": "generate_enum_reference() -> dict[str, Any]",
      "summary": "Generate reference for all enum types.",
      "layer": "core",
      "docstring": "Generate reference for all enum types.",
      "category": "script"
    },
    {
      "name": "generate_formula_reference",
      "kind": "async_function",
      "path": "scripts/generate_formula_reference.py",
      "line": 536,
      "signature": "async generate_formula_reference() -> dict[str, Any]",
      "summary": "Generate complete formula reference schema.",
      "layer": "core",
      "docstring": "Generate complete formula reference schema.",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "async_function",
      "path": "scripts/generate_formula_reference.py",
      "line": 634,
      "signature": "async main()",
      "summary": "Main execution function.",
      "layer": "core",
      "docstring": "Main execution function.",
      "category": "script"
    },
    {
      "name": "main",
      "kind": "async_function",
      "path": "scripts/verify_baseline_hydration_fixes.py",
      "line": 29,
      "signature": "async main()",
      "summary": "Verify baseline hydration fixes.",
      "layer": "core",
      "docstring": "Verify baseline hydration fixes.",
      "category": "script"
    },
    {
      "name": "demo_basic_parsing",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 20,
      "signature": "demo_basic_parsing()",
      "summary": "Demo basic formula parsing",
      "layer": "core",
      "docstring": "Demo basic formula parsing",
      "category": "business_logic"
    },
    {
      "name": "demo_error_messages",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 46,
      "signature": "demo_error_messages()",
      "summary": "Demo enhanced error messages",
      "layer": "core",
      "docstring": "Demo enhanced error messages",
      "category": "business_logic"
    },
    {
      "name": "demo_field_extraction",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 79,
      "signature": "demo_field_extraction()",
      "summary": "Demo field reference extraction",
      "layer": "core",
      "docstring": "Demo field reference extraction",
      "category": "business_logic"
    },
    {
      "name": "demo_ast_visualization",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 102,
      "signature": "demo_ast_visualization()",
      "summary": "Demo AST visualization",
      "layer": "core",
      "docstring": "Demo AST visualization",
      "category": "business_logic"
    },
    {
      "name": "demo_field_validation",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 125,
      "signature": "demo_field_validation()",
      "summary": "Demo field availability validation",
      "layer": "core",
      "docstring": "Demo field availability validation",
      "category": "business_logic"
    },
    {
      "name": "demo_validation_warnings",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 160,
      "signature": "demo_validation_warnings()",
      "summary": "Demo validation warnings and best practices",
      "layer": "core",
      "docstring": "Demo validation warnings and best practices",
      "category": "business_logic"
    },
    {
      "name": "demo_evaluation",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 195,
      "signature": "demo_evaluation()",
      "summary": "Demo formula evaluation with better error messages",
      "layer": "core",
      "docstring": "Demo formula evaluation with better error messages",
      "category": "business_logic"
    },
    {
      "name": "main",
      "kind": "function",
      "path": "examples/formula_validation_demo.py",
      "line": 231,
      "signature": "main()",
      "summary": "Run all demos",
      "layer": "core",
      "docstring": "Run all demos",
      "category": "business_logic"
    }
  ]
}